
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  00002a64  00002af8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a64  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000686  0080012e  0080012e  00002b26  2**0
                  ALLOC
  3 .stab         00007644  00000000  00000000  00002b28  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004382  00000000  00000000  0000a16c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e4ee  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e500  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e540  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000eb34  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f0d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f0f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 a2 11 	jmp	0x2344	; 0x2344 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e4 e6       	ldi	r30, 0x64	; 100
      7c:	fa e2       	ldi	r31, 0x2A	; 42
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ae 32       	cpi	r26, 0x2E	; 46
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ae e2       	ldi	r26, 0x2E	; 46
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a4 3b       	cpi	r26, 0xB4	; 180
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <main>
      9e:	0c 94 30 15 	jmp	0x2a60	; 0x2a60 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vSerial+0x6>
      ac:	cd b7       	in	r28, 0x3d	; 61
      ae:	de b7       	in	r29, 0x3e	; 62
      b0:	8c 01       	movw	r16, r24
	uart_init();
      b2:	0e 94 bf 11 	call	0x237e	; 0x237e <uart_init>
	stdin = stdout = stderr = &uart_file;
      b6:	80 e0       	ldi	r24, 0x00	; 0
      b8:	91 e0       	ldi	r25, 0x01	; 1
      ba:	90 93 b3 07 	sts	0x07B3, r25	; 0x8007b3 <__iob+0x5>
      be:	80 93 b2 07 	sts	0x07B2, r24	; 0x8007b2 <__iob+0x4>
      c2:	90 93 b1 07 	sts	0x07B1, r25	; 0x8007b1 <__iob+0x3>
      c6:	80 93 b0 07 	sts	0x07B0, r24	; 0x8007b0 <__iob+0x2>
      ca:	90 93 af 07 	sts	0x07AF, r25	; 0x8007af <__iob+0x1>
      ce:	80 93 ae 07 	sts	0x07AE, r24	; 0x8007ae <__iob>
	{
		value = 0;
		input = getchar();
		while (input >= 48 && input <= 57) 
		{
			value = value * 10 + (input - 48);
      d2:	8a e0       	ldi	r24, 0x0A	; 10
      d4:	f8 2e       	mov	r15, r24
	uint16_t value;
	char input;

	while(1)
	{
		value = 0;
      d6:	1a 82       	std	Y+2, r1	; 0x02
      d8:	19 82       	std	Y+1, r1	; 0x01
		input = getchar();
		while (input >= 48 && input <= 57) 
		{
			value = value * 10 + (input - 48);
			input = getchar();
      da:	80 91 ae 07 	lds	r24, 0x07AE	; 0x8007ae <__iob>
      de:	90 91 af 07 	lds	r25, 0x07AF	; 0x8007af <__iob+0x1>
      e2:	0e 94 14 12 	call	0x2428	; 0x2428 <fgetc>

	while(1)
	{
		value = 0;
		input = getchar();
		while (input >= 48 && input <= 57) 
      e6:	90 ed       	ldi	r25, 0xD0	; 208
      e8:	98 0f       	add	r25, r24
      ea:	9a 30       	cpi	r25, 0x0A	; 10
      ec:	88 f4       	brcc	.+34     	; 0x110 <vSerial+0x6a>
		{
			value = value * 10 + (input - 48);
      ee:	49 81       	ldd	r20, Y+1	; 0x01
      f0:	5a 81       	ldd	r21, Y+2	; 0x02
      f2:	f4 9e       	mul	r15, r20
      f4:	90 01       	movw	r18, r0
      f6:	f5 9e       	mul	r15, r21
      f8:	30 0d       	add	r19, r0
      fa:	11 24       	eor	r1, r1
      fc:	20 53       	subi	r18, 0x30	; 48
      fe:	31 09       	sbc	r19, r1
     100:	a9 01       	movw	r20, r18
     102:	48 0f       	add	r20, r24
     104:	51 1d       	adc	r21, r1
     106:	87 fd       	sbrc	r24, 7
     108:	5a 95       	dec	r21
     10a:	5a 83       	std	Y+2, r21	; 0x02
     10c:	49 83       	std	Y+1, r20	; 0x01
     10e:	e5 cf       	rjmp	.-54     	; 0xda <vSerial+0x34>
			input = getchar();
		}
        xQueueSend(xQueue, (void*)&value, (TickType_t)0);
     110:	20 e0       	ldi	r18, 0x00	; 0
     112:	40 e0       	ldi	r20, 0x00	; 0
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	be 01       	movw	r22, r28
     118:	6f 5f       	subi	r22, 0xFF	; 255
     11a:	7f 4f       	sbci	r23, 0xFF	; 255
     11c:	c8 01       	movw	r24, r16
     11e:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <xQueueGenericSend>
	}
     122:	d9 cf       	rjmp	.-78     	; 0xd6 <vSerial+0x30>

00000124 <vBlinkLed>:
 * \brief
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
     124:	cf 93       	push	r28
     126:	df 93       	push	r29
     128:	00 d0       	rcall	.+0      	; 0x12a <vBlinkLed+0x6>
     12a:	cd b7       	in	r28, 0x3d	; 61
     12c:	de b7       	in	r29, 0x3e	; 62
     12e:	7c 01       	movw	r14, r24
	QueueHandle_t xQueue = (QueueHandle_t)pvParameters;
	DDRB |= _BV(PB5);
     130:	25 9a       	sbi	0x04, 5	; 4
	uint16_t value; 

	PORTB &= ~_BV(PB5);
     132:	2d 98       	cbi	0x05, 5	; 5
	while(1)
	{
		if (xQueueReceive(xQueue, &value, (TickType_t)10) == pdPASS) {
			printf("Receive:%d\r\n", value);
     134:	0e e0       	ldi	r16, 0x0E	; 14
     136:	11 e0       	ldi	r17, 0x01	; 1
	uint16_t value; 

	PORTB &= ~_BV(PB5);
	while(1)
	{
		if (xQueueReceive(xQueue, &value, (TickType_t)10) == pdPASS) {
     138:	4a e0       	ldi	r20, 0x0A	; 10
     13a:	50 e0       	ldi	r21, 0x00	; 0
     13c:	be 01       	movw	r22, r28
     13e:	6f 5f       	subi	r22, 0xFF	; 255
     140:	7f 4f       	sbci	r23, 0xFF	; 255
     142:	c7 01       	movw	r24, r14
     144:	0e 94 b8 0a 	call	0x1570	; 0x1570 <xQueueReceive>
     148:	81 30       	cpi	r24, 0x01	; 1
     14a:	b1 f7       	brne	.-20     	; 0x138 <vBlinkLed+0x14>
			printf("Receive:%d\r\n", value);
     14c:	8a 81       	ldd	r24, Y+2	; 0x02
     14e:	8f 93       	push	r24
     150:	89 81       	ldd	r24, Y+1	; 0x01
     152:	8f 93       	push	r24
     154:	1f 93       	push	r17
     156:	0f 93       	push	r16
     158:	0e 94 52 12 	call	0x24a4	; 0x24a4 <printf>
			PORTB |= _BV(PB5);
     15c:	2d 9a       	sbi	0x05, 5	; 5
			vTaskDelay(value / portTICK_PERIOD_MS);
     15e:	89 81       	ldd	r24, Y+1	; 0x01
     160:	9a 81       	ldd	r25, Y+2	; 0x02
     162:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <vTaskDelay>
			PORTB &= ~_BV(PB5);
     166:	2d 98       	cbi	0x05, 5	; 5
			vTaskDelay(500 / portTICK_PERIOD_MS);
     168:	84 ef       	ldi	r24, 0xF4	; 244
     16a:	91 e0       	ldi	r25, 0x01	; 1
     16c:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <vTaskDelay>
     170:	0f 90       	pop	r0
     172:	0f 90       	pop	r0
     174:	0f 90       	pop	r0
     176:	0f 90       	pop	r0
     178:	df cf       	rjmp	.-66     	; 0x138 <vBlinkLed+0x14>

0000017a <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     17a:	08 95       	ret

0000017c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     17c:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     180:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     184:	80 81       	ld	r24, Z
     186:	81 11       	cpse	r24, r1
     188:	03 c0       	rjmp	.+6      	; 0x190 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     18a:	8f ef       	ldi	r24, 0xFF	; 255
     18c:	9f ef       	ldi	r25, 0xFF	; 255
     18e:	0c c0       	rjmp	.+24     	; 0x1a8 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     190:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     194:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     198:	05 80       	ldd	r0, Z+5	; 0x05
     19a:	f6 81       	ldd	r31, Z+6	; 0x06
     19c:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     19e:	06 80       	ldd	r0, Z+6	; 0x06
     1a0:	f7 81       	ldd	r31, Z+7	; 0x07
     1a2:	e0 2d       	mov	r30, r0
     1a4:	82 81       	ldd	r24, Z+2	; 0x02
     1a6:	93 81       	ldd	r25, Z+3	; 0x03
     1a8:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <xNextTaskUnblockTime+0x1>
     1ac:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xNextTaskUnblockTime>
     1b0:	08 95       	ret

000001b2 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     1b2:	ff 92       	push	r15
     1b4:	0f 93       	push	r16
     1b6:	1f 93       	push	r17
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	ec 01       	movw	r28, r24
     1be:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     1c0:	00 91 3b 01 	lds	r16, 0x013B	; 0x80013b <xTickCount>
     1c4:	10 91 3c 01 	lds	r17, 0x013C	; 0x80013c <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     1c8:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     1cc:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     1d0:	02 96       	adiw	r24, 0x02	; 2
     1d2:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     1d6:	cf 3f       	cpi	r28, 0xFF	; 255
     1d8:	8f ef       	ldi	r24, 0xFF	; 255
     1da:	d8 07       	cpc	r29, r24
     1dc:	89 f4       	brne	.+34     	; 0x200 <prvAddCurrentTaskToDelayedList+0x4e>
     1de:	ff 20       	and	r15, r15
     1e0:	79 f0       	breq	.+30     	; 0x200 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1e2:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     1e6:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
     1ea:	6e 5f       	subi	r22, 0xFE	; 254
     1ec:	7f 4f       	sbci	r23, 0xFF	; 255
     1ee:	8e e3       	ldi	r24, 0x3E	; 62
     1f0:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     1f2:	df 91       	pop	r29
     1f4:	cf 91       	pop	r28
     1f6:	1f 91       	pop	r17
     1f8:	0f 91       	pop	r16
     1fa:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1fc:	0c 94 bc 0d 	jmp	0x1b78	; 0x1b78 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     200:	c0 0f       	add	r28, r16
     202:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     204:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     208:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     20c:	d3 83       	std	Z+3, r29	; 0x03
     20e:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     210:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     214:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     218:	c0 17       	cp	r28, r16
     21a:	d1 07       	cpc	r29, r17
     21c:	68 f4       	brcc	.+26     	; 0x238 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     21e:	80 91 5a 01 	lds	r24, 0x015A	; 0x80015a <pxOverflowDelayedTaskList>
     222:	90 91 5b 01 	lds	r25, 0x015B	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     226:	6e 5f       	subi	r22, 0xFE	; 254
     228:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     22a:	df 91       	pop	r29
     22c:	cf 91       	pop	r28
     22e:	1f 91       	pop	r17
     230:	0f 91       	pop	r16
     232:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     234:	0c 94 dd 0d 	jmp	0x1bba	; 0x1bba <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     238:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <pxDelayedTaskList>
     23c:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     240:	6e 5f       	subi	r22, 0xFE	; 254
     242:	7f 4f       	sbci	r23, 0xFF	; 255
     244:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     248:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xNextTaskUnblockTime>
     24c:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <xNextTaskUnblockTime+0x1>
     250:	c8 17       	cp	r28, r24
     252:	d9 07       	cpc	r29, r25
     254:	20 f4       	brcc	.+8      	; 0x25e <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     256:	d0 93 34 01 	sts	0x0134, r29	; 0x800134 <xNextTaskUnblockTime+0x1>
     25a:	c0 93 33 01 	sts	0x0133, r28	; 0x800133 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     25e:	df 91       	pop	r29
     260:	cf 91       	pop	r28
     262:	1f 91       	pop	r17
     264:	0f 91       	pop	r16
     266:	ff 90       	pop	r15
     268:	08 95       	ret

0000026a <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     26a:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     26e:	88 23       	and	r24, r24
     270:	09 f1       	breq	.+66     	; 0x2b4 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     272:	0f b6       	in	r0, 0x3f	; 63
     274:	f8 94       	cli
     276:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     278:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <xTasksWaitingTermination+0x5>
     27c:	f0 91 4e 01 	lds	r31, 0x014E	; 0x80014e <xTasksWaitingTermination+0x6>
     280:	c6 81       	ldd	r28, Z+6	; 0x06
     282:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     284:	ce 01       	movw	r24, r28
     286:	02 96       	adiw	r24, 0x02	; 2
     288:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
				--uxCurrentNumberOfTasks;
     28c:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     290:	81 50       	subi	r24, 0x01	; 1
     292:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     296:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     29a:	81 50       	subi	r24, 0x01	; 1
     29c:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     2a0:	0f 90       	pop	r0
     2a2:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     2a4:	8f 89       	ldd	r24, Y+23	; 0x17
     2a6:	98 8d       	ldd	r25, Y+24	; 0x18
     2a8:	0e 94 31 10 	call	0x2062	; 0x2062 <vPortFree>
			vPortFree( pxTCB );
     2ac:	ce 01       	movw	r24, r28
     2ae:	0e 94 31 10 	call	0x2062	; 0x2062 <vPortFree>
     2b2:	db cf       	rjmp	.-74     	; 0x26a <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     2b4:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <pxReadyTasksLists>
     2b8:	82 30       	cpi	r24, 0x02	; 2
     2ba:	10 f0       	brcs	.+4      	; 0x2c0 <prvIdleTask+0x56>
			{
				taskYIELD();
     2bc:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     2c0:	0e 94 bd 00 	call	0x17a	; 0x17a <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     2c4:	d2 cf       	rjmp	.-92     	; 0x26a <prvIdleTask>

000002c6 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     2c6:	3f 92       	push	r3
     2c8:	4f 92       	push	r4
     2ca:	5f 92       	push	r5
     2cc:	6f 92       	push	r6
     2ce:	7f 92       	push	r7
     2d0:	8f 92       	push	r8
     2d2:	9f 92       	push	r9
     2d4:	af 92       	push	r10
     2d6:	bf 92       	push	r11
     2d8:	cf 92       	push	r12
     2da:	df 92       	push	r13
     2dc:	ef 92       	push	r14
     2de:	ff 92       	push	r15
     2e0:	0f 93       	push	r16
     2e2:	1f 93       	push	r17
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
     2e8:	4c 01       	movw	r8, r24
     2ea:	16 2f       	mov	r17, r22
     2ec:	37 2e       	mov	r3, r23
     2ee:	6a 01       	movw	r12, r20
     2f0:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     2f2:	ca 01       	movw	r24, r20
     2f4:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <pvPortMalloc>
     2f8:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     2fa:	89 2b       	or	r24, r25
     2fc:	09 f4       	brne	.+2      	; 0x300 <xTaskCreate+0x3a>
     2fe:	d1 c0       	rjmp	.+418    	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     300:	86 e2       	ldi	r24, 0x26	; 38
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <pvPortMalloc>
     308:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     30a:	89 2b       	or	r24, r25
     30c:	79 f0       	breq	.+30     	; 0x32c <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     30e:	58 8e       	std	Y+24, r5	; 0x18
     310:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     312:	c6 01       	movw	r24, r12
     314:	01 97       	sbiw	r24, 0x01	; 1
     316:	32 01       	movw	r6, r4
     318:	68 0e       	add	r6, r24
     31a:	79 1e       	adc	r7, r25
     31c:	be 01       	movw	r22, r28
     31e:	67 5e       	subi	r22, 0xE7	; 231
     320:	7f 4f       	sbci	r23, 0xFF	; 255
     322:	e1 2f       	mov	r30, r17
     324:	f3 2d       	mov	r31, r3
     326:	cf 01       	movw	r24, r30
     328:	08 96       	adiw	r24, 0x08	; 8
     32a:	07 c0       	rjmp	.+14     	; 0x33a <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     32c:	c2 01       	movw	r24, r4
     32e:	0e 94 31 10 	call	0x2062	; 0x2062 <vPortFree>
     332:	b7 c0       	rjmp	.+366    	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     334:	e8 17       	cp	r30, r24
     336:	f9 07       	cpc	r31, r25
     338:	49 f0       	breq	.+18     	; 0x34c <xTaskCreate+0x86>
     33a:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     33c:	41 91       	ld	r20, Z+
     33e:	db 01       	movw	r26, r22
     340:	4d 93       	st	X+, r20
     342:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     344:	d9 01       	movw	r26, r18
     346:	2c 91       	ld	r18, X
     348:	21 11       	cpse	r18, r1
     34a:	f4 cf       	rjmp	.-24     	; 0x334 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     34c:	18 a2       	std	Y+32, r1	; 0x20
     34e:	04 30       	cpi	r16, 0x04	; 4
     350:	08 f0       	brcs	.+2      	; 0x354 <xTaskCreate+0x8e>
     352:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     354:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     356:	6e 01       	movw	r12, r28
     358:	b2 e0       	ldi	r27, 0x02	; 2
     35a:	cb 0e       	add	r12, r27
     35c:	d1 1c       	adc	r13, r1
     35e:	c6 01       	movw	r24, r12
     360:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     364:	ce 01       	movw	r24, r28
     366:	0c 96       	adiw	r24, 0x0c	; 12
     368:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     36c:	d9 87       	std	Y+9, r29	; 0x09
     36e:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     370:	84 e0       	ldi	r24, 0x04	; 4
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	80 1b       	sub	r24, r16
     376:	91 09       	sbc	r25, r1
     378:	9d 87       	std	Y+13, r25	; 0x0d
     37a:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     37c:	db 8b       	std	Y+19, r29	; 0x13
     37e:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     380:	19 a2       	std	Y+33, r1	; 0x21
     382:	1a a2       	std	Y+34, r1	; 0x22
     384:	1b a2       	std	Y+35, r1	; 0x23
     386:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     388:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     38a:	a5 01       	movw	r20, r10
     38c:	b4 01       	movw	r22, r8
     38e:	c3 01       	movw	r24, r6
     390:	0e 94 40 10 	call	0x2080	; 0x2080 <pxPortInitialiseStack>
     394:	99 83       	std	Y+1, r25	; 0x01
     396:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     398:	e1 14       	cp	r14, r1
     39a:	f1 04       	cpc	r15, r1
     39c:	19 f0       	breq	.+6      	; 0x3a4 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     39e:	f7 01       	movw	r30, r14
     3a0:	d1 83       	std	Z+1, r29	; 0x01
     3a2:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     3a4:	0f b6       	in	r0, 0x3f	; 63
     3a6:	f8 94       	cli
     3a8:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     3aa:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     3ae:	8f 5f       	subi	r24, 0xFF	; 255
     3b0:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     3b4:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     3b8:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     3bc:	89 2b       	or	r24, r25
     3be:	d1 f5       	brne	.+116    	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     3c0:	d0 93 2f 01 	sts	0x012F, r29	; 0x80012f <__data_end+0x1>
     3c4:	c0 93 2e 01 	sts	0x012E, r28	; 0x80012e <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     3c8:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     3cc:	81 30       	cpi	r24, 0x01	; 1
     3ce:	09 f0       	breq	.+2      	; 0x3d2 <xTaskCreate+0x10c>
     3d0:	41 c0       	rjmp	.+130    	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     3d2:	80 e7       	ldi	r24, 0x70	; 112
     3d4:	91 e0       	ldi	r25, 0x01	; 1
     3d6:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
     3da:	89 e7       	ldi	r24, 0x79	; 121
     3dc:	91 e0       	ldi	r25, 0x01	; 1
     3de:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
     3e2:	82 e8       	ldi	r24, 0x82	; 130
     3e4:	91 e0       	ldi	r25, 0x01	; 1
     3e6:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
     3ea:	8b e8       	ldi	r24, 0x8B	; 139
     3ec:	91 e0       	ldi	r25, 0x01	; 1
     3ee:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     3f2:	87 e6       	ldi	r24, 0x67	; 103
     3f4:	91 e0       	ldi	r25, 0x01	; 1
     3f6:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     3fa:	8e e5       	ldi	r24, 0x5E	; 94
     3fc:	91 e0       	ldi	r25, 0x01	; 1
     3fe:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     402:	81 e5       	ldi	r24, 0x51	; 81
     404:	91 e0       	ldi	r25, 0x01	; 1
     406:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     40a:	88 e4       	ldi	r24, 0x48	; 72
     40c:	91 e0       	ldi	r25, 0x01	; 1
     40e:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     412:	8e e3       	ldi	r24, 0x3E	; 62
     414:	91 e0       	ldi	r25, 0x01	; 1
     416:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     41a:	87 e6       	ldi	r24, 0x67	; 103
     41c:	91 e0       	ldi	r25, 0x01	; 1
     41e:	90 93 5d 01 	sts	0x015D, r25	; 0x80015d <pxDelayedTaskList+0x1>
     422:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     426:	8e e5       	ldi	r24, 0x5E	; 94
     428:	91 e0       	ldi	r25, 0x01	; 1
     42a:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     42e:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <pxOverflowDelayedTaskList>
     432:	10 c0       	rjmp	.+32     	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     434:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     438:	81 11       	cpse	r24, r1
     43a:	0c c0       	rjmp	.+24     	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     43c:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     440:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     444:	96 89       	ldd	r25, Z+22	; 0x16
     446:	8e 89       	ldd	r24, Y+22	; 0x16
     448:	89 17       	cp	r24, r25
     44a:	20 f0       	brcs	.+8      	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
				{
					pxCurrentTCB = pxNewTCB;
     44c:	d0 93 2f 01 	sts	0x012F, r29	; 0x80012f <__data_end+0x1>
     450:	c0 93 2e 01 	sts	0x012E, r28	; 0x80012e <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     454:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxTaskNumber>
     458:	8f 5f       	subi	r24, 0xFF	; 255
     45a:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     45e:	8e 89       	ldd	r24, Y+22	; 0x16
     460:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     464:	98 17       	cp	r25, r24
     466:	10 f4       	brcc	.+4      	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
     468:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     46c:	f9 e0       	ldi	r31, 0x09	; 9
     46e:	8f 9f       	mul	r24, r31
     470:	c0 01       	movw	r24, r0
     472:	11 24       	eor	r1, r1
     474:	b6 01       	movw	r22, r12
     476:	80 59       	subi	r24, 0x90	; 144
     478:	9e 4f       	sbci	r25, 0xFE	; 254
     47a:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     47e:	0f 90       	pop	r0
     480:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     482:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     486:	88 23       	and	r24, r24
     488:	51 f0       	breq	.+20     	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     48a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     48e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     492:	96 89       	ldd	r25, Z+22	; 0x16
     494:	8e 89       	ldd	r24, Y+22	; 0x16
     496:	98 17       	cp	r25, r24
     498:	10 f4       	brcc	.+4      	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
		{
			taskYIELD_IF_USING_PREEMPTION();
     49a:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	01 c0       	rjmp	.+2      	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     4a2:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     4a4:	df 91       	pop	r29
     4a6:	cf 91       	pop	r28
     4a8:	1f 91       	pop	r17
     4aa:	0f 91       	pop	r16
     4ac:	ff 90       	pop	r15
     4ae:	ef 90       	pop	r14
     4b0:	df 90       	pop	r13
     4b2:	cf 90       	pop	r12
     4b4:	bf 90       	pop	r11
     4b6:	af 90       	pop	r10
     4b8:	9f 90       	pop	r9
     4ba:	8f 90       	pop	r8
     4bc:	7f 90       	pop	r7
     4be:	6f 90       	pop	r6
     4c0:	5f 90       	pop	r5
     4c2:	4f 90       	pop	r4
     4c4:	3f 90       	pop	r3
     4c6:	08 95       	ret

000004c8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     4c8:	0f 93       	push	r16
     4ca:	1f 93       	push	r17
     4cc:	cf 93       	push	r28
     4ce:	df 93       	push	r29
     4d0:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     4d2:	0f b6       	in	r0, 0x3f	; 63
     4d4:	f8 94       	cli
     4d6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     4d8:	89 2b       	or	r24, r25
     4da:	21 f4       	brne	.+8      	; 0x4e4 <vTaskDelete+0x1c>
     4dc:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <__data_end>
     4e0:	d0 91 2f 01 	lds	r29, 0x012F	; 0x80012f <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     4e4:	8e 01       	movw	r16, r28
     4e6:	0e 5f       	subi	r16, 0xFE	; 254
     4e8:	1f 4f       	sbci	r17, 0xFF	; 255
     4ea:	c8 01       	movw	r24, r16
     4ec:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     4f0:	8c 89       	ldd	r24, Y+20	; 0x14
     4f2:	9d 89       	ldd	r25, Y+21	; 0x15
     4f4:	89 2b       	or	r24, r25
     4f6:	21 f0       	breq	.+8      	; 0x500 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     4f8:	ce 01       	movw	r24, r28
     4fa:	0c 96       	adiw	r24, 0x0c	; 12
     4fc:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     500:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uxTaskNumber>
     504:	8f 5f       	subi	r24, 0xFF	; 255
     506:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     50a:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     50e:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     512:	c8 17       	cp	r28, r24
     514:	d9 07       	cpc	r29, r25
     516:	59 f4       	brne	.+22     	; 0x52e <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     518:	b8 01       	movw	r22, r16
     51a:	88 e4       	ldi	r24, 0x48	; 72
     51c:	91 e0       	ldi	r25, 0x01	; 1
     51e:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     522:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     526:	8f 5f       	subi	r24, 0xFF	; 255
     528:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <uxDeletedTasksWaitingCleanUp>
     52c:	0e c0       	rjmp	.+28     	; 0x54a <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     52e:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     532:	81 50       	subi	r24, 0x01	; 1
     534:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     538:	8f 89       	ldd	r24, Y+23	; 0x17
     53a:	98 8d       	ldd	r25, Y+24	; 0x18
     53c:	0e 94 31 10 	call	0x2062	; 0x2062 <vPortFree>
			vPortFree( pxTCB );
     540:	ce 01       	movw	r24, r28
     542:	0e 94 31 10 	call	0x2062	; 0x2062 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     546:	0e 94 be 00 	call	0x17c	; 0x17c <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     54a:	0f 90       	pop	r0
     54c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     54e:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     552:	88 23       	and	r24, r24
     554:	49 f0       	breq	.+18     	; 0x568 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     556:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     55a:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     55e:	c8 17       	cp	r28, r24
     560:	d9 07       	cpc	r29, r25
     562:	11 f4       	brne	.+4      	; 0x568 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     564:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     568:	df 91       	pop	r29
     56a:	cf 91       	pop	r28
     56c:	1f 91       	pop	r17
     56e:	0f 91       	pop	r16
     570:	08 95       	ret

00000572 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     572:	0f 93       	push	r16
     574:	1f 93       	push	r17
     576:	cf 93       	push	r28
     578:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     57a:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <__data_end>
     57e:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <__data_end+0x1>
     582:	82 17       	cp	r24, r18
     584:	93 07       	cpc	r25, r19
     586:	b9 f1       	breq	.+110    	; 0x5f6 <vTaskResume+0x84>
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	a9 f1       	breq	.+106    	; 0x5f6 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     58c:	0f b6       	in	r0, 0x3f	; 63
     58e:	f8 94       	cli
     590:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     592:	fc 01       	movw	r30, r24
     594:	22 85       	ldd	r18, Z+10	; 0x0a
     596:	33 85       	ldd	r19, Z+11	; 0x0b
     598:	2e 53       	subi	r18, 0x3E	; 62
     59a:	31 40       	sbci	r19, 0x01	; 1
     59c:	51 f5       	brne	.+84     	; 0x5f2 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     59e:	fc 01       	movw	r30, r24
     5a0:	24 89       	ldd	r18, Z+20	; 0x14
     5a2:	35 89       	ldd	r19, Z+21	; 0x15
     5a4:	f1 e0       	ldi	r31, 0x01	; 1
     5a6:	21 35       	cpi	r18, 0x51	; 81
     5a8:	3f 07       	cpc	r19, r31
     5aa:	19 f1       	breq	.+70     	; 0x5f2 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     5ac:	23 2b       	or	r18, r19
     5ae:	09 f5       	brne	.+66     	; 0x5f2 <vTaskResume+0x80>
     5b0:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     5b2:	8c 01       	movw	r16, r24
     5b4:	0e 5f       	subi	r16, 0xFE	; 254
     5b6:	1f 4f       	sbci	r17, 0xFF	; 255
     5b8:	c8 01       	movw	r24, r16
     5ba:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     5be:	8e 89       	ldd	r24, Y+22	; 0x16
     5c0:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     5c4:	98 17       	cp	r25, r24
     5c6:	10 f4       	brcc	.+4      	; 0x5cc <vTaskResume+0x5a>
     5c8:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     5cc:	29 e0       	ldi	r18, 0x09	; 9
     5ce:	82 9f       	mul	r24, r18
     5d0:	c0 01       	movw	r24, r0
     5d2:	11 24       	eor	r1, r1
     5d4:	b8 01       	movw	r22, r16
     5d6:	80 59       	subi	r24, 0x90	; 144
     5d8:	9e 4f       	sbci	r25, 0xFE	; 254
     5da:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     5de:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     5e2:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     5e6:	9e 89       	ldd	r25, Y+22	; 0x16
     5e8:	86 89       	ldd	r24, Z+22	; 0x16
     5ea:	98 17       	cp	r25, r24
     5ec:	10 f0       	brcs	.+4      	; 0x5f2 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     5ee:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     5f2:	0f 90       	pop	r0
     5f4:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	1f 91       	pop	r17
     5fc:	0f 91       	pop	r16
     5fe:	08 95       	ret

00000600 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     600:	ef 92       	push	r14
     602:	ff 92       	push	r15
     604:	1f 93       	push	r17
     606:	cf 93       	push	r28
     608:	df 93       	push	r29
     60a:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     60c:	8a 85       	ldd	r24, Y+10	; 0x0a
     60e:	9b 85       	ldd	r25, Y+11	; 0x0b
     610:	8e 53       	subi	r24, 0x3E	; 62
     612:	91 40       	sbci	r25, 0x01	; 1
     614:	99 f4       	brne	.+38     	; 0x63c <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     616:	8c 89       	ldd	r24, Y+20	; 0x14
     618:	9d 89       	ldd	r25, Y+21	; 0x15
     61a:	21 e0       	ldi	r18, 0x01	; 1
     61c:	81 35       	cpi	r24, 0x51	; 81
     61e:	92 07       	cpc	r25, r18
     620:	69 f0       	breq	.+26     	; 0x63c <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     622:	89 2b       	or	r24, r25
     624:	59 f4       	brne	.+22     	; 0x63c <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     626:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     62a:	88 23       	and	r24, r24
     62c:	49 f0       	breq	.+18     	; 0x640 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     62e:	be 01       	movw	r22, r28
     630:	64 5f       	subi	r22, 0xF4	; 244
     632:	7f 4f       	sbci	r23, 0xFF	; 255
     634:	81 e5       	ldi	r24, 0x51	; 81
     636:	91 e0       	ldi	r25, 0x01	; 1
     638:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     63c:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     63e:	21 c0       	rjmp	.+66     	; 0x682 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     640:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     644:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     648:	11 e0       	ldi	r17, 0x01	; 1
     64a:	9e 89       	ldd	r25, Y+22	; 0x16
     64c:	86 89       	ldd	r24, Z+22	; 0x16
     64e:	98 17       	cp	r25, r24
     650:	08 f4       	brcc	.+2      	; 0x654 <xTaskResumeFromISR+0x54>
     652:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     654:	7e 01       	movw	r14, r28
     656:	82 e0       	ldi	r24, 0x02	; 2
     658:	e8 0e       	add	r14, r24
     65a:	f1 1c       	adc	r15, r1
     65c:	c7 01       	movw	r24, r14
     65e:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     662:	8e 89       	ldd	r24, Y+22	; 0x16
     664:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     668:	98 17       	cp	r25, r24
     66a:	10 f4       	brcc	.+4      	; 0x670 <xTaskResumeFromISR+0x70>
     66c:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     670:	29 e0       	ldi	r18, 0x09	; 9
     672:	82 9f       	mul	r24, r18
     674:	c0 01       	movw	r24, r0
     676:	11 24       	eor	r1, r1
     678:	b7 01       	movw	r22, r14
     67a:	80 59       	subi	r24, 0x90	; 144
     67c:	9e 4f       	sbci	r25, 0xFE	; 254
     67e:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     682:	81 2f       	mov	r24, r17
     684:	df 91       	pop	r29
     686:	cf 91       	pop	r28
     688:	1f 91       	pop	r17
     68a:	ff 90       	pop	r15
     68c:	ef 90       	pop	r14
     68e:	08 95       	ret

00000690 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     690:	ef 92       	push	r14
     692:	ff 92       	push	r15
     694:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     696:	81 e3       	ldi	r24, 0x31	; 49
     698:	e8 2e       	mov	r14, r24
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	f8 2e       	mov	r15, r24
     69e:	00 e0       	ldi	r16, 0x00	; 0
     6a0:	20 e0       	ldi	r18, 0x00	; 0
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	45 e5       	ldi	r20, 0x55	; 85
     6a6:	50 e0       	ldi	r21, 0x00	; 0
     6a8:	68 e2       	ldi	r22, 0x28	; 40
     6aa:	71 e0       	ldi	r23, 0x01	; 1
     6ac:	85 e3       	ldi	r24, 0x35	; 53
     6ae:	91 e0       	ldi	r25, 0x01	; 1
     6b0:	0e 94 63 01 	call	0x2c6	; 0x2c6 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     6b4:	81 30       	cpi	r24, 0x01	; 1
     6b6:	91 f4       	brne	.+36     	; 0x6dc <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     6b8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     6ba:	2f ef       	ldi	r18, 0xFF	; 255
     6bc:	3f ef       	ldi	r19, 0xFF	; 255
     6be:	30 93 34 01 	sts	0x0134, r19	; 0x800134 <xNextTaskUnblockTime+0x1>
     6c2:	20 93 33 01 	sts	0x0133, r18	; 0x800133 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     6c6:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     6ca:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <xTickCount+0x1>
     6ce:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     6d2:	0f 91       	pop	r16
     6d4:	ff 90       	pop	r15
     6d6:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     6d8:	0c 94 ac 10 	jmp	0x2158	; 0x2158 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     6dc:	0f 91       	pop	r16
     6de:	ff 90       	pop	r15
     6e0:	ef 90       	pop	r14
     6e2:	08 95       	ret

000006e4 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     6e4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     6e6:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <xSchedulerRunning>
	vPortEndScheduler();
     6ea:	0c 94 ec 10 	jmp	0x21d8	; 0x21d8 <vPortEndScheduler>

000006ee <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     6ee:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     6f2:	8f 5f       	subi	r24, 0xFF	; 255
     6f4:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxSchedulerSuspended>
     6f8:	08 95       	ret

000006fa <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     6fa:	0f b6       	in	r0, 0x3f	; 63
     6fc:	f8 94       	cli
     6fe:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     700:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xTickCount>
     704:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     708:	0f 90       	pop	r0
     70a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     70c:	08 95       	ret

0000070e <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     70e:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xTickCount>
     712:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     716:	08 95       	ret

00000718 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     718:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
}
     71c:	08 95       	ret

0000071e <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     71e:	00 97       	sbiw	r24, 0x00	; 0
     720:	21 f4       	brne	.+8      	; 0x72a <pcTaskGetName+0xc>
     722:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     726:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     72a:	49 96       	adiw	r24, 0x19	; 25
     72c:	08 95       	ret

0000072e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     72e:	cf 92       	push	r12
     730:	df 92       	push	r13
     732:	ef 92       	push	r14
     734:	ff 92       	push	r15
     736:	0f 93       	push	r16
     738:	1f 93       	push	r17
     73a:	cf 93       	push	r28
     73c:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     73e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     742:	81 11       	cpse	r24, r1
     744:	8c c0       	rjmp	.+280    	; 0x85e <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     746:	00 91 3b 01 	lds	r16, 0x013B	; 0x80013b <xTickCount>
     74a:	10 91 3c 01 	lds	r17, 0x013C	; 0x80013c <xTickCount+0x1>
     74e:	0f 5f       	subi	r16, 0xFF	; 255
     750:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     752:	10 93 3c 01 	sts	0x013C, r17	; 0x80013c <xTickCount+0x1>
     756:	00 93 3b 01 	sts	0x013B, r16	; 0x80013b <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     75a:	01 15       	cp	r16, r1
     75c:	11 05       	cpc	r17, r1
     75e:	b9 f4       	brne	.+46     	; 0x78e <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     760:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <pxDelayedTaskList>
     764:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     768:	20 91 5a 01 	lds	r18, 0x015A	; 0x80015a <pxOverflowDelayedTaskList>
     76c:	30 91 5b 01 	lds	r19, 0x015B	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     770:	30 93 5d 01 	sts	0x015D, r19	; 0x80015d <pxDelayedTaskList+0x1>
     774:	20 93 5c 01 	sts	0x015C, r18	; 0x80015c <pxDelayedTaskList>
     778:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <pxOverflowDelayedTaskList+0x1>
     77c:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <pxOverflowDelayedTaskList>
     780:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <xNumOfOverflows>
     784:	8f 5f       	subi	r24, 0xFF	; 255
     786:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <xNumOfOverflows>
     78a:	0e 94 be 00 	call	0x17c	; 0x17c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     78e:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xNextTaskUnblockTime>
     792:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <xNextTaskUnblockTime+0x1>
     796:	c0 e0       	ldi	r28, 0x00	; 0
     798:	08 17       	cp	r16, r24
     79a:	19 07       	cpc	r17, r25
     79c:	08 f4       	brcc	.+2      	; 0x7a0 <xTaskIncrementTick+0x72>
     79e:	4f c0       	rjmp	.+158    	; 0x83e <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     7a0:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     7a2:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     7a6:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     7aa:	80 81       	ld	r24, Z
     7ac:	81 11       	cpse	r24, r1
     7ae:	03 c0       	rjmp	.+6      	; 0x7b6 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7b0:	8f ef       	ldi	r24, 0xFF	; 255
     7b2:	9f ef       	ldi	r25, 0xFF	; 255
     7b4:	11 c0       	rjmp	.+34     	; 0x7d8 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     7b6:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <pxDelayedTaskList>
     7ba:	f0 91 5d 01 	lds	r31, 0x015D	; 0x80015d <pxDelayedTaskList+0x1>
     7be:	05 80       	ldd	r0, Z+5	; 0x05
     7c0:	f6 81       	ldd	r31, Z+6	; 0x06
     7c2:	e0 2d       	mov	r30, r0
     7c4:	e6 80       	ldd	r14, Z+6	; 0x06
     7c6:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     7c8:	d7 01       	movw	r26, r14
     7ca:	12 96       	adiw	r26, 0x02	; 2
     7cc:	8d 91       	ld	r24, X+
     7ce:	9c 91       	ld	r25, X
     7d0:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     7d2:	08 17       	cp	r16, r24
     7d4:	19 07       	cpc	r17, r25
     7d6:	28 f4       	brcc	.+10     	; 0x7e2 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     7d8:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <xNextTaskUnblockTime+0x1>
     7dc:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     7e0:	2e c0       	rjmp	.+92     	; 0x83e <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7e2:	67 01       	movw	r12, r14
     7e4:	b2 e0       	ldi	r27, 0x02	; 2
     7e6:	cb 0e       	add	r12, r27
     7e8:	d1 1c       	adc	r13, r1
     7ea:	c6 01       	movw	r24, r12
     7ec:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     7f0:	f7 01       	movw	r30, r14
     7f2:	84 89       	ldd	r24, Z+20	; 0x14
     7f4:	95 89       	ldd	r25, Z+21	; 0x15
     7f6:	89 2b       	or	r24, r25
     7f8:	21 f0       	breq	.+8      	; 0x802 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     7fa:	c7 01       	movw	r24, r14
     7fc:	0c 96       	adiw	r24, 0x0c	; 12
     7fe:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     802:	d7 01       	movw	r26, r14
     804:	56 96       	adiw	r26, 0x16	; 22
     806:	8c 91       	ld	r24, X
     808:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     80c:	98 17       	cp	r25, r24
     80e:	10 f4       	brcc	.+4      	; 0x814 <xTaskIncrementTick+0xe6>
     810:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     814:	d8 9f       	mul	r29, r24
     816:	c0 01       	movw	r24, r0
     818:	11 24       	eor	r1, r1
     81a:	b6 01       	movw	r22, r12
     81c:	80 59       	subi	r24, 0x90	; 144
     81e:	9e 4f       	sbci	r25, 0xFE	; 254
     820:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     824:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     828:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     82c:	d7 01       	movw	r26, r14
     82e:	56 96       	adiw	r26, 0x16	; 22
     830:	9c 91       	ld	r25, X
     832:	86 89       	ldd	r24, Z+22	; 0x16
     834:	98 17       	cp	r25, r24
     836:	08 f4       	brcc	.+2      	; 0x83a <xTaskIncrementTick+0x10c>
     838:	b4 cf       	rjmp	.-152    	; 0x7a2 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     83a:	c1 e0       	ldi	r28, 0x01	; 1
     83c:	b2 cf       	rjmp	.-156    	; 0x7a2 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     83e:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     842:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     846:	e6 89       	ldd	r30, Z+22	; 0x16
     848:	b9 e0       	ldi	r27, 0x09	; 9
     84a:	eb 9f       	mul	r30, r27
     84c:	f0 01       	movw	r30, r0
     84e:	11 24       	eor	r1, r1
     850:	e0 59       	subi	r30, 0x90	; 144
     852:	fe 4f       	sbci	r31, 0xFE	; 254
     854:	80 81       	ld	r24, Z
     856:	82 30       	cpi	r24, 0x02	; 2
     858:	40 f0       	brcs	.+16     	; 0x86a <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     85a:	c1 e0       	ldi	r28, 0x01	; 1
     85c:	06 c0       	rjmp	.+12     	; 0x86a <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     85e:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <uxPendedTicks>
     862:	8f 5f       	subi	r24, 0xFF	; 255
     864:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     868:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     86a:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <xYieldPending>
     86e:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     870:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     872:	8c 2f       	mov	r24, r28
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	1f 91       	pop	r17
     87a:	0f 91       	pop	r16
     87c:	ff 90       	pop	r15
     87e:	ef 90       	pop	r14
     880:	df 90       	pop	r13
     882:	cf 90       	pop	r12
     884:	08 95       	ret

00000886 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	0f 93       	push	r16
     88c:	1f 93       	push	r17
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     898:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     89c:	81 50       	subi	r24, 0x01	; 1
     89e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8a2:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     8a6:	88 23       	and	r24, r24
     8a8:	11 f0       	breq	.+4      	; 0x8ae <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     8aa:	80 e0       	ldi	r24, 0x00	; 0
     8ac:	52 c0       	rjmp	.+164    	; 0x952 <__stack+0x53>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     8ae:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     8b2:	88 23       	and	r24, r24
     8b4:	d1 f3       	breq	.-12     	; 0x8aa <xTaskResumeAll+0x24>
     8b6:	c0 e0       	ldi	r28, 0x00	; 0
     8b8:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     8ba:	89 e0       	ldi	r24, 0x09	; 9
     8bc:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     8be:	ee 24       	eor	r14, r14
     8c0:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     8c2:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <xPendingReadyList>
     8c6:	88 23       	and	r24, r24
     8c8:	51 f1       	breq	.+84     	; 0x91e <__stack+0x1f>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     8ca:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <xPendingReadyList+0x5>
     8ce:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <xPendingReadyList+0x6>
     8d2:	c6 81       	ldd	r28, Z+6	; 0x06
     8d4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     8d6:	ce 01       	movw	r24, r28
     8d8:	0c 96       	adiw	r24, 0x0c	; 12
     8da:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     8de:	8e 01       	movw	r16, r28
     8e0:	0e 5f       	subi	r16, 0xFE	; 254
     8e2:	1f 4f       	sbci	r17, 0xFF	; 255
     8e4:	c8 01       	movw	r24, r16
     8e6:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     8ea:	8e 89       	ldd	r24, Y+22	; 0x16
     8ec:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     8f0:	98 17       	cp	r25, r24
     8f2:	10 f4       	brcc	.+4      	; 0x8f8 <xTaskResumeAll+0x72>
     8f4:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     8f8:	f8 9e       	mul	r15, r24
     8fa:	c0 01       	movw	r24, r0
     8fc:	11 24       	eor	r1, r1
     8fe:	b8 01       	movw	r22, r16
     900:	80 59       	subi	r24, 0x90	; 144
     902:	9e 4f       	sbci	r25, 0xFE	; 254
     904:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     908:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     90c:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     910:	9e 89       	ldd	r25, Y+22	; 0x16
     912:	86 89       	ldd	r24, Z+22	; 0x16
     914:	98 17       	cp	r25, r24
     916:	a8 f2       	brcs	.-86     	; 0x8c2 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     918:	e0 92 37 01 	sts	0x0137, r14	; 0x800137 <xYieldPending>
     91c:	d2 cf       	rjmp	.-92     	; 0x8c2 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     91e:	cd 2b       	or	r28, r29
     920:	11 f0       	breq	.+4      	; 0x926 <__stack+0x27>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     922:	0e 94 be 00 	call	0x17c	; 0x17c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     926:	c0 91 38 01 	lds	r28, 0x0138	; 0x800138 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     92a:	cc 23       	and	r28, r28
     92c:	51 f0       	breq	.+20     	; 0x942 <__stack+0x43>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     92e:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     930:	0e 94 97 03 	call	0x72e	; 0x72e <xTaskIncrementTick>
     934:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     936:	d0 93 37 01 	sts	0x0137, r29	; 0x800137 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     93a:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     93c:	c9 f7       	brne	.-14     	; 0x930 <__stack+0x31>

						uxPendedTicks = 0;
     93e:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     942:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <xYieldPending>
     946:	88 23       	and	r24, r24
     948:	09 f4       	brne	.+2      	; 0x94c <__stack+0x4d>
     94a:	af cf       	rjmp	.-162    	; 0x8aa <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     94c:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     950:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     952:	0f 90       	pop	r0
     954:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	1f 91       	pop	r17
     95c:	0f 91       	pop	r16
     95e:	ff 90       	pop	r15
     960:	ef 90       	pop	r14
     962:	08 95       	ret

00000964 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     964:	0f 93       	push	r16
     966:	1f 93       	push	r17
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	8c 01       	movw	r16, r24
     96e:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     970:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     974:	40 91 3b 01 	lds	r20, 0x013B	; 0x80013b <xTickCount>
     978:	50 91 3c 01 	lds	r21, 0x013C	; 0x80013c <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     97c:	f8 01       	movw	r30, r16
     97e:	20 81       	ld	r18, Z
     980:	31 81       	ldd	r19, Z+1	; 0x01
     982:	c9 01       	movw	r24, r18
     984:	8c 0f       	add	r24, r28
     986:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     988:	42 17       	cp	r20, r18
     98a:	53 07       	cpc	r21, r19
     98c:	20 f4       	brcc	.+8      	; 0x996 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     98e:	82 17       	cp	r24, r18
     990:	93 07       	cpc	r25, r19
     992:	40 f4       	brcc	.+16     	; 0x9a4 <vTaskDelayUntil+0x40>
     994:	03 c0       	rjmp	.+6      	; 0x99c <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     996:	82 17       	cp	r24, r18
     998:	93 07       	cpc	r25, r19
     99a:	30 f0       	brcs	.+12     	; 0x9a8 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     99c:	21 e0       	ldi	r18, 0x01	; 1
     99e:	48 17       	cp	r20, r24
     9a0:	59 07       	cpc	r21, r25
     9a2:	18 f0       	brcs	.+6      	; 0x9aa <vTaskDelayUntil+0x46>
     9a4:	20 e0       	ldi	r18, 0x00	; 0
     9a6:	01 c0       	rjmp	.+2      	; 0x9aa <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     9a8:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     9aa:	f8 01       	movw	r30, r16
     9ac:	91 83       	std	Z+1, r25	; 0x01
     9ae:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     9b0:	22 23       	and	r18, r18
     9b2:	29 f0       	breq	.+10     	; 0x9be <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     9b4:	60 e0       	ldi	r22, 0x00	; 0
     9b6:	84 1b       	sub	r24, r20
     9b8:	95 0b       	sbc	r25, r21
     9ba:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     9be:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9c2:	81 11       	cpse	r24, r1
     9c4:	02 c0       	rjmp	.+4      	; 0x9ca <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     9c6:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     9ca:	df 91       	pop	r29
     9cc:	cf 91       	pop	r28
     9ce:	1f 91       	pop	r17
     9d0:	0f 91       	pop	r16
     9d2:	08 95       	ret

000009d4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     9d4:	cf 93       	push	r28
     9d6:	df 93       	push	r29
     9d8:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     9da:	89 2b       	or	r24, r25
     9dc:	19 f4       	brne	.+6      	; 0x9e4 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     9de:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
     9e2:	0a c0       	rjmp	.+20     	; 0x9f8 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     9e4:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     9e8:	60 e0       	ldi	r22, 0x00	; 0
     9ea:	ce 01       	movw	r24, r28
     9ec:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     9f0:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9f4:	88 23       	and	r24, r24
     9f6:	99 f3       	breq	.-26     	; 0x9de <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	08 95       	ret

000009fe <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     9fe:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     a02:	88 23       	and	r24, r24
     a04:	21 f0       	breq	.+8      	; 0xa0e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
     a0c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a0e:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a12:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxTopReadyPriority>
     a16:	69 e0       	ldi	r22, 0x09	; 9
     a18:	48 2f       	mov	r20, r24
     a1a:	50 e0       	ldi	r21, 0x00	; 0
     a1c:	64 9f       	mul	r22, r20
     a1e:	90 01       	movw	r18, r0
     a20:	65 9f       	mul	r22, r21
     a22:	30 0d       	add	r19, r0
     a24:	11 24       	eor	r1, r1
     a26:	f9 01       	movw	r30, r18
     a28:	e0 59       	subi	r30, 0x90	; 144
     a2a:	fe 4f       	sbci	r31, 0xFE	; 254
     a2c:	90 81       	ld	r25, Z
     a2e:	91 11       	cpse	r25, r1
     a30:	02 c0       	rjmp	.+4      	; 0xa36 <vTaskSwitchContext+0x38>
     a32:	81 50       	subi	r24, 0x01	; 1
     a34:	f1 cf       	rjmp	.-30     	; 0xa18 <vTaskSwitchContext+0x1a>
     a36:	a1 81       	ldd	r26, Z+1	; 0x01
     a38:	b2 81       	ldd	r27, Z+2	; 0x02
     a3a:	12 96       	adiw	r26, 0x02	; 2
     a3c:	0d 90       	ld	r0, X+
     a3e:	bc 91       	ld	r27, X
     a40:	a0 2d       	mov	r26, r0
     a42:	b2 83       	std	Z+2, r27	; 0x02
     a44:	a1 83       	std	Z+1, r26	; 0x01
     a46:	2d 58       	subi	r18, 0x8D	; 141
     a48:	3e 4f       	sbci	r19, 0xFE	; 254
     a4a:	a2 17       	cp	r26, r18
     a4c:	b3 07       	cpc	r27, r19
     a4e:	31 f4       	brne	.+12     	; 0xa5c <vTaskSwitchContext+0x5e>
     a50:	12 96       	adiw	r26, 0x02	; 2
     a52:	2d 91       	ld	r18, X+
     a54:	3c 91       	ld	r19, X
     a56:	13 97       	sbiw	r26, 0x03	; 3
     a58:	32 83       	std	Z+2, r19	; 0x02
     a5a:	21 83       	std	Z+1, r18	; 0x01
     a5c:	99 e0       	ldi	r25, 0x09	; 9
     a5e:	94 9f       	mul	r25, r20
     a60:	f0 01       	movw	r30, r0
     a62:	95 9f       	mul	r25, r21
     a64:	f0 0d       	add	r31, r0
     a66:	11 24       	eor	r1, r1
     a68:	e0 59       	subi	r30, 0x90	; 144
     a6a:	fe 4f       	sbci	r31, 0xFE	; 254
     a6c:	01 80       	ldd	r0, Z+1	; 0x01
     a6e:	f2 81       	ldd	r31, Z+2	; 0x02
     a70:	e0 2d       	mov	r30, r0
     a72:	26 81       	ldd	r18, Z+6	; 0x06
     a74:	37 81       	ldd	r19, Z+7	; 0x07
     a76:	30 93 2f 01 	sts	0x012F, r19	; 0x80012f <__data_end+0x1>
     a7a:	20 93 2e 01 	sts	0x012E, r18	; 0x80012e <__data_end>
     a7e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     a82:	08 95       	ret

00000a84 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     a8e:	0f b6       	in	r0, 0x3f	; 63
     a90:	f8 94       	cli
     a92:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     a94:	89 2b       	or	r24, r25
     a96:	21 f4       	brne	.+8      	; 0xaa0 <vTaskSuspend+0x1c>
     a98:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <__data_end>
     a9c:	d0 91 2f 01 	lds	r29, 0x012F	; 0x80012f <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     aa0:	8e 01       	movw	r16, r28
     aa2:	0e 5f       	subi	r16, 0xFE	; 254
     aa4:	1f 4f       	sbci	r17, 0xFF	; 255
     aa6:	c8 01       	movw	r24, r16
     aa8:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     aac:	8c 89       	ldd	r24, Y+20	; 0x14
     aae:	9d 89       	ldd	r25, Y+21	; 0x15
     ab0:	89 2b       	or	r24, r25
     ab2:	21 f0       	breq	.+8      	; 0xabc <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ab4:	ce 01       	movw	r24, r28
     ab6:	0c 96       	adiw	r24, 0x0c	; 12
     ab8:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     abc:	b8 01       	movw	r22, r16
     abe:	8e e3       	ldi	r24, 0x3E	; 62
     ac0:	91 e0       	ldi	r25, 0x01	; 1
     ac2:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     ac6:	8d a1       	ldd	r24, Y+37	; 0x25
     ac8:	81 30       	cpi	r24, 0x01	; 1
     aca:	09 f4       	brne	.+2      	; 0xace <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     acc:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     ad2:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     ad6:	88 23       	and	r24, r24
     ad8:	39 f0       	breq	.+14     	; 0xae8 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     ada:	0f b6       	in	r0, 0x3f	; 63
     adc:	f8 94       	cli
     ade:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     ae0:	0e 94 be 00 	call	0x17c	; 0x17c <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     ae4:	0f 90       	pop	r0
     ae6:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     ae8:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
     aec:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>
     af0:	c8 17       	cp	r28, r24
     af2:	d9 07       	cpc	r29, r25
     af4:	c1 f4       	brne	.+48     	; 0xb26 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     af6:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xSchedulerRunning>
     afa:	88 23       	and	r24, r24
     afc:	19 f0       	breq	.+6      	; 0xb04 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     afe:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
     b02:	11 c0       	rjmp	.+34     	; 0xb26 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b04:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <xSuspendedTaskList>
     b08:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uxCurrentNumberOfTasks>
     b0c:	98 13       	cpse	r25, r24
     b0e:	05 c0       	rjmp	.+10     	; 0xb1a <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b10:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <__data_end+0x1>
     b14:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <__data_end>
     b18:	06 c0       	rjmp	.+12     	; 0xb26 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b1a:	df 91       	pop	r29
     b1c:	cf 91       	pop	r28
     b1e:	1f 91       	pop	r17
     b20:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b22:	0c 94 ff 04 	jmp	0x9fe	; 0x9fe <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b26:	df 91       	pop	r29
     b28:	cf 91       	pop	r28
     b2a:	1f 91       	pop	r17
     b2c:	0f 91       	pop	r16
     b2e:	08 95       	ret

00000b30 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     b30:	cf 93       	push	r28
     b32:	df 93       	push	r29
     b34:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b36:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     b3a:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
     b3e:	64 5f       	subi	r22, 0xF4	; 244
     b40:	7f 4f       	sbci	r23, 0xFF	; 255
     b42:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b46:	61 e0       	ldi	r22, 0x01	; 1
     b48:	ce 01       	movw	r24, r28
}
     b4a:	df 91       	pop	r29
     b4c:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b4e:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <prvAddCurrentTaskToDelayedList>

00000b52 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b58:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     b5c:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     b60:	70 68       	ori	r23, 0x80	; 128
     b62:	75 87       	std	Z+13, r23	; 0x0d
     b64:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b66:	60 91 2e 01 	lds	r22, 0x012E	; 0x80012e <__data_end>
     b6a:	70 91 2f 01 	lds	r23, 0x012F	; 0x80012f <__data_end+0x1>
     b6e:	64 5f       	subi	r22, 0xF4	; 244
     b70:	7f 4f       	sbci	r23, 0xFF	; 255
     b72:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b76:	61 e0       	ldi	r22, 0x01	; 1
     b78:	ce 01       	movw	r24, r28
}
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b7e:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <prvAddCurrentTaskToDelayedList>

00000b82 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     b82:	0f 93       	push	r16
     b84:	1f 93       	push	r17
     b86:	cf 93       	push	r28
     b88:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b8a:	dc 01       	movw	r26, r24
     b8c:	15 96       	adiw	r26, 0x05	; 5
     b8e:	ed 91       	ld	r30, X+
     b90:	fc 91       	ld	r31, X
     b92:	16 97       	sbiw	r26, 0x06	; 6
     b94:	c6 81       	ldd	r28, Z+6	; 0x06
     b96:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     b98:	8e 01       	movw	r16, r28
     b9a:	04 5f       	subi	r16, 0xF4	; 244
     b9c:	1f 4f       	sbci	r17, 0xFF	; 255
     b9e:	c8 01       	movw	r24, r16
     ba0:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ba4:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
     ba8:	81 11       	cpse	r24, r1
     baa:	14 c0       	rjmp	.+40     	; 0xbd4 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     bac:	0a 50       	subi	r16, 0x0A	; 10
     bae:	11 09       	sbc	r17, r1
     bb0:	c8 01       	movw	r24, r16
     bb2:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     bb6:	8e 89       	ldd	r24, Y+22	; 0x16
     bb8:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     bbc:	98 17       	cp	r25, r24
     bbe:	10 f4       	brcc	.+4      	; 0xbc4 <xTaskRemoveFromEventList+0x42>
     bc0:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     bc4:	b9 e0       	ldi	r27, 0x09	; 9
     bc6:	8b 9f       	mul	r24, r27
     bc8:	c0 01       	movw	r24, r0
     bca:	11 24       	eor	r1, r1
     bcc:	b8 01       	movw	r22, r16
     bce:	80 59       	subi	r24, 0x90	; 144
     bd0:	9e 4f       	sbci	r25, 0xFE	; 254
     bd2:	03 c0       	rjmp	.+6      	; 0xbda <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     bd4:	b8 01       	movw	r22, r16
     bd6:	81 e5       	ldi	r24, 0x51	; 81
     bd8:	91 e0       	ldi	r25, 0x01	; 1
     bda:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     bde:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     be2:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     be6:	9e 89       	ldd	r25, Y+22	; 0x16
     be8:	86 89       	ldd	r24, Z+22	; 0x16
     bea:	89 17       	cp	r24, r25
     bec:	20 f4       	brcc	.+8      	; 0xbf6 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     bee:	81 e0       	ldi	r24, 0x01	; 1
     bf0:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
     bf4:	01 c0       	rjmp	.+2      	; 0xbf8 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     bf6:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     bf8:	df 91       	pop	r29
     bfa:	cf 91       	pop	r28
     bfc:	1f 91       	pop	r17
     bfe:	0f 91       	pop	r16
     c00:	08 95       	ret

00000c02 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c02:	0f 93       	push	r16
     c04:	1f 93       	push	r17
     c06:	cf 93       	push	r28
     c08:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c0a:	70 68       	ori	r23, 0x80	; 128
     c0c:	fc 01       	movw	r30, r24
     c0e:	71 83       	std	Z+1, r23	; 0x01
     c10:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c12:	c6 81       	ldd	r28, Z+6	; 0x06
     c14:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c16:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c1a:	8e 01       	movw	r16, r28
     c1c:	0e 5f       	subi	r16, 0xFE	; 254
     c1e:	1f 4f       	sbci	r17, 0xFF	; 255
     c20:	c8 01       	movw	r24, r16
     c22:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c26:	8e 89       	ldd	r24, Y+22	; 0x16
     c28:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     c2c:	98 17       	cp	r25, r24
     c2e:	10 f4       	brcc	.+4      	; 0xc34 <vTaskRemoveFromUnorderedEventList+0x32>
     c30:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     c34:	f9 e0       	ldi	r31, 0x09	; 9
     c36:	8f 9f       	mul	r24, r31
     c38:	c0 01       	movw	r24, r0
     c3a:	11 24       	eor	r1, r1
     c3c:	b8 01       	movw	r22, r16
     c3e:	80 59       	subi	r24, 0x90	; 144
     c40:	9e 4f       	sbci	r25, 0xFE	; 254
     c42:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c46:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     c4a:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     c4e:	9e 89       	ldd	r25, Y+22	; 0x16
     c50:	86 89       	ldd	r24, Z+22	; 0x16
     c52:	89 17       	cp	r24, r25
     c54:	18 f4       	brcc	.+6      	; 0xc5c <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
	}
}
     c5c:	df 91       	pop	r29
     c5e:	cf 91       	pop	r28
     c60:	1f 91       	pop	r17
     c62:	0f 91       	pop	r16
     c64:	08 95       	ret

00000c66 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     c66:	0f b6       	in	r0, 0x3f	; 63
     c68:	f8 94       	cli
     c6a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     c6c:	20 91 36 01 	lds	r18, 0x0136	; 0x800136 <xNumOfOverflows>
     c70:	fc 01       	movw	r30, r24
     c72:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     c74:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <xTickCount>
     c78:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <xTickCount+0x1>
     c7c:	32 83       	std	Z+2, r19	; 0x02
     c7e:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     c80:	0f 90       	pop	r0
     c82:	0f be       	out	0x3f, r0	; 63
     c84:	08 95       	ret

00000c86 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     c86:	20 91 36 01 	lds	r18, 0x0136	; 0x800136 <xNumOfOverflows>
     c8a:	fc 01       	movw	r30, r24
     c8c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     c8e:	20 91 3b 01 	lds	r18, 0x013B	; 0x80013b <xTickCount>
     c92:	30 91 3c 01 	lds	r19, 0x013C	; 0x80013c <xTickCount+0x1>
     c96:	32 83       	std	Z+2, r19	; 0x02
     c98:	21 83       	std	Z+1, r18	; 0x01
     c9a:	08 95       	ret

00000c9c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     c9c:	cf 93       	push	r28
     c9e:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     ca0:	0f b6       	in	r0, 0x3f	; 63
     ca2:	f8 94       	cli
     ca4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     ca6:	40 91 3b 01 	lds	r20, 0x013B	; 0x80013b <xTickCount>
     caa:	50 91 3c 01 	lds	r21, 0x013C	; 0x80013c <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     cae:	db 01       	movw	r26, r22
     cb0:	2d 91       	ld	r18, X+
     cb2:	3c 91       	ld	r19, X
     cb4:	2f 3f       	cpi	r18, 0xFF	; 255
     cb6:	bf ef       	ldi	r27, 0xFF	; 255
     cb8:	3b 07       	cpc	r19, r27
     cba:	d9 f0       	breq	.+54     	; 0xcf2 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     cbc:	ec 01       	movw	r28, r24
     cbe:	e9 81       	ldd	r30, Y+1	; 0x01
     cc0:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     cc2:	a0 91 36 01 	lds	r26, 0x0136	; 0x800136 <xNumOfOverflows>
     cc6:	b8 81       	ld	r27, Y
     cc8:	ba 17       	cp	r27, r26
     cca:	19 f0       	breq	.+6      	; 0xcd2 <xTaskCheckForTimeOut+0x36>
     ccc:	4e 17       	cp	r20, r30
     cce:	5f 07       	cpc	r21, r31
     cd0:	90 f4       	brcc	.+36     	; 0xcf6 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     cd2:	4e 1b       	sub	r20, r30
     cd4:	5f 0b       	sbc	r21, r31
     cd6:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     cd8:	42 17       	cp	r20, r18
     cda:	53 07       	cpc	r21, r19
     cdc:	38 f4       	brcc	.+14     	; 0xcec <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     cde:	24 1b       	sub	r18, r20
     ce0:	35 0b       	sbc	r19, r21
     ce2:	31 83       	std	Z+1, r19	; 0x01
     ce4:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     ce6:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskInternalSetTimeOutState>
     cea:	03 c0       	rjmp	.+6      	; 0xcf2 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     cec:	11 82       	std	Z+1, r1	; 0x01
     cee:	10 82       	st	Z, r1
     cf0:	02 c0       	rjmp	.+4      	; 0xcf6 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     cf2:	80 e0       	ldi	r24, 0x00	; 0
     cf4:	01 c0       	rjmp	.+2      	; 0xcf8 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     cf6:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     cf8:	0f 90       	pop	r0
     cfa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     cfc:	df 91       	pop	r29
     cfe:	cf 91       	pop	r28
     d00:	08 95       	ret

00000d02 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
     d08:	08 95       	ret

00000d0a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d0a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d0e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d12:	84 85       	ldd	r24, Z+12	; 0x0c
     d14:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d16:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d1a:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d1e:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
     d22:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
     d26:	56 96       	adiw	r26, 0x16	; 22
     d28:	4c 91       	ld	r20, X
     d2a:	24 e0       	ldi	r18, 0x04	; 4
     d2c:	30 e0       	ldi	r19, 0x00	; 0
     d2e:	24 1b       	sub	r18, r20
     d30:	31 09       	sbc	r19, r1
     d32:	35 87       	std	Z+13, r19	; 0x0d
     d34:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     d36:	08 95       	ret

00000d38 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     d38:	0f 93       	push	r16
     d3a:	1f 93       	push	r17
     d3c:	18 2f       	mov	r17, r24
     d3e:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	f8 94       	cli
     d44:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     d46:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d4a:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d4e:	41 a1       	ldd	r20, Z+33	; 0x21
     d50:	52 a1       	ldd	r21, Z+34	; 0x22
     d52:	63 a1       	ldd	r22, Z+35	; 0x23
     d54:	74 a1       	ldd	r23, Z+36	; 0x24
     d56:	45 2b       	or	r20, r21
     d58:	46 2b       	or	r20, r22
     d5a:	47 2b       	or	r20, r23
     d5c:	69 f4       	brne	.+26     	; 0xd78 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     d5e:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d62:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d66:	21 e0       	ldi	r18, 0x01	; 1
     d68:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     d6a:	00 97       	sbiw	r24, 0x00	; 0
     d6c:	29 f0       	breq	.+10     	; 0xd78 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     d6e:	61 e0       	ldi	r22, 0x01	; 1
     d70:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     d74:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     d82:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     d86:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     d8a:	61 a1       	ldd	r22, Z+33	; 0x21
     d8c:	72 a1       	ldd	r23, Z+34	; 0x22
     d8e:	83 a1       	ldd	r24, Z+35	; 0x23
     d90:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     d92:	61 15       	cp	r22, r1
     d94:	71 05       	cpc	r23, r1
     d96:	81 05       	cpc	r24, r1
     d98:	91 05       	cpc	r25, r1
     d9a:	a9 f0       	breq	.+42     	; 0xdc6 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     d9c:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     da0:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     da4:	11 23       	and	r17, r17
     da6:	29 f0       	breq	.+10     	; 0xdb2 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     da8:	11 a2       	std	Z+33, r1	; 0x21
     daa:	12 a2       	std	Z+34, r1	; 0x22
     dac:	13 a2       	std	Z+35, r1	; 0x23
     dae:	14 a2       	std	Z+36, r1	; 0x24
     db0:	0a c0       	rjmp	.+20     	; 0xdc6 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     db2:	8b 01       	movw	r16, r22
     db4:	9c 01       	movw	r18, r24
     db6:	01 50       	subi	r16, 0x01	; 1
     db8:	11 09       	sbc	r17, r1
     dba:	21 09       	sbc	r18, r1
     dbc:	31 09       	sbc	r19, r1
     dbe:	01 a3       	std	Z+33, r16	; 0x21
     dc0:	12 a3       	std	Z+34, r17	; 0x22
     dc2:	23 a3       	std	Z+35, r18	; 0x23
     dc4:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     dc6:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     dca:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     dce:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     dd0:	0f 90       	pop	r0
     dd2:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	08 95       	ret

00000dda <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     dda:	4f 92       	push	r4
     ddc:	5f 92       	push	r5
     dde:	6f 92       	push	r6
     de0:	7f 92       	push	r7
     de2:	8f 92       	push	r8
     de4:	9f 92       	push	r9
     de6:	af 92       	push	r10
     de8:	bf 92       	push	r11
     dea:	ef 92       	push	r14
     dec:	ff 92       	push	r15
     dee:	0f 93       	push	r16
     df0:	1f 93       	push	r17
     df2:	49 01       	movw	r8, r18
     df4:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	f8 94       	cli
     dfa:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     dfc:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e00:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e04:	25 a1       	ldd	r18, Z+37	; 0x25
     e06:	22 30       	cpi	r18, 0x02	; 2
     e08:	39 f1       	breq	.+78     	; 0xe58 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e0a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e0e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e12:	21 a1       	ldd	r18, Z+33	; 0x21
     e14:	32 a1       	ldd	r19, Z+34	; 0x22
     e16:	43 a1       	ldd	r20, Z+35	; 0x23
     e18:	54 a1       	ldd	r21, Z+36	; 0x24
     e1a:	2b 01       	movw	r4, r22
     e1c:	3c 01       	movw	r6, r24
     e1e:	40 94       	com	r4
     e20:	50 94       	com	r5
     e22:	60 94       	com	r6
     e24:	70 94       	com	r7
     e26:	d3 01       	movw	r26, r6
     e28:	c2 01       	movw	r24, r4
     e2a:	82 23       	and	r24, r18
     e2c:	93 23       	and	r25, r19
     e2e:	a4 23       	and	r26, r20
     e30:	b5 23       	and	r27, r21
     e32:	81 a3       	std	Z+33, r24	; 0x21
     e34:	92 a3       	std	Z+34, r25	; 0x22
     e36:	a3 a3       	std	Z+35, r26	; 0x23
     e38:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e3a:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e3e:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e42:	81 e0       	ldi	r24, 0x01	; 1
     e44:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e46:	e1 14       	cp	r14, r1
     e48:	f1 04       	cpc	r15, r1
     e4a:	31 f0       	breq	.+12     	; 0xe58 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e4c:	61 e0       	ldi	r22, 0x01	; 1
     e4e:	c7 01       	movw	r24, r14
     e50:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e54:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e58:	0f 90       	pop	r0
     e5a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     e5c:	0f b6       	in	r0, 0x3f	; 63
     e5e:	f8 94       	cli
     e60:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     e62:	01 15       	cp	r16, r1
     e64:	11 05       	cpc	r17, r1
     e66:	69 f0       	breq	.+26     	; 0xe82 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     e68:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e6c:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e70:	81 a1       	ldd	r24, Z+33	; 0x21
     e72:	92 a1       	ldd	r25, Z+34	; 0x22
     e74:	a3 a1       	ldd	r26, Z+35	; 0x23
     e76:	b4 a1       	ldd	r27, Z+36	; 0x24
     e78:	f8 01       	movw	r30, r16
     e7a:	80 83       	st	Z, r24
     e7c:	91 83       	std	Z+1, r25	; 0x01
     e7e:	a2 83       	std	Z+2, r26	; 0x02
     e80:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e82:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e86:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e8a:	85 a1       	ldd	r24, Z+37	; 0x25
     e8c:	82 30       	cpi	r24, 0x02	; 2
     e8e:	c1 f4       	brne	.+48     	; 0xec0 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     e90:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     e94:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     e98:	41 a1       	ldd	r20, Z+33	; 0x21
     e9a:	52 a1       	ldd	r21, Z+34	; 0x22
     e9c:	63 a1       	ldd	r22, Z+35	; 0x23
     e9e:	74 a1       	ldd	r23, Z+36	; 0x24
     ea0:	d5 01       	movw	r26, r10
     ea2:	c4 01       	movw	r24, r8
     ea4:	80 95       	com	r24
     ea6:	90 95       	com	r25
     ea8:	a0 95       	com	r26
     eaa:	b0 95       	com	r27
     eac:	84 23       	and	r24, r20
     eae:	95 23       	and	r25, r21
     eb0:	a6 23       	and	r26, r22
     eb2:	b7 23       	and	r27, r23
     eb4:	81 a3       	std	Z+33, r24	; 0x21
     eb6:	92 a3       	std	Z+34, r25	; 0x22
     eb8:	a3 a3       	std	Z+35, r26	; 0x23
     eba:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     ebc:	81 e0       	ldi	r24, 0x01	; 1
     ebe:	01 c0       	rjmp	.+2      	; 0xec2 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     ec0:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     ec2:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     ec6:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     eca:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     ed0:	1f 91       	pop	r17
     ed2:	0f 91       	pop	r16
     ed4:	ff 90       	pop	r15
     ed6:	ef 90       	pop	r14
     ed8:	bf 90       	pop	r11
     eda:	af 90       	pop	r10
     edc:	9f 90       	pop	r9
     ede:	8f 90       	pop	r8
     ee0:	7f 90       	pop	r7
     ee2:	6f 90       	pop	r6
     ee4:	5f 90       	pop	r5
     ee6:	4f 90       	pop	r4
     ee8:	08 95       	ret

00000eea <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     eea:	0f 93       	push	r16
     eec:	1f 93       	push	r17
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
     ef2:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     ef4:	0f b6       	in	r0, 0x3f	; 63
     ef6:	f8 94       	cli
     ef8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     efa:	01 15       	cp	r16, r1
     efc:	11 05       	cpc	r17, r1
     efe:	49 f0       	breq	.+18     	; 0xf12 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f00:	81 a1       	ldd	r24, Z+33	; 0x21
     f02:	92 a1       	ldd	r25, Z+34	; 0x22
     f04:	a3 a1       	ldd	r26, Z+35	; 0x23
     f06:	b4 a1       	ldd	r27, Z+36	; 0x24
     f08:	e8 01       	movw	r28, r16
     f0a:	88 83       	st	Y, r24
     f0c:	99 83       	std	Y+1, r25	; 0x01
     f0e:	aa 83       	std	Y+2, r26	; 0x02
     f10:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f12:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f18:	22 30       	cpi	r18, 0x02	; 2
     f1a:	89 f0       	breq	.+34     	; 0xf3e <xTaskGenericNotify+0x54>
     f1c:	58 f4       	brcc	.+22     	; 0xf34 <xTaskGenericNotify+0x4a>
     f1e:	21 30       	cpi	r18, 0x01	; 1
     f20:	01 f5       	brne	.+64     	; 0xf62 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f22:	81 a1       	ldd	r24, Z+33	; 0x21
     f24:	92 a1       	ldd	r25, Z+34	; 0x22
     f26:	a3 a1       	ldd	r26, Z+35	; 0x23
     f28:	b4 a1       	ldd	r27, Z+36	; 0x24
     f2a:	48 2b       	or	r20, r24
     f2c:	59 2b       	or	r21, r25
     f2e:	6a 2b       	or	r22, r26
     f30:	7b 2b       	or	r23, r27
     f32:	13 c0       	rjmp	.+38     	; 0xf5a <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     f34:	23 30       	cpi	r18, 0x03	; 3
     f36:	89 f0       	breq	.+34     	; 0xf5a <xTaskGenericNotify+0x70>
     f38:	24 30       	cpi	r18, 0x04	; 4
     f3a:	69 f0       	breq	.+26     	; 0xf56 <xTaskGenericNotify+0x6c>
     f3c:	12 c0       	rjmp	.+36     	; 0xf62 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     f3e:	81 a1       	ldd	r24, Z+33	; 0x21
     f40:	92 a1       	ldd	r25, Z+34	; 0x22
     f42:	a3 a1       	ldd	r26, Z+35	; 0x23
     f44:	b4 a1       	ldd	r27, Z+36	; 0x24
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	a1 1d       	adc	r26, r1
     f4a:	b1 1d       	adc	r27, r1
     f4c:	81 a3       	std	Z+33, r24	; 0x21
     f4e:	92 a3       	std	Z+34, r25	; 0x22
     f50:	a3 a3       	std	Z+35, r26	; 0x23
     f52:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     f54:	06 c0       	rjmp	.+12     	; 0xf62 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     f56:	32 30       	cpi	r19, 0x02	; 2
     f58:	49 f1       	breq	.+82     	; 0xfac <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     f5a:	41 a3       	std	Z+33, r20	; 0x21
     f5c:	52 a3       	std	Z+34, r21	; 0x22
     f5e:	63 a3       	std	Z+35, r22	; 0x23
     f60:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     f62:	31 30       	cpi	r19, 0x01	; 1
     f64:	09 f5       	brne	.+66     	; 0xfa8 <xTaskGenericNotify+0xbe>
     f66:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     f68:	8f 01       	movw	r16, r30
     f6a:	0e 5f       	subi	r16, 0xFE	; 254
     f6c:	1f 4f       	sbci	r17, 0xFF	; 255
     f6e:	c8 01       	movw	r24, r16
     f70:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     f74:	8e 89       	ldd	r24, Y+22	; 0x16
     f76:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
     f7a:	98 17       	cp	r25, r24
     f7c:	10 f4       	brcc	.+4      	; 0xf82 <xTaskGenericNotify+0x98>
     f7e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
     f82:	29 e0       	ldi	r18, 0x09	; 9
     f84:	82 9f       	mul	r24, r18
     f86:	c0 01       	movw	r24, r0
     f88:	11 24       	eor	r1, r1
     f8a:	b8 01       	movw	r22, r16
     f8c:	80 59       	subi	r24, 0x90	; 144
     f8e:	9e 4f       	sbci	r25, 0xFE	; 254
     f90:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     f94:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
     f98:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
     f9c:	9e 89       	ldd	r25, Y+22	; 0x16
     f9e:	86 89       	ldd	r24, Z+22	; 0x16
     fa0:	89 17       	cp	r24, r25
     fa2:	10 f4       	brcc	.+4      	; 0xfa8 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     fa4:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
     fa8:	81 e0       	ldi	r24, 0x01	; 1
     faa:	01 c0       	rjmp	.+2      	; 0xfae <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     fac:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     fae:	0f 90       	pop	r0
     fb0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     fb2:	df 91       	pop	r29
     fb4:	cf 91       	pop	r28
     fb6:	1f 91       	pop	r17
     fb8:	0f 91       	pop	r16
     fba:	08 95       	ret

00000fbc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     fbc:	ef 92       	push	r14
     fbe:	ff 92       	push	r15
     fc0:	0f 93       	push	r16
     fc2:	1f 93       	push	r17
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
     fca:	01 15       	cp	r16, r1
     fcc:	11 05       	cpc	r17, r1
     fce:	49 f0       	breq	.+18     	; 0xfe2 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     fd0:	81 a1       	ldd	r24, Z+33	; 0x21
     fd2:	92 a1       	ldd	r25, Z+34	; 0x22
     fd4:	a3 a1       	ldd	r26, Z+35	; 0x23
     fd6:	b4 a1       	ldd	r27, Z+36	; 0x24
     fd8:	e8 01       	movw	r28, r16
     fda:	88 83       	st	Y, r24
     fdc:	99 83       	std	Y+1, r25	; 0x01
     fde:	aa 83       	std	Y+2, r26	; 0x02
     fe0:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     fe2:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     fe4:	82 e0       	ldi	r24, 0x02	; 2
     fe6:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     fe8:	22 30       	cpi	r18, 0x02	; 2
     fea:	89 f0       	breq	.+34     	; 0x100e <xTaskGenericNotifyFromISR+0x52>
     fec:	58 f4       	brcc	.+22     	; 0x1004 <xTaskGenericNotifyFromISR+0x48>
     fee:	21 30       	cpi	r18, 0x01	; 1
     ff0:	01 f5       	brne	.+64     	; 0x1032 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     ff2:	81 a1       	ldd	r24, Z+33	; 0x21
     ff4:	92 a1       	ldd	r25, Z+34	; 0x22
     ff6:	a3 a1       	ldd	r26, Z+35	; 0x23
     ff8:	b4 a1       	ldd	r27, Z+36	; 0x24
     ffa:	48 2b       	or	r20, r24
     ffc:	59 2b       	or	r21, r25
     ffe:	6a 2b       	or	r22, r26
    1000:	7b 2b       	or	r23, r27
    1002:	13 c0       	rjmp	.+38     	; 0x102a <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1004:	23 30       	cpi	r18, 0x03	; 3
    1006:	89 f0       	breq	.+34     	; 0x102a <xTaskGenericNotifyFromISR+0x6e>
    1008:	24 30       	cpi	r18, 0x04	; 4
    100a:	69 f0       	breq	.+26     	; 0x1026 <xTaskGenericNotifyFromISR+0x6a>
    100c:	12 c0       	rjmp	.+36     	; 0x1032 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    100e:	81 a1       	ldd	r24, Z+33	; 0x21
    1010:	92 a1       	ldd	r25, Z+34	; 0x22
    1012:	a3 a1       	ldd	r26, Z+35	; 0x23
    1014:	b4 a1       	ldd	r27, Z+36	; 0x24
    1016:	01 96       	adiw	r24, 0x01	; 1
    1018:	a1 1d       	adc	r26, r1
    101a:	b1 1d       	adc	r27, r1
    101c:	81 a3       	std	Z+33, r24	; 0x21
    101e:	92 a3       	std	Z+34, r25	; 0x22
    1020:	a3 a3       	std	Z+35, r26	; 0x23
    1022:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1024:	06 c0       	rjmp	.+12     	; 0x1032 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1026:	32 30       	cpi	r19, 0x02	; 2
    1028:	d9 f1       	breq	.+118    	; 0x10a0 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    102a:	41 a3       	std	Z+33, r20	; 0x21
    102c:	52 a3       	std	Z+34, r21	; 0x22
    102e:	63 a3       	std	Z+35, r22	; 0x23
    1030:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1032:	31 30       	cpi	r19, 0x01	; 1
    1034:	11 f0       	breq	.+4      	; 0x103a <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	34 c0       	rjmp	.+104    	; 0x10a2 <xTaskGenericNotifyFromISR+0xe6>
    103a:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    103c:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
    1040:	81 11       	cpse	r24, r1
    1042:	15 c0       	rjmp	.+42     	; 0x106e <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1044:	8f 01       	movw	r16, r30
    1046:	0e 5f       	subi	r16, 0xFE	; 254
    1048:	1f 4f       	sbci	r17, 0xFF	; 255
    104a:	c8 01       	movw	r24, r16
    104c:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1050:	8e 89       	ldd	r24, Y+22	; 0x16
    1052:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
    1056:	98 17       	cp	r25, r24
    1058:	10 f4       	brcc	.+4      	; 0x105e <xTaskGenericNotifyFromISR+0xa2>
    105a:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
    105e:	e9 e0       	ldi	r30, 0x09	; 9
    1060:	8e 9f       	mul	r24, r30
    1062:	c0 01       	movw	r24, r0
    1064:	11 24       	eor	r1, r1
    1066:	b8 01       	movw	r22, r16
    1068:	80 59       	subi	r24, 0x90	; 144
    106a:	9e 4f       	sbci	r25, 0xFE	; 254
    106c:	05 c0       	rjmp	.+10     	; 0x1078 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    106e:	bf 01       	movw	r22, r30
    1070:	64 5f       	subi	r22, 0xF4	; 244
    1072:	7f 4f       	sbci	r23, 0xFF	; 255
    1074:	81 e5       	ldi	r24, 0x51	; 81
    1076:	91 e0       	ldi	r25, 0x01	; 1
    1078:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    107c:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
    1080:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
    1084:	9e 89       	ldd	r25, Y+22	; 0x16
    1086:	86 89       	ldd	r24, Z+22	; 0x16
    1088:	89 17       	cp	r24, r25
    108a:	a8 f6       	brcc	.-86     	; 0x1036 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    108c:	e1 14       	cp	r14, r1
    108e:	f1 04       	cpc	r15, r1
    1090:	19 f0       	breq	.+6      	; 0x1098 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1092:	81 e0       	ldi	r24, 0x01	; 1
    1094:	e7 01       	movw	r28, r14
    1096:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
    109e:	01 c0       	rjmp	.+2      	; 0x10a2 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10a0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	1f 91       	pop	r17
    10a8:	0f 91       	pop	r16
    10aa:	ff 90       	pop	r15
    10ac:	ef 90       	pop	r14
    10ae:	08 95       	ret

000010b0 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10b0:	ef 92       	push	r14
    10b2:	ff 92       	push	r15
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    10be:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    10c0:	82 e0       	ldi	r24, 0x02	; 2
    10c2:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    10c4:	81 a1       	ldd	r24, Z+33	; 0x21
    10c6:	92 a1       	ldd	r25, Z+34	; 0x22
    10c8:	a3 a1       	ldd	r26, Z+35	; 0x23
    10ca:	b4 a1       	ldd	r27, Z+36	; 0x24
    10cc:	01 96       	adiw	r24, 0x01	; 1
    10ce:	a1 1d       	adc	r26, r1
    10d0:	b1 1d       	adc	r27, r1
    10d2:	81 a3       	std	Z+33, r24	; 0x21
    10d4:	92 a3       	std	Z+34, r25	; 0x22
    10d6:	a3 a3       	std	Z+35, r26	; 0x23
    10d8:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    10da:	21 30       	cpi	r18, 0x01	; 1
    10dc:	a1 f5       	brne	.+104    	; 0x1146 <vTaskNotifyGiveFromISR+0x96>
    10de:	8b 01       	movw	r16, r22
    10e0:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10e2:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxSchedulerSuspended>
    10e6:	81 11       	cpse	r24, r1
    10e8:	16 c0       	rjmp	.+44     	; 0x1116 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10ea:	7f 01       	movw	r14, r30
    10ec:	22 e0       	ldi	r18, 0x02	; 2
    10ee:	e2 0e       	add	r14, r18
    10f0:	f1 1c       	adc	r15, r1
    10f2:	c7 01       	movw	r24, r14
    10f4:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    10f8:	8e 89       	ldd	r24, Y+22	; 0x16
    10fa:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <uxTopReadyPriority>
    10fe:	98 17       	cp	r25, r24
    1100:	10 f4       	brcc	.+4      	; 0x1106 <vTaskNotifyGiveFromISR+0x56>
    1102:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxTopReadyPriority>
    1106:	e9 e0       	ldi	r30, 0x09	; 9
    1108:	8e 9f       	mul	r24, r30
    110a:	c0 01       	movw	r24, r0
    110c:	11 24       	eor	r1, r1
    110e:	b7 01       	movw	r22, r14
    1110:	80 59       	subi	r24, 0x90	; 144
    1112:	9e 4f       	sbci	r25, 0xFE	; 254
    1114:	05 c0       	rjmp	.+10     	; 0x1120 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1116:	bf 01       	movw	r22, r30
    1118:	64 5f       	subi	r22, 0xF4	; 244
    111a:	7f 4f       	sbci	r23, 0xFF	; 255
    111c:	81 e5       	ldi	r24, 0x51	; 81
    111e:	91 e0       	ldi	r25, 0x01	; 1
    1120:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1124:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <__data_end>
    1128:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <__data_end+0x1>
    112c:	9e 89       	ldd	r25, Y+22	; 0x16
    112e:	86 89       	ldd	r24, Z+22	; 0x16
    1130:	89 17       	cp	r24, r25
    1132:	48 f4       	brcc	.+18     	; 0x1146 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1134:	01 15       	cp	r16, r1
    1136:	11 05       	cpc	r17, r1
    1138:	19 f0       	breq	.+6      	; 0x1140 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	f8 01       	movw	r30, r16
    113e:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1140:	81 e0       	ldi	r24, 0x01	; 1
    1142:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1146:	df 91       	pop	r29
    1148:	cf 91       	pop	r28
    114a:	1f 91       	pop	r17
    114c:	0f 91       	pop	r16
    114e:	ff 90       	pop	r15
    1150:	ef 90       	pop	r14
    1152:	08 95       	ret

00001154 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1154:	00 97       	sbiw	r24, 0x00	; 0
    1156:	21 f4       	brne	.+8      	; 0x1160 <xTaskNotifyStateClear+0xc>
    1158:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <__data_end>
    115c:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <__data_end+0x1>

		taskENTER_CRITICAL();
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1166:	fc 01       	movw	r30, r24
    1168:	25 a1       	ldd	r18, Z+37	; 0x25
    116a:	22 30       	cpi	r18, 0x02	; 2
    116c:	19 f4       	brne	.+6      	; 0x1174 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    116e:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	01 c0       	rjmp	.+2      	; 0x1176 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1174:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1176:	0f 90       	pop	r0
    1178:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    117a:	08 95       	ret

0000117c <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	f8 94       	cli
    1180:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1182:	fc 01       	movw	r30, r24
    1184:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1186:	0f 90       	pop	r0
    1188:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	91 11       	cpse	r25, r1
    118e:	80 e0       	ldi	r24, 0x00	; 0
}
    1190:	08 95       	ret

00001192 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1192:	0f 93       	push	r16
    1194:	1f 93       	push	r17
    1196:	cf 93       	push	r28
    1198:	df 93       	push	r29
    119a:	ec 01       	movw	r28, r24
    119c:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    119e:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    11a0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11a2:	44 23       	and	r20, r20
    11a4:	b1 f1       	breq	.+108    	; 0x1212 <prvCopyDataToQueue+0x80>
    11a6:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    11a8:	01 11       	cpse	r16, r1
    11aa:	15 c0       	rjmp	.+42     	; 0x11d6 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    11ac:	8a 81       	ldd	r24, Y+2	; 0x02
    11ae:	9b 81       	ldd	r25, Y+3	; 0x03
    11b0:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    11b4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11b6:	8a 81       	ldd	r24, Y+2	; 0x02
    11b8:	9b 81       	ldd	r25, Y+3	; 0x03
    11ba:	82 0f       	add	r24, r18
    11bc:	91 1d       	adc	r25, r1
    11be:	9b 83       	std	Y+3, r25	; 0x03
    11c0:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11c2:	2c 81       	ldd	r18, Y+4	; 0x04
    11c4:	3d 81       	ldd	r19, Y+5	; 0x05
    11c6:	82 17       	cp	r24, r18
    11c8:	93 07       	cpc	r25, r19
    11ca:	18 f1       	brcs	.+70     	; 0x1212 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    11cc:	88 81       	ld	r24, Y
    11ce:	99 81       	ldd	r25, Y+1	; 0x01
    11d0:	9b 83       	std	Y+3, r25	; 0x03
    11d2:	8a 83       	std	Y+2, r24	; 0x02
    11d4:	1e c0       	rjmp	.+60     	; 0x1212 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    11d6:	8e 81       	ldd	r24, Y+6	; 0x06
    11d8:	9f 81       	ldd	r25, Y+7	; 0x07
    11da:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    11de:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	91 95       	neg	r25
    11e4:	81 95       	neg	r24
    11e6:	91 09       	sbc	r25, r1
    11e8:	2e 81       	ldd	r18, Y+6	; 0x06
    11ea:	3f 81       	ldd	r19, Y+7	; 0x07
    11ec:	28 0f       	add	r18, r24
    11ee:	39 1f       	adc	r19, r25
    11f0:	3f 83       	std	Y+7, r19	; 0x07
    11f2:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11f4:	48 81       	ld	r20, Y
    11f6:	59 81       	ldd	r21, Y+1	; 0x01
    11f8:	24 17       	cp	r18, r20
    11fa:	35 07       	cpc	r19, r21
    11fc:	30 f4       	brcc	.+12     	; 0x120a <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    11fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1200:	3d 81       	ldd	r19, Y+5	; 0x05
    1202:	82 0f       	add	r24, r18
    1204:	93 1f       	adc	r25, r19
    1206:	9f 83       	std	Y+7, r25	; 0x07
    1208:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    120a:	02 30       	cpi	r16, 0x02	; 2
    120c:	11 f4       	brne	.+4      	; 0x1212 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    120e:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1210:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1212:	1f 5f       	subi	r17, 0xFF	; 255
    1214:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1216:	80 e0       	ldi	r24, 0x00	; 0
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	1f 91       	pop	r17
    121e:	0f 91       	pop	r16
    1220:	08 95       	ret

00001222 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1222:	fc 01       	movw	r30, r24
    1224:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1226:	44 8d       	ldd	r20, Z+28	; 0x1c
    1228:	44 23       	and	r20, r20
    122a:	a1 f0       	breq	.+40     	; 0x1254 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    122c:	50 e0       	ldi	r21, 0x00	; 0
    122e:	26 81       	ldd	r18, Z+6	; 0x06
    1230:	37 81       	ldd	r19, Z+7	; 0x07
    1232:	24 0f       	add	r18, r20
    1234:	35 1f       	adc	r19, r21
    1236:	37 83       	std	Z+7, r19	; 0x07
    1238:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    123a:	64 81       	ldd	r22, Z+4	; 0x04
    123c:	75 81       	ldd	r23, Z+5	; 0x05
    123e:	26 17       	cp	r18, r22
    1240:	37 07       	cpc	r19, r23
    1242:	20 f0       	brcs	.+8      	; 0x124c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1244:	20 81       	ld	r18, Z
    1246:	31 81       	ldd	r19, Z+1	; 0x01
    1248:	37 83       	std	Z+7, r19	; 0x07
    124a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    124c:	66 81       	ldd	r22, Z+6	; 0x06
    124e:	77 81       	ldd	r23, Z+7	; 0x07
    1250:	0c 94 0b 12 	jmp	0x2416	; 0x2416 <memcpy>
    1254:	08 95       	ret

00001256 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1256:	ef 92       	push	r14
    1258:	ff 92       	push	r15
    125a:	1f 93       	push	r17
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1268:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    126a:	7c 01       	movw	r14, r24
    126c:	81 e1       	ldi	r24, 0x11	; 17
    126e:	e8 0e       	add	r14, r24
    1270:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1272:	11 16       	cp	r1, r17
    1274:	5c f4       	brge	.+22     	; 0x128c <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1276:	89 89       	ldd	r24, Y+17	; 0x11
    1278:	88 23       	and	r24, r24
    127a:	41 f0       	breq	.+16     	; 0x128c <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    127c:	c7 01       	movw	r24, r14
    127e:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    1282:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1284:	0e 94 81 06 	call	0xd02	; 0xd02 <vTaskMissedYield>
    1288:	11 50       	subi	r17, 0x01	; 1
    128a:	f3 cf       	rjmp	.-26     	; 0x1272 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    128c:	8f ef       	ldi	r24, 0xFF	; 255
    128e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1290:	0f 90       	pop	r0
    1292:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1294:	0f b6       	in	r0, 0x3f	; 63
    1296:	f8 94       	cli
    1298:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    129a:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    129c:	7e 01       	movw	r14, r28
    129e:	88 e0       	ldi	r24, 0x08	; 8
    12a0:	e8 0e       	add	r14, r24
    12a2:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    12a4:	11 16       	cp	r1, r17
    12a6:	5c f4       	brge	.+22     	; 0x12be <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12a8:	88 85       	ldd	r24, Y+8	; 0x08
    12aa:	88 23       	and	r24, r24
    12ac:	41 f0       	breq	.+16     	; 0x12be <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12ae:	c7 01       	movw	r24, r14
    12b0:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    12b4:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    12b6:	0e 94 81 06 	call	0xd02	; 0xd02 <vTaskMissedYield>
    12ba:	11 50       	subi	r17, 0x01	; 1
    12bc:	f3 cf       	rjmp	.-26     	; 0x12a4 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    12be:	8f ef       	ldi	r24, 0xFF	; 255
    12c0:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    12c2:	0f 90       	pop	r0
    12c4:	0f be       	out	0x3f, r0	; 63
}
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	1f 91       	pop	r17
    12cc:	ff 90       	pop	r15
    12ce:	ef 90       	pop	r14
    12d0:	08 95       	ret

000012d2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    12d2:	cf 93       	push	r28
    12d4:	df 93       	push	r29
    12d6:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    12d8:	0f b6       	in	r0, 0x3f	; 63
    12da:	f8 94       	cli
    12dc:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    12de:	48 81       	ld	r20, Y
    12e0:	59 81       	ldd	r21, Y+1	; 0x01
    12e2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    12e4:	7c 8d       	ldd	r23, Y+28	; 0x1c
    12e6:	9a 01       	movw	r18, r20
    12e8:	87 9f       	mul	r24, r23
    12ea:	20 0d       	add	r18, r0
    12ec:	31 1d       	adc	r19, r1
    12ee:	11 24       	eor	r1, r1
    12f0:	3d 83       	std	Y+5, r19	; 0x05
    12f2:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    12f4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    12f6:	5b 83       	std	Y+3, r21	; 0x03
    12f8:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	01 97       	sbiw	r24, 0x01	; 1
    12fe:	78 9f       	mul	r23, r24
    1300:	90 01       	movw	r18, r0
    1302:	79 9f       	mul	r23, r25
    1304:	30 0d       	add	r19, r0
    1306:	11 24       	eor	r1, r1
    1308:	ca 01       	movw	r24, r20
    130a:	82 0f       	add	r24, r18
    130c:	93 1f       	adc	r25, r19
    130e:	9f 83       	std	Y+7, r25	; 0x07
    1310:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1312:	8f ef       	ldi	r24, 0xFF	; 255
    1314:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1316:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1318:	61 11       	cpse	r22, r1
    131a:	0c c0       	rjmp	.+24     	; 0x1334 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    131c:	88 85       	ldd	r24, Y+8	; 0x08
    131e:	88 23       	and	r24, r24
    1320:	89 f0       	breq	.+34     	; 0x1344 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1322:	ce 01       	movw	r24, r28
    1324:	08 96       	adiw	r24, 0x08	; 8
    1326:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    132a:	88 23       	and	r24, r24
    132c:	59 f0       	breq	.+22     	; 0x1344 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    132e:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    1332:	08 c0       	rjmp	.+16     	; 0x1344 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1334:	ce 01       	movw	r24, r28
    1336:	08 96       	adiw	r24, 0x08	; 8
    1338:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    133c:	ce 01       	movw	r24, r28
    133e:	41 96       	adiw	r24, 0x11	; 17
    1340:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1344:	0f 90       	pop	r0
    1346:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	08 95       	ret

00001350 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1350:	0f 93       	push	r16
    1352:	1f 93       	push	r17
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	08 2f       	mov	r16, r24
    135a:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    135c:	66 23       	and	r22, r22
    135e:	21 f0       	breq	.+8      	; 0x1368 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1360:	86 9f       	mul	r24, r22
    1362:	c0 01       	movw	r24, r0
    1364:	11 24       	eor	r1, r1
    1366:	02 c0       	rjmp	.+4      	; 0x136c <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    136c:	4f 96       	adiw	r24, 0x1f	; 31
    136e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <pvPortMalloc>
    1372:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1374:	00 97       	sbiw	r24, 0x00	; 0
    1376:	71 f0       	breq	.+28     	; 0x1394 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1378:	11 11       	cpse	r17, r1
    137a:	03 c0       	rjmp	.+6      	; 0x1382 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    137c:	99 83       	std	Y+1, r25	; 0x01
    137e:	88 83       	st	Y, r24
    1380:	03 c0       	rjmp	.+6      	; 0x1388 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1382:	4f 96       	adiw	r24, 0x1f	; 31
    1384:	99 83       	std	Y+1, r25	; 0x01
    1386:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1388:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    138a:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    138c:	61 e0       	ldi	r22, 0x01	; 1
    138e:	ce 01       	movw	r24, r28
    1390:	0e 94 69 09 	call	0x12d2	; 0x12d2 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    1394:	ce 01       	movw	r24, r28
    1396:	df 91       	pop	r29
    1398:	cf 91       	pop	r28
    139a:	1f 91       	pop	r17
    139c:	0f 91       	pop	r16
    139e:	08 95       	ret

000013a0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    13a0:	af 92       	push	r10
    13a2:	bf 92       	push	r11
    13a4:	cf 92       	push	r12
    13a6:	df 92       	push	r13
    13a8:	ff 92       	push	r15
    13aa:	0f 93       	push	r16
    13ac:	1f 93       	push	r17
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	00 d0       	rcall	.+0      	; 0x13b4 <xQueueGenericSend+0x14>
    13b4:	00 d0       	rcall	.+0      	; 0x13b6 <xQueueGenericSend+0x16>
    13b6:	1f 92       	push	r1
    13b8:	cd b7       	in	r28, 0x3d	; 61
    13ba:	de b7       	in	r29, 0x3e	; 62
    13bc:	8c 01       	movw	r16, r24
    13be:	6b 01       	movw	r12, r22
    13c0:	5d 83       	std	Y+5, r21	; 0x05
    13c2:	4c 83       	std	Y+4, r20	; 0x04
    13c4:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    13c6:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13c8:	58 01       	movw	r10, r16
    13ca:	98 e0       	ldi	r25, 0x08	; 8
    13cc:	a9 0e       	add	r10, r25
    13ce:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	f8 94       	cli
    13d4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13d6:	f8 01       	movw	r30, r16
    13d8:	22 8d       	ldd	r18, Z+26	; 0x1a
    13da:	93 8d       	ldd	r25, Z+27	; 0x1b
    13dc:	29 17       	cp	r18, r25
    13de:	18 f0       	brcs	.+6      	; 0x13e6 <xQueueGenericSend+0x46>
    13e0:	f2 e0       	ldi	r31, 0x02	; 2
    13e2:	ff 12       	cpse	r15, r31
    13e4:	14 c0       	rjmp	.+40     	; 0x140e <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13e6:	4f 2d       	mov	r20, r15
    13e8:	b6 01       	movw	r22, r12
    13ea:	c8 01       	movw	r24, r16
    13ec:	0e 94 c9 08 	call	0x1192	; 0x1192 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13f0:	f8 01       	movw	r30, r16
    13f2:	91 89       	ldd	r25, Z+17	; 0x11
    13f4:	99 23       	and	r25, r25
    13f6:	21 f0       	breq	.+8      	; 0x1400 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13f8:	c8 01       	movw	r24, r16
    13fa:	41 96       	adiw	r24, 0x11	; 17
    13fc:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    1400:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1402:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1406:	0f 90       	pop	r0
    1408:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    140a:	81 e0       	ldi	r24, 0x01	; 1
    140c:	50 c0       	rjmp	.+160    	; 0x14ae <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    140e:	2c 81       	ldd	r18, Y+4	; 0x04
    1410:	3d 81       	ldd	r19, Y+5	; 0x05
    1412:	23 2b       	or	r18, r19
    1414:	19 f4       	brne	.+6      	; 0x141c <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1416:	0f 90       	pop	r0
    1418:	0f be       	out	0x3f, r0	; 63
    141a:	48 c0       	rjmp	.+144    	; 0x14ac <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    141c:	81 11       	cpse	r24, r1
    141e:	04 c0       	rjmp	.+8      	; 0x1428 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1420:	ce 01       	movw	r24, r28
    1422:	01 96       	adiw	r24, 0x01	; 1
    1424:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1428:	0f 90       	pop	r0
    142a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    142c:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1430:	0f b6       	in	r0, 0x3f	; 63
    1432:	f8 94       	cli
    1434:	0f 92       	push	r0
    1436:	f8 01       	movw	r30, r16
    1438:	85 8d       	ldd	r24, Z+29	; 0x1d
    143a:	8f 3f       	cpi	r24, 0xFF	; 255
    143c:	09 f4       	brne	.+2      	; 0x1440 <xQueueGenericSend+0xa0>
    143e:	15 8e       	std	Z+29, r1	; 0x1d
    1440:	f8 01       	movw	r30, r16
    1442:	86 8d       	ldd	r24, Z+30	; 0x1e
    1444:	8f 3f       	cpi	r24, 0xFF	; 255
    1446:	09 f4       	brne	.+2      	; 0x144a <xQueueGenericSend+0xaa>
    1448:	16 8e       	std	Z+30, r1	; 0x1e
    144a:	0f 90       	pop	r0
    144c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    144e:	be 01       	movw	r22, r28
    1450:	6c 5f       	subi	r22, 0xFC	; 252
    1452:	7f 4f       	sbci	r23, 0xFF	; 255
    1454:	ce 01       	movw	r24, r28
    1456:	01 96       	adiw	r24, 0x01	; 1
    1458:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xTaskCheckForTimeOut>
    145c:	81 11       	cpse	r24, r1
    145e:	21 c0       	rjmp	.+66     	; 0x14a2 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1460:	0f b6       	in	r0, 0x3f	; 63
    1462:	f8 94       	cli
    1464:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1466:	f8 01       	movw	r30, r16
    1468:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    146a:	0f 90       	pop	r0
    146c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    146e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1470:	98 13       	cpse	r25, r24
    1472:	11 c0       	rjmp	.+34     	; 0x1496 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1474:	6c 81       	ldd	r22, Y+4	; 0x04
    1476:	7d 81       	ldd	r23, Y+5	; 0x05
    1478:	c5 01       	movw	r24, r10
    147a:	0e 94 98 05 	call	0xb30	; 0xb30 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    147e:	c8 01       	movw	r24, r16
    1480:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1484:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    1488:	88 23       	and	r24, r24
    148a:	11 f0       	breq	.+4      	; 0x1490 <xQueueGenericSend+0xf0>
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	a0 cf       	rjmp	.-192    	; 0x13d0 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1490:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    1494:	fb cf       	rjmp	.-10     	; 0x148c <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1496:	c8 01       	movw	r24, r16
    1498:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    149c:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    14a0:	f5 cf       	rjmp	.-22     	; 0x148c <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    14a2:	c8 01       	movw	r24, r16
    14a4:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14a8:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    14ac:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    14ae:	0f 90       	pop	r0
    14b0:	0f 90       	pop	r0
    14b2:	0f 90       	pop	r0
    14b4:	0f 90       	pop	r0
    14b6:	0f 90       	pop	r0
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	df 90       	pop	r13
    14c4:	cf 90       	pop	r12
    14c6:	bf 90       	pop	r11
    14c8:	af 90       	pop	r10
    14ca:	08 95       	ret

000014cc <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    14cc:	ef 92       	push	r14
    14ce:	ff 92       	push	r15
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
    14d6:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14d8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14da:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14dc:	98 17       	cp	r25, r24
    14de:	10 f0       	brcs	.+4      	; 0x14e4 <xQueueGenericSendFromISR+0x18>
    14e0:	22 30       	cpi	r18, 0x02	; 2
    14e2:	e1 f4       	brne	.+56     	; 0x151c <xQueueGenericSendFromISR+0x50>
    14e4:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    14e6:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    14e8:	42 2f       	mov	r20, r18
    14ea:	ce 01       	movw	r24, r28
    14ec:	0e 94 c9 08 	call	0x1192	; 0x1192 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14f0:	1f 3f       	cpi	r17, 0xFF	; 255
    14f2:	81 f4       	brne	.+32     	; 0x1514 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14f4:	89 89       	ldd	r24, Y+17	; 0x11
    14f6:	88 23       	and	r24, r24
    14f8:	79 f0       	breq	.+30     	; 0x1518 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14fa:	ce 01       	movw	r24, r28
    14fc:	41 96       	adiw	r24, 0x11	; 17
    14fe:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    1502:	88 23       	and	r24, r24
    1504:	49 f0       	breq	.+18     	; 0x1518 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1506:	e1 14       	cp	r14, r1
    1508:	f1 04       	cpc	r15, r1
    150a:	31 f0       	breq	.+12     	; 0x1518 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    150c:	81 e0       	ldi	r24, 0x01	; 1
    150e:	f7 01       	movw	r30, r14
    1510:	80 83       	st	Z, r24
    1512:	05 c0       	rjmp	.+10     	; 0x151e <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1514:	1f 5f       	subi	r17, 0xFF	; 255
    1516:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	01 c0       	rjmp	.+2      	; 0x151e <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    151c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	1f 91       	pop	r17
    1524:	ff 90       	pop	r15
    1526:	ef 90       	pop	r14
    1528:	08 95       	ret

0000152a <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1530:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1532:	83 8d       	ldd	r24, Z+27	; 0x1b
    1534:	98 17       	cp	r25, r24
    1536:	c0 f4       	brcc	.+48     	; 0x1568 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1538:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    153a:	9f 5f       	subi	r25, 0xFF	; 255
    153c:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    153e:	8f 3f       	cpi	r24, 0xFF	; 255
    1540:	79 f4       	brne	.+30     	; 0x1560 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1542:	81 89       	ldd	r24, Z+17	; 0x11
    1544:	88 23       	and	r24, r24
    1546:	71 f0       	breq	.+28     	; 0x1564 <xQueueGiveFromISR+0x3a>
    1548:	eb 01       	movw	r28, r22
    154a:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    154c:	41 96       	adiw	r24, 0x11	; 17
    154e:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    1552:	88 23       	and	r24, r24
    1554:	39 f0       	breq	.+14     	; 0x1564 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1556:	20 97       	sbiw	r28, 0x00	; 0
    1558:	29 f0       	breq	.+10     	; 0x1564 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    155a:	81 e0       	ldi	r24, 0x01	; 1
    155c:	88 83       	st	Y, r24
    155e:	05 c0       	rjmp	.+10     	; 0x156a <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1560:	8f 5f       	subi	r24, 0xFF	; 255
    1562:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1564:	81 e0       	ldi	r24, 0x01	; 1
    1566:	01 c0       	rjmp	.+2      	; 0x156a <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1568:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	08 95       	ret

00001570 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1570:	af 92       	push	r10
    1572:	bf 92       	push	r11
    1574:	cf 92       	push	r12
    1576:	df 92       	push	r13
    1578:	ff 92       	push	r15
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	00 d0       	rcall	.+0      	; 0x1584 <xQueueReceive+0x14>
    1584:	00 d0       	rcall	.+0      	; 0x1586 <xQueueReceive+0x16>
    1586:	1f 92       	push	r1
    1588:	cd b7       	in	r28, 0x3d	; 61
    158a:	de b7       	in	r29, 0x3e	; 62
    158c:	8c 01       	movw	r16, r24
    158e:	6b 01       	movw	r12, r22
    1590:	5d 83       	std	Y+5, r21	; 0x05
    1592:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1594:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1596:	58 01       	movw	r10, r16
    1598:	91 e1       	ldi	r25, 0x11	; 17
    159a:	a9 0e       	add	r10, r25
    159c:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15a4:	f8 01       	movw	r30, r16
    15a6:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15a8:	ff 20       	and	r15, r15
    15aa:	a9 f0       	breq	.+42     	; 0x15d6 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15ac:	b6 01       	movw	r22, r12
    15ae:	c8 01       	movw	r24, r16
    15b0:	0e 94 11 09 	call	0x1222	; 0x1222 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15b4:	fa 94       	dec	r15
    15b6:	f8 01       	movw	r30, r16
    15b8:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15ba:	80 85       	ldd	r24, Z+8	; 0x08
    15bc:	88 23       	and	r24, r24
    15be:	39 f0       	breq	.+14     	; 0x15ce <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15c0:	c8 01       	movw	r24, r16
    15c2:	08 96       	adiw	r24, 0x08	; 8
    15c4:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    15c8:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    15ca:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    15ce:	0f 90       	pop	r0
    15d0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15d2:	81 e0       	ldi	r24, 0x01	; 1
    15d4:	50 c0       	rjmp	.+160    	; 0x1676 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15d6:	2c 81       	ldd	r18, Y+4	; 0x04
    15d8:	3d 81       	ldd	r19, Y+5	; 0x05
    15da:	23 2b       	or	r18, r19
    15dc:	19 f4       	brne	.+6      	; 0x15e4 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15de:	0f 90       	pop	r0
    15e0:	0f be       	out	0x3f, r0	; 63
    15e2:	48 c0       	rjmp	.+144    	; 0x1674 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    15e4:	81 11       	cpse	r24, r1
    15e6:	04 c0       	rjmp	.+8      	; 0x15f0 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    15e8:	ce 01       	movw	r24, r28
    15ea:	01 96       	adiw	r24, 0x01	; 1
    15ec:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15f4:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15f8:	0f b6       	in	r0, 0x3f	; 63
    15fa:	f8 94       	cli
    15fc:	0f 92       	push	r0
    15fe:	f8 01       	movw	r30, r16
    1600:	85 8d       	ldd	r24, Z+29	; 0x1d
    1602:	8f 3f       	cpi	r24, 0xFF	; 255
    1604:	09 f4       	brne	.+2      	; 0x1608 <xQueueReceive+0x98>
    1606:	15 8e       	std	Z+29, r1	; 0x1d
    1608:	f8 01       	movw	r30, r16
    160a:	86 8d       	ldd	r24, Z+30	; 0x1e
    160c:	8f 3f       	cpi	r24, 0xFF	; 255
    160e:	09 f4       	brne	.+2      	; 0x1612 <xQueueReceive+0xa2>
    1610:	16 8e       	std	Z+30, r1	; 0x1e
    1612:	0f 90       	pop	r0
    1614:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1616:	be 01       	movw	r22, r28
    1618:	6c 5f       	subi	r22, 0xFC	; 252
    161a:	7f 4f       	sbci	r23, 0xFF	; 255
    161c:	ce 01       	movw	r24, r28
    161e:	01 96       	adiw	r24, 0x01	; 1
    1620:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xTaskCheckForTimeOut>
    1624:	81 11       	cpse	r24, r1
    1626:	1c c0       	rjmp	.+56     	; 0x1660 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1628:	c8 01       	movw	r24, r16
    162a:	0e 94 be 08 	call	0x117c	; 0x117c <prvIsQueueEmpty>
    162e:	88 23       	and	r24, r24
    1630:	89 f0       	breq	.+34     	; 0x1654 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1632:	6c 81       	ldd	r22, Y+4	; 0x04
    1634:	7d 81       	ldd	r23, Y+5	; 0x05
    1636:	c5 01       	movw	r24, r10
    1638:	0e 94 98 05 	call	0xb30	; 0xb30 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    163c:	c8 01       	movw	r24, r16
    163e:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1642:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    1646:	88 23       	and	r24, r24
    1648:	11 f0       	breq	.+4      	; 0x164e <xQueueReceive+0xde>
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	a8 cf       	rjmp	.-176    	; 0x159e <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    164e:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    1652:	fb cf       	rjmp	.-10     	; 0x164a <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1654:	c8 01       	movw	r24, r16
    1656:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    165a:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    165e:	f5 cf       	rjmp	.-22     	; 0x164a <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1660:	c8 01       	movw	r24, r16
    1662:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1666:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    166a:	c8 01       	movw	r24, r16
    166c:	0e 94 be 08 	call	0x117c	; 0x117c <prvIsQueueEmpty>
    1670:	88 23       	and	r24, r24
    1672:	59 f3       	breq	.-42     	; 0x164a <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1674:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1676:	0f 90       	pop	r0
    1678:	0f 90       	pop	r0
    167a:	0f 90       	pop	r0
    167c:	0f 90       	pop	r0
    167e:	0f 90       	pop	r0
    1680:	df 91       	pop	r29
    1682:	cf 91       	pop	r28
    1684:	1f 91       	pop	r17
    1686:	0f 91       	pop	r16
    1688:	ff 90       	pop	r15
    168a:	df 90       	pop	r13
    168c:	cf 90       	pop	r12
    168e:	bf 90       	pop	r11
    1690:	af 90       	pop	r10
    1692:	08 95       	ret

00001694 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1694:	ef 92       	push	r14
    1696:	ff 92       	push	r15
    1698:	0f 93       	push	r16
    169a:	1f 93       	push	r17
    169c:	cf 93       	push	r28
    169e:	df 93       	push	r29
    16a0:	00 d0       	rcall	.+0      	; 0x16a2 <xQueueSemaphoreTake+0xe>
    16a2:	00 d0       	rcall	.+0      	; 0x16a4 <xQueueSemaphoreTake+0x10>
    16a4:	1f 92       	push	r1
    16a6:	cd b7       	in	r28, 0x3d	; 61
    16a8:	de b7       	in	r29, 0x3e	; 62
    16aa:	8c 01       	movw	r16, r24
    16ac:	7d 83       	std	Y+5, r23	; 0x05
    16ae:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    16b0:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16b2:	78 01       	movw	r14, r16
    16b4:	81 e1       	ldi	r24, 0x11	; 17
    16b6:	e8 0e       	add	r14, r24
    16b8:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16ba:	0f b6       	in	r0, 0x3f	; 63
    16bc:	f8 94       	cli
    16be:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    16c0:	f8 01       	movw	r30, r16
    16c2:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    16c4:	88 23       	and	r24, r24
    16c6:	81 f0       	breq	.+32     	; 0x16e8 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    16c8:	81 50       	subi	r24, 0x01	; 1
    16ca:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16cc:	80 85       	ldd	r24, Z+8	; 0x08
    16ce:	88 23       	and	r24, r24
    16d0:	39 f0       	breq	.+14     	; 0x16e0 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16d2:	c8 01       	movw	r24, r16
    16d4:	08 96       	adiw	r24, 0x08	; 8
    16d6:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    16da:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    16dc:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16e0:	0f 90       	pop	r0
    16e2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16e4:	81 e0       	ldi	r24, 0x01	; 1
    16e6:	50 c0       	rjmp	.+160    	; 0x1788 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16e8:	2c 81       	ldd	r18, Y+4	; 0x04
    16ea:	3d 81       	ldd	r19, Y+5	; 0x05
    16ec:	23 2b       	or	r18, r19
    16ee:	19 f4       	brne	.+6      	; 0x16f6 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    16f0:	0f 90       	pop	r0
    16f2:	0f be       	out	0x3f, r0	; 63
    16f4:	48 c0       	rjmp	.+144    	; 0x1786 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    16f6:	91 11       	cpse	r25, r1
    16f8:	04 c0       	rjmp	.+8      	; 0x1702 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16fa:	ce 01       	movw	r24, r28
    16fc:	01 96       	adiw	r24, 0x01	; 1
    16fe:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1702:	0f 90       	pop	r0
    1704:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1706:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    170a:	0f b6       	in	r0, 0x3f	; 63
    170c:	f8 94       	cli
    170e:	0f 92       	push	r0
    1710:	f8 01       	movw	r30, r16
    1712:	85 8d       	ldd	r24, Z+29	; 0x1d
    1714:	8f 3f       	cpi	r24, 0xFF	; 255
    1716:	09 f4       	brne	.+2      	; 0x171a <xQueueSemaphoreTake+0x86>
    1718:	15 8e       	std	Z+29, r1	; 0x1d
    171a:	f8 01       	movw	r30, r16
    171c:	86 8d       	ldd	r24, Z+30	; 0x1e
    171e:	8f 3f       	cpi	r24, 0xFF	; 255
    1720:	09 f4       	brne	.+2      	; 0x1724 <xQueueSemaphoreTake+0x90>
    1722:	16 8e       	std	Z+30, r1	; 0x1e
    1724:	0f 90       	pop	r0
    1726:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1728:	be 01       	movw	r22, r28
    172a:	6c 5f       	subi	r22, 0xFC	; 252
    172c:	7f 4f       	sbci	r23, 0xFF	; 255
    172e:	ce 01       	movw	r24, r28
    1730:	01 96       	adiw	r24, 0x01	; 1
    1732:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xTaskCheckForTimeOut>
    1736:	81 11       	cpse	r24, r1
    1738:	1c c0       	rjmp	.+56     	; 0x1772 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    173a:	c8 01       	movw	r24, r16
    173c:	0e 94 be 08 	call	0x117c	; 0x117c <prvIsQueueEmpty>
    1740:	88 23       	and	r24, r24
    1742:	89 f0       	breq	.+34     	; 0x1766 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1744:	6c 81       	ldd	r22, Y+4	; 0x04
    1746:	7d 81       	ldd	r23, Y+5	; 0x05
    1748:	c7 01       	movw	r24, r14
    174a:	0e 94 98 05 	call	0xb30	; 0xb30 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    174e:	c8 01       	movw	r24, r16
    1750:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1754:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    1758:	88 23       	and	r24, r24
    175a:	11 f0       	breq	.+4      	; 0x1760 <xQueueSemaphoreTake+0xcc>
    175c:	91 e0       	ldi	r25, 0x01	; 1
    175e:	ad cf       	rjmp	.-166    	; 0x16ba <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1760:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    1764:	fb cf       	rjmp	.-10     	; 0x175c <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1766:	c8 01       	movw	r24, r16
    1768:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    176c:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    1770:	f5 cf       	rjmp	.-22     	; 0x175c <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1772:	c8 01       	movw	r24, r16
    1774:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1778:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    177c:	c8 01       	movw	r24, r16
    177e:	0e 94 be 08 	call	0x117c	; 0x117c <prvIsQueueEmpty>
    1782:	88 23       	and	r24, r24
    1784:	59 f3       	breq	.-42     	; 0x175c <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1786:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1788:	0f 90       	pop	r0
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	0f 90       	pop	r0
    1790:	0f 90       	pop	r0
    1792:	df 91       	pop	r29
    1794:	cf 91       	pop	r28
    1796:	1f 91       	pop	r17
    1798:	0f 91       	pop	r16
    179a:	ff 90       	pop	r15
    179c:	ef 90       	pop	r14
    179e:	08 95       	ret

000017a0 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    17a0:	cf 92       	push	r12
    17a2:	df 92       	push	r13
    17a4:	ef 92       	push	r14
    17a6:	ff 92       	push	r15
    17a8:	0f 93       	push	r16
    17aa:	1f 93       	push	r17
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
    17b0:	00 d0       	rcall	.+0      	; 0x17b2 <xQueuePeek+0x12>
    17b2:	00 d0       	rcall	.+0      	; 0x17b4 <xQueuePeek+0x14>
    17b4:	1f 92       	push	r1
    17b6:	cd b7       	in	r28, 0x3d	; 61
    17b8:	de b7       	in	r29, 0x3e	; 62
    17ba:	8c 01       	movw	r16, r24
    17bc:	7b 01       	movw	r14, r22
    17be:	5d 83       	std	Y+5, r21	; 0x05
    17c0:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    17c2:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17c4:	68 01       	movw	r12, r16
    17c6:	91 e1       	ldi	r25, 0x11	; 17
    17c8:	c9 0e       	add	r12, r25
    17ca:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17cc:	0f b6       	in	r0, 0x3f	; 63
    17ce:	f8 94       	cli
    17d0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17d2:	f8 01       	movw	r30, r16
    17d4:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17d6:	99 23       	and	r25, r25
    17d8:	b9 f0       	breq	.+46     	; 0x1808 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    17da:	c6 80       	ldd	r12, Z+6	; 0x06
    17dc:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17de:	b7 01       	movw	r22, r14
    17e0:	c8 01       	movw	r24, r16
    17e2:	0e 94 11 09 	call	0x1222	; 0x1222 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    17e6:	f8 01       	movw	r30, r16
    17e8:	d7 82       	std	Z+7, r13	; 0x07
    17ea:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ec:	81 89       	ldd	r24, Z+17	; 0x11
    17ee:	88 23       	and	r24, r24
    17f0:	39 f0       	breq	.+14     	; 0x1800 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17f2:	c8 01       	movw	r24, r16
    17f4:	41 96       	adiw	r24, 0x11	; 17
    17f6:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    17fa:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    17fc:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1800:	0f 90       	pop	r0
    1802:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1804:	81 e0       	ldi	r24, 0x01	; 1
    1806:	50 c0       	rjmp	.+160    	; 0x18a8 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1808:	2c 81       	ldd	r18, Y+4	; 0x04
    180a:	3d 81       	ldd	r19, Y+5	; 0x05
    180c:	23 2b       	or	r18, r19
    180e:	19 f4       	brne	.+6      	; 0x1816 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	48 c0       	rjmp	.+144    	; 0x18a6 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1816:	81 11       	cpse	r24, r1
    1818:	04 c0       	rjmp	.+8      	; 0x1822 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    181a:	ce 01       	movw	r24, r28
    181c:	01 96       	adiw	r24, 0x01	; 1
    181e:	0e 94 43 06 	call	0xc86	; 0xc86 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1826:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    182a:	0f b6       	in	r0, 0x3f	; 63
    182c:	f8 94       	cli
    182e:	0f 92       	push	r0
    1830:	f8 01       	movw	r30, r16
    1832:	85 8d       	ldd	r24, Z+29	; 0x1d
    1834:	8f 3f       	cpi	r24, 0xFF	; 255
    1836:	09 f4       	brne	.+2      	; 0x183a <xQueuePeek+0x9a>
    1838:	15 8e       	std	Z+29, r1	; 0x1d
    183a:	f8 01       	movw	r30, r16
    183c:	86 8d       	ldd	r24, Z+30	; 0x1e
    183e:	8f 3f       	cpi	r24, 0xFF	; 255
    1840:	09 f4       	brne	.+2      	; 0x1844 <xQueuePeek+0xa4>
    1842:	16 8e       	std	Z+30, r1	; 0x1e
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1848:	be 01       	movw	r22, r28
    184a:	6c 5f       	subi	r22, 0xFC	; 252
    184c:	7f 4f       	sbci	r23, 0xFF	; 255
    184e:	ce 01       	movw	r24, r28
    1850:	01 96       	adiw	r24, 0x01	; 1
    1852:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xTaskCheckForTimeOut>
    1856:	81 11       	cpse	r24, r1
    1858:	1c c0       	rjmp	.+56     	; 0x1892 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    185a:	c8 01       	movw	r24, r16
    185c:	0e 94 be 08 	call	0x117c	; 0x117c <prvIsQueueEmpty>
    1860:	88 23       	and	r24, r24
    1862:	89 f0       	breq	.+34     	; 0x1886 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1864:	6c 81       	ldd	r22, Y+4	; 0x04
    1866:	7d 81       	ldd	r23, Y+5	; 0x05
    1868:	c6 01       	movw	r24, r12
    186a:	0e 94 98 05 	call	0xb30	; 0xb30 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    186e:	c8 01       	movw	r24, r16
    1870:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1874:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    1878:	88 23       	and	r24, r24
    187a:	11 f0       	breq	.+4      	; 0x1880 <xQueuePeek+0xe0>
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	a6 cf       	rjmp	.-180    	; 0x17cc <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1880:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    1884:	fb cf       	rjmp	.-10     	; 0x187c <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1886:	c8 01       	movw	r24, r16
    1888:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    188c:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
    1890:	f5 cf       	rjmp	.-22     	; 0x187c <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1892:	c8 01       	movw	r24, r16
    1894:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1898:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    189c:	c8 01       	movw	r24, r16
    189e:	0e 94 be 08 	call	0x117c	; 0x117c <prvIsQueueEmpty>
    18a2:	88 23       	and	r24, r24
    18a4:	59 f3       	breq	.-42     	; 0x187c <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18a6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18a8:	0f 90       	pop	r0
    18aa:	0f 90       	pop	r0
    18ac:	0f 90       	pop	r0
    18ae:	0f 90       	pop	r0
    18b0:	0f 90       	pop	r0
    18b2:	df 91       	pop	r29
    18b4:	cf 91       	pop	r28
    18b6:	1f 91       	pop	r17
    18b8:	0f 91       	pop	r16
    18ba:	ff 90       	pop	r15
    18bc:	ef 90       	pop	r14
    18be:	df 90       	pop	r13
    18c0:	cf 90       	pop	r12
    18c2:	08 95       	ret

000018c4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18c4:	ef 92       	push	r14
    18c6:	ff 92       	push	r15
    18c8:	0f 93       	push	r16
    18ca:	1f 93       	push	r17
    18cc:	cf 93       	push	r28
    18ce:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18d0:	fc 01       	movw	r30, r24
    18d2:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18d4:	00 23       	and	r16, r16
    18d6:	e9 f0       	breq	.+58     	; 0x1912 <xQueueReceiveFromISR+0x4e>
    18d8:	7a 01       	movw	r14, r20
    18da:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    18dc:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    18de:	0e 94 11 09 	call	0x1222	; 0x1222 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    18e2:	01 50       	subi	r16, 0x01	; 1
    18e4:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    18e6:	1f 3f       	cpi	r17, 0xFF	; 255
    18e8:	81 f4       	brne	.+32     	; 0x190a <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18ea:	88 85       	ldd	r24, Y+8	; 0x08
    18ec:	88 23       	and	r24, r24
    18ee:	79 f0       	breq	.+30     	; 0x190e <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18f0:	ce 01       	movw	r24, r28
    18f2:	08 96       	adiw	r24, 0x08	; 8
    18f4:	0e 94 c1 05 	call	0xb82	; 0xb82 <xTaskRemoveFromEventList>
    18f8:	88 23       	and	r24, r24
    18fa:	49 f0       	breq	.+18     	; 0x190e <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    18fc:	e1 14       	cp	r14, r1
    18fe:	f1 04       	cpc	r15, r1
    1900:	31 f0       	breq	.+12     	; 0x190e <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	f7 01       	movw	r30, r14
    1906:	80 83       	st	Z, r24
    1908:	05 c0       	rjmp	.+10     	; 0x1914 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    190a:	1f 5f       	subi	r17, 0xFF	; 255
    190c:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    190e:	81 e0       	ldi	r24, 0x01	; 1
    1910:	01 c0       	rjmp	.+2      	; 0x1914 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1912:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1914:	df 91       	pop	r29
    1916:	cf 91       	pop	r28
    1918:	1f 91       	pop	r17
    191a:	0f 91       	pop	r16
    191c:	ff 90       	pop	r15
    191e:	ef 90       	pop	r14
    1920:	08 95       	ret

00001922 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1922:	0f 93       	push	r16
    1924:	1f 93       	push	r17
    1926:	cf 93       	push	r28
    1928:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    192a:	fc 01       	movw	r30, r24
    192c:	22 8d       	ldd	r18, Z+26	; 0x1a
    192e:	22 23       	and	r18, r18
    1930:	49 f0       	breq	.+18     	; 0x1944 <xQueuePeekFromISR+0x22>
    1932:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1934:	06 81       	ldd	r16, Z+6	; 0x06
    1936:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1938:	0e 94 11 09 	call	0x1222	; 0x1222 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    193c:	1f 83       	std	Y+7, r17	; 0x07
    193e:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1940:	81 e0       	ldi	r24, 0x01	; 1
    1942:	01 c0       	rjmp	.+2      	; 0x1946 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1944:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1946:	df 91       	pop	r29
    1948:	cf 91       	pop	r28
    194a:	1f 91       	pop	r17
    194c:	0f 91       	pop	r16
    194e:	08 95       	ret

00001950 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1950:	0f b6       	in	r0, 0x3f	; 63
    1952:	f8 94       	cli
    1954:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1956:	fc 01       	movw	r30, r24
    1958:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    195a:	0f 90       	pop	r0
    195c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    195e:	08 95       	ret

00001960 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1966:	fc 01       	movw	r30, r24
    1968:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    196a:	0f 90       	pop	r0
    196c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    196e:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1970:	82 1b       	sub	r24, r18
    1972:	08 95       	ret

00001974 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1974:	fc 01       	movw	r30, r24
    1976:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1978:	08 95       	ret

0000197a <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    197a:	0c 94 31 10 	jmp	0x2062	; 0x2062 <vPortFree>

0000197e <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    197e:	fc 01       	movw	r30, r24
    1980:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1982:	81 e0       	ldi	r24, 0x01	; 1
    1984:	91 11       	cpse	r25, r1
    1986:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1988:	08 95       	ret

0000198a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    198a:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    198c:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	23 8d       	ldd	r18, Z+27	; 0x1b
    1992:	29 13       	cpse	r18, r25
    1994:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1996:	08 95       	ret

00001998 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1998:	cf 93       	push	r28
    199a:	df 93       	push	r29
    199c:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    199e:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19a8:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19aa:	0f 90       	pop	r0
    19ac:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19ae:	89 13       	cpse	r24, r25
    19b0:	0f c0       	rjmp	.+30     	; 0x19d0 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    19b2:	41 15       	cp	r20, r1
    19b4:	51 05       	cpc	r21, r1
    19b6:	49 f0       	breq	.+18     	; 0x19ca <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    19b8:	be 01       	movw	r22, r28
    19ba:	68 5f       	subi	r22, 0xF8	; 248
    19bc:	7f 4f       	sbci	r23, 0xFF	; 255
    19be:	ca 01       	movw	r24, r20
    19c0:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    19c4:	78 94       	sei
					return errQUEUE_BLOCKED;
    19c6:	8c ef       	ldi	r24, 0xFC	; 252
    19c8:	1b c0       	rjmp	.+54     	; 0x1a00 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    19ca:	78 94       	sei
					return errQUEUE_FULL;
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	18 c0       	rjmp	.+48     	; 0x1a00 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    19d0:	78 94       	sei

		portDISABLE_INTERRUPTS();
    19d2:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19d6:	89 17       	cp	r24, r25
    19d8:	88 f4       	brcc	.+34     	; 0x19fc <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    19da:	40 e0       	ldi	r20, 0x00	; 0
    19dc:	ce 01       	movw	r24, r28
    19de:	0e 94 c9 08 	call	0x1192	; 0x1192 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19e2:	89 89       	ldd	r24, Y+17	; 0x11
    19e4:	81 11       	cpse	r24, r1
    19e6:	02 c0       	rjmp	.+4      	; 0x19ec <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	09 c0       	rjmp	.+18     	; 0x19fe <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19ec:	ce 01       	movw	r24, r28
    19ee:	41 96       	adiw	r24, 0x11	; 17
    19f0:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <xCoRoutineRemoveFromEventList>
    19f4:	88 23       	and	r24, r24
    19f6:	c1 f3       	breq	.-16     	; 0x19e8 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    19f8:	8b ef       	ldi	r24, 0xFB	; 251
    19fa:	01 c0       	rjmp	.+2      	; 0x19fe <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    19fc:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    19fe:	78 94       	sei

		return xReturn;
	}
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	08 95       	ret

00001a06 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a06:	cf 93       	push	r28
    1a08:	df 93       	push	r29
    1a0a:	ec 01       	movw	r28, r24
    1a0c:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a0e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a12:	81 11       	cpse	r24, r1
    1a14:	0f c0       	rjmp	.+30     	; 0x1a34 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a16:	41 15       	cp	r20, r1
    1a18:	51 05       	cpc	r21, r1
    1a1a:	49 f0       	breq	.+18     	; 0x1a2e <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a1c:	be 01       	movw	r22, r28
    1a1e:	6f 5e       	subi	r22, 0xEF	; 239
    1a20:	7f 4f       	sbci	r23, 0xFF	; 255
    1a22:	ca 01       	movw	r24, r20
    1a24:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a28:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a2a:	8c ef       	ldi	r24, 0xFC	; 252
    1a2c:	30 c0       	rjmp	.+96     	; 0x1a8e <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a2e:	78 94       	sei
					return errQUEUE_FULL;
    1a30:	80 e0       	ldi	r24, 0x00	; 0
    1a32:	2d c0       	rjmp	.+90     	; 0x1a8e <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1a34:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a36:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a38:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a3a:	88 23       	and	r24, r24
    1a3c:	31 f1       	breq	.+76     	; 0x1a8a <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1a3e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a40:	50 e0       	ldi	r21, 0x00	; 0
    1a42:	2e 81       	ldd	r18, Y+6	; 0x06
    1a44:	3f 81       	ldd	r19, Y+7	; 0x07
    1a46:	24 0f       	add	r18, r20
    1a48:	35 1f       	adc	r19, r21
    1a4a:	3f 83       	std	Y+7, r19	; 0x07
    1a4c:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1a4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a50:	9d 81       	ldd	r25, Y+5	; 0x05
    1a52:	28 17       	cp	r18, r24
    1a54:	39 07       	cpc	r19, r25
    1a56:	20 f0       	brcs	.+8      	; 0x1a60 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1a58:	88 81       	ld	r24, Y
    1a5a:	99 81       	ldd	r25, Y+1	; 0x01
    1a5c:	9f 83       	std	Y+7, r25	; 0x07
    1a5e:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1a60:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a62:	91 50       	subi	r25, 0x01	; 1
    1a64:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a66:	6e 81       	ldd	r22, Y+6	; 0x06
    1a68:	7f 81       	ldd	r23, Y+7	; 0x07
    1a6a:	cf 01       	movw	r24, r30
    1a6c:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a70:	88 85       	ldd	r24, Y+8	; 0x08
    1a72:	81 11       	cpse	r24, r1
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	09 c0       	rjmp	.+18     	; 0x1a8c <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a7a:	ce 01       	movw	r24, r28
    1a7c:	08 96       	adiw	r24, 0x08	; 8
    1a7e:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <xCoRoutineRemoveFromEventList>
    1a82:	88 23       	and	r24, r24
    1a84:	c1 f3       	breq	.-16     	; 0x1a76 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1a86:	8b ef       	ldi	r24, 0xFB	; 251
    1a88:	01 c0       	rjmp	.+2      	; 0x1a8c <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1a8a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a8c:	78 94       	sei

		return xReturn;
	}
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	08 95       	ret

00001a94 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1a94:	0f 93       	push	r16
    1a96:	1f 93       	push	r17
    1a98:	cf 93       	push	r28
    1a9a:	8c 01       	movw	r16, r24
    1a9c:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a9e:	fc 01       	movw	r30, r24
    1aa0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1aa2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1aa4:	98 17       	cp	r25, r24
    1aa6:	10 f0       	brcs	.+4      	; 0x1aac <xQueueCRSendFromISR+0x18>
    1aa8:	4c 2f       	mov	r20, r28
    1aaa:	12 c0       	rjmp	.+36     	; 0x1ad0 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1aac:	40 e0       	ldi	r20, 0x00	; 0
    1aae:	c8 01       	movw	r24, r16
    1ab0:	0e 94 c9 08 	call	0x1192	; 0x1192 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1ab4:	c1 11       	cpse	r28, r1
    1ab6:	f8 cf       	rjmp	.-16     	; 0x1aa8 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ab8:	f8 01       	movw	r30, r16
    1aba:	81 89       	ldd	r24, Z+17	; 0x11
    1abc:	88 23       	and	r24, r24
    1abe:	39 f0       	breq	.+14     	; 0x1ace <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	41 96       	adiw	r24, 0x11	; 17
    1ac4:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1ac8:	41 e0       	ldi	r20, 0x01	; 1
    1aca:	81 11       	cpse	r24, r1
    1acc:	01 c0       	rjmp	.+2      	; 0x1ad0 <xQueueCRSendFromISR+0x3c>
    1ace:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1ad0:	84 2f       	mov	r24, r20
    1ad2:	cf 91       	pop	r28
    1ad4:	1f 91       	pop	r17
    1ad6:	0f 91       	pop	r16
    1ad8:	08 95       	ret

00001ada <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1ada:	0f 93       	push	r16
    1adc:	1f 93       	push	r17
    1ade:	cf 93       	push	r28
    1ae0:	df 93       	push	r29
    1ae2:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ae4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ae6:	88 23       	and	r24, r24
    1ae8:	79 f1       	breq	.+94     	; 0x1b48 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1aea:	24 8d       	ldd	r18, Z+28	; 0x1c
    1aec:	30 e0       	ldi	r19, 0x00	; 0
    1aee:	a6 81       	ldd	r26, Z+6	; 0x06
    1af0:	b7 81       	ldd	r27, Z+7	; 0x07
    1af2:	a2 0f       	add	r26, r18
    1af4:	b3 1f       	adc	r27, r19
    1af6:	b7 83       	std	Z+7, r27	; 0x07
    1af8:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1afa:	84 81       	ldd	r24, Z+4	; 0x04
    1afc:	95 81       	ldd	r25, Z+5	; 0x05
    1afe:	a8 17       	cp	r26, r24
    1b00:	b9 07       	cpc	r27, r25
    1b02:	20 f0       	brcs	.+8      	; 0x1b0c <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b04:	80 81       	ld	r24, Z
    1b06:	91 81       	ldd	r25, Z+1	; 0x01
    1b08:	97 83       	std	Z+7, r25	; 0x07
    1b0a:	86 83       	std	Z+6, r24	; 0x06
    1b0c:	8a 01       	movw	r16, r20
    1b0e:	cb 01       	movw	r24, r22
    1b10:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b12:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b14:	41 50       	subi	r20, 0x01	; 1
    1b16:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b18:	66 81       	ldd	r22, Z+6	; 0x06
    1b1a:	77 81       	ldd	r23, Z+7	; 0x07
    1b1c:	a9 01       	movw	r20, r18
    1b1e:	0e 94 0b 12 	call	0x2416	; 0x2416 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b22:	f8 01       	movw	r30, r16
    1b24:	80 81       	ld	r24, Z
    1b26:	88 23       	and	r24, r24
    1b28:	11 f0       	breq	.+4      	; 0x1b2e <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	0e c0       	rjmp	.+28     	; 0x1b4a <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b2e:	88 85       	ldd	r24, Y+8	; 0x08
    1b30:	88 23       	and	r24, r24
    1b32:	d9 f3       	breq	.-10     	; 0x1b2a <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b34:	ce 01       	movw	r24, r28
    1b36:	08 96       	adiw	r24, 0x08	; 8
    1b38:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <xCoRoutineRemoveFromEventList>
    1b3c:	88 23       	and	r24, r24
    1b3e:	a9 f3       	breq	.-22     	; 0x1b2a <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	f8 01       	movw	r30, r16
    1b44:	80 83       	st	Z, r24
    1b46:	01 c0       	rjmp	.+2      	; 0x1b4a <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b48:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1b4a:	df 91       	pop	r29
    1b4c:	cf 91       	pop	r28
    1b4e:	1f 91       	pop	r17
    1b50:	0f 91       	pop	r16
    1b52:	08 95       	ret

00001b54 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b54:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b56:	03 96       	adiw	r24, 0x03	; 3
    1b58:	92 83       	std	Z+2, r25	; 0x02
    1b5a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b5c:	2f ef       	ldi	r18, 0xFF	; 255
    1b5e:	3f ef       	ldi	r19, 0xFF	; 255
    1b60:	34 83       	std	Z+4, r19	; 0x04
    1b62:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b64:	96 83       	std	Z+6, r25	; 0x06
    1b66:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b68:	90 87       	std	Z+8, r25	; 0x08
    1b6a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b6c:	10 82       	st	Z, r1
    1b6e:	08 95       	ret

00001b70 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1b70:	fc 01       	movw	r30, r24
    1b72:	11 86       	std	Z+9, r1	; 0x09
    1b74:	10 86       	std	Z+8, r1	; 0x08
    1b76:	08 95       	ret

00001b78 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b78:	cf 93       	push	r28
    1b7a:	df 93       	push	r29
    1b7c:	9c 01       	movw	r18, r24
    1b7e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1b80:	dc 01       	movw	r26, r24
    1b82:	11 96       	adiw	r26, 0x01	; 1
    1b84:	cd 91       	ld	r28, X+
    1b86:	dc 91       	ld	r29, X
    1b88:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1b8a:	d3 83       	std	Z+3, r29	; 0x03
    1b8c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b8e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b90:	9d 81       	ldd	r25, Y+5	; 0x05
    1b92:	95 83       	std	Z+5, r25	; 0x05
    1b94:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b96:	8c 81       	ldd	r24, Y+4	; 0x04
    1b98:	9d 81       	ldd	r25, Y+5	; 0x05
    1b9a:	dc 01       	movw	r26, r24
    1b9c:	13 96       	adiw	r26, 0x03	; 3
    1b9e:	7c 93       	st	X, r23
    1ba0:	6e 93       	st	-X, r22
    1ba2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1ba4:	7d 83       	std	Y+5, r23	; 0x05
    1ba6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1ba8:	31 87       	std	Z+9, r19	; 0x09
    1baa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1bac:	f9 01       	movw	r30, r18
    1bae:	80 81       	ld	r24, Z
    1bb0:	8f 5f       	subi	r24, 0xFF	; 255
    1bb2:	80 83       	st	Z, r24
}
    1bb4:	df 91       	pop	r29
    1bb6:	cf 91       	pop	r28
    1bb8:	08 95       	ret

00001bba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bba:	0f 93       	push	r16
    1bbc:	1f 93       	push	r17
    1bbe:	cf 93       	push	r28
    1bc0:	df 93       	push	r29
    1bc2:	8c 01       	movw	r16, r24
    1bc4:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1bc6:	80 81       	ld	r24, Z
    1bc8:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bca:	8f 3f       	cpi	r24, 0xFF	; 255
    1bcc:	2f ef       	ldi	r18, 0xFF	; 255
    1bce:	92 07       	cpc	r25, r18
    1bd0:	21 f4       	brne	.+8      	; 0x1bda <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1bd2:	e8 01       	movw	r28, r16
    1bd4:	af 81       	ldd	r26, Y+7	; 0x07
    1bd6:	b8 85       	ldd	r27, Y+8	; 0x08
    1bd8:	0e c0       	rjmp	.+28     	; 0x1bf6 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1bda:	d8 01       	movw	r26, r16
    1bdc:	13 96       	adiw	r26, 0x03	; 3
    1bde:	12 96       	adiw	r26, 0x02	; 2
    1be0:	2d 91       	ld	r18, X+
    1be2:	3c 91       	ld	r19, X
    1be4:	13 97       	sbiw	r26, 0x03	; 3
    1be6:	e9 01       	movw	r28, r18
    1be8:	48 81       	ld	r20, Y
    1bea:	59 81       	ldd	r21, Y+1	; 0x01
    1bec:	84 17       	cp	r24, r20
    1bee:	95 07       	cpc	r25, r21
    1bf0:	10 f0       	brcs	.+4      	; 0x1bf6 <vListInsert+0x3c>
    1bf2:	d9 01       	movw	r26, r18
    1bf4:	f4 cf       	rjmp	.-24     	; 0x1bde <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1bf6:	12 96       	adiw	r26, 0x02	; 2
    1bf8:	8d 91       	ld	r24, X+
    1bfa:	9c 91       	ld	r25, X
    1bfc:	13 97       	sbiw	r26, 0x03	; 3
    1bfe:	93 83       	std	Z+3, r25	; 0x03
    1c00:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c02:	ec 01       	movw	r28, r24
    1c04:	fd 83       	std	Y+5, r31	; 0x05
    1c06:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c08:	b5 83       	std	Z+5, r27	; 0x05
    1c0a:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c0c:	13 96       	adiw	r26, 0x03	; 3
    1c0e:	fc 93       	st	X, r31
    1c10:	ee 93       	st	-X, r30
    1c12:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c14:	11 87       	std	Z+9, r17	; 0x09
    1c16:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c18:	f8 01       	movw	r30, r16
    1c1a:	80 81       	ld	r24, Z
    1c1c:	8f 5f       	subi	r24, 0xFF	; 255
    1c1e:	80 83       	st	Z, r24
}
    1c20:	df 91       	pop	r29
    1c22:	cf 91       	pop	r28
    1c24:	1f 91       	pop	r17
    1c26:	0f 91       	pop	r16
    1c28:	08 95       	ret

00001c2a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c2a:	cf 93       	push	r28
    1c2c:	df 93       	push	r29
    1c2e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c30:	a0 85       	ldd	r26, Z+8	; 0x08
    1c32:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c34:	82 81       	ldd	r24, Z+2	; 0x02
    1c36:	93 81       	ldd	r25, Z+3	; 0x03
    1c38:	24 81       	ldd	r18, Z+4	; 0x04
    1c3a:	35 81       	ldd	r19, Z+5	; 0x05
    1c3c:	ec 01       	movw	r28, r24
    1c3e:	3d 83       	std	Y+5, r19	; 0x05
    1c40:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c42:	c4 81       	ldd	r28, Z+4	; 0x04
    1c44:	d5 81       	ldd	r29, Z+5	; 0x05
    1c46:	9b 83       	std	Y+3, r25	; 0x03
    1c48:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c4a:	11 96       	adiw	r26, 0x01	; 1
    1c4c:	8d 91       	ld	r24, X+
    1c4e:	9c 91       	ld	r25, X
    1c50:	12 97       	sbiw	r26, 0x02	; 2
    1c52:	e8 17       	cp	r30, r24
    1c54:	f9 07       	cpc	r31, r25
    1c56:	21 f4       	brne	.+8      	; 0x1c60 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c58:	12 96       	adiw	r26, 0x02	; 2
    1c5a:	dc 93       	st	X, r29
    1c5c:	ce 93       	st	-X, r28
    1c5e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1c60:	11 86       	std	Z+9, r1	; 0x09
    1c62:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c64:	8c 91       	ld	r24, X
    1c66:	81 50       	subi	r24, 0x01	; 1
    1c68:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1c6a:	8c 91       	ld	r24, X
}
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	08 95       	ret

00001c72 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1c72:	cf 92       	push	r12
    1c74:	df 92       	push	r13
    1c76:	ef 92       	push	r14
    1c78:	ff 92       	push	r15
    1c7a:	1f 93       	push	r17
    1c7c:	cf 93       	push	r28
    1c7e:	df 93       	push	r29
    1c80:	6c 01       	movw	r12, r24
    1c82:	16 2f       	mov	r17, r22
    1c84:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1c86:	8a e1       	ldi	r24, 0x1A	; 26
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <pvPortMalloc>
    1c8e:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1c90:	89 2b       	or	r24, r25
    1c92:	09 f4       	brne	.+2      	; 0x1c96 <xCoRoutineCreate+0x24>
    1c94:	57 c0       	rjmp	.+174    	; 0x1d44 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1c96:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1c9a:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1c9e:	89 2b       	or	r24, r25
    1ca0:	21 f5       	brne	.+72     	; 0x1cea <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1ca2:	d0 93 95 01 	sts	0x0195, r29	; 0x800195 <pxCurrentCoRoutine+0x1>
    1ca6:	c0 93 94 01 	sts	0x0194, r28	; 0x800194 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1caa:	8c eb       	ldi	r24, 0xBC	; 188
    1cac:	91 e0       	ldi	r25, 0x01	; 1
    1cae:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
    1cb2:	85 ec       	ldi	r24, 0xC5	; 197
    1cb4:	91 e0       	ldi	r25, 0x01	; 1
    1cb6:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1cba:	83 eb       	ldi	r24, 0xB3	; 179
    1cbc:	91 e0       	ldi	r25, 0x01	; 1
    1cbe:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1cc2:	8a ea       	ldi	r24, 0xAA	; 170
    1cc4:	91 e0       	ldi	r25, 0x01	; 1
    1cc6:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1cca:	8d e9       	ldi	r24, 0x9D	; 157
    1ccc:	91 e0       	ldi	r25, 0x01	; 1
    1cce:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1cd2:	83 eb       	ldi	r24, 0xB3	; 179
    1cd4:	91 e0       	ldi	r25, 0x01	; 1
    1cd6:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1cda:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1cde:	8a ea       	ldi	r24, 0xAA	; 170
    1ce0:	91 e0       	ldi	r25, 0x01	; 1
    1ce2:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1ce6:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1cea:	11 11       	cpse	r17, r1
    1cec:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1cee:	19 8e       	std	Y+25, r1	; 0x19
    1cf0:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1cf2:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1cf4:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1cf6:	fe 01       	movw	r30, r28
    1cf8:	c1 92       	st	Z+, r12
    1cfa:	d1 92       	st	Z+, r13
    1cfc:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1cfe:	cf 01       	movw	r24, r30
    1d00:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d04:	ce 01       	movw	r24, r28
    1d06:	0c 96       	adiw	r24, 0x0c	; 12
    1d08:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d0c:	d9 87       	std	Y+9, r29	; 0x09
    1d0e:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d10:	db 8b       	std	Y+19, r29	; 0x13
    1d12:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d14:	82 e0       	ldi	r24, 0x02	; 2
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	81 1b       	sub	r24, r17
    1d1a:	91 09       	sbc	r25, r1
    1d1c:	9d 87       	std	Y+13, r25	; 0x0d
    1d1e:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d20:	8e 89       	ldd	r24, Y+22	; 0x16
    1d22:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>
    1d26:	98 17       	cp	r25, r24
    1d28:	10 f4       	brcc	.+4      	; 0x1d2e <xCoRoutineCreate+0xbc>
    1d2a:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
    1d2e:	f9 e0       	ldi	r31, 0x09	; 9
    1d30:	8f 9f       	mul	r24, r31
    1d32:	c0 01       	movw	r24, r0
    1d34:	11 24       	eor	r1, r1
    1d36:	b7 01       	movw	r22, r14
    1d38:	84 54       	subi	r24, 0x44	; 68
    1d3a:	9e 4f       	sbci	r25, 0xFE	; 254
    1d3c:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

		xReturn = pdPASS;
    1d40:	81 e0       	ldi	r24, 0x01	; 1
    1d42:	01 c0       	rjmp	.+2      	; 0x1d46 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d44:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1d46:	df 91       	pop	r29
    1d48:	cf 91       	pop	r28
    1d4a:	1f 91       	pop	r17
    1d4c:	ff 90       	pop	r15
    1d4e:	ef 90       	pop	r14
    1d50:	df 90       	pop	r13
    1d52:	cf 90       	pop	r12
    1d54:	08 95       	ret

00001d56 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1d56:	0f 93       	push	r16
    1d58:	1f 93       	push	r17
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1d60:	c0 91 9a 01 	lds	r28, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1d64:	d0 91 9b 01 	lds	r29, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1d68:	c8 0f       	add	r28, r24
    1d6a:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1d6c:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1d70:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1d74:	02 96       	adiw	r24, 0x02	; 2
    1d76:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1d7a:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1d7e:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1d82:	d3 83       	std	Z+3, r29	; 0x03
    1d84:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1d86:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1d8a:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1d8e:	bf 01       	movw	r22, r30
    1d90:	6e 5f       	subi	r22, 0xFE	; 254
    1d92:	7f 4f       	sbci	r23, 0xFF	; 255
    1d94:	c8 17       	cp	r28, r24
    1d96:	d9 07       	cpc	r29, r25
    1d98:	28 f4       	brcc	.+10     	; 0x1da4 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1d9a:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1d9e:	90 91 a7 01 	lds	r25, 0x01A7	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1da2:	04 c0       	rjmp	.+8      	; 0x1dac <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1da4:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <pxDelayedCoRoutineList>
    1da8:	90 91 a9 01 	lds	r25, 0x01A9	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1dac:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <vListInsert>
	}

	if( pxEventList )
    1db0:	01 15       	cp	r16, r1
    1db2:	11 05       	cpc	r17, r1
    1db4:	69 f0       	breq	.+26     	; 0x1dd0 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1db6:	60 91 94 01 	lds	r22, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1dba:	70 91 95 01 	lds	r23, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
    1dbe:	64 5f       	subi	r22, 0xF4	; 244
    1dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1dc2:	c8 01       	movw	r24, r16
	}
}
    1dc4:	df 91       	pop	r29
    1dc6:	cf 91       	pop	r28
    1dc8:	1f 91       	pop	r17
    1dca:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1dcc:	0c 94 dd 0d 	jmp	0x1bba	; 0x1bba <vListInsert>
	}
}
    1dd0:	df 91       	pop	r29
    1dd2:	cf 91       	pop	r28
    1dd4:	1f 91       	pop	r17
    1dd6:	0f 91       	pop	r16
    1dd8:	08 95       	ret

00001dda <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1dda:	ff 92       	push	r15
    1ddc:	0f 93       	push	r16
    1dde:	1f 93       	push	r17
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1de4:	99 e0       	ldi	r25, 0x09	; 9
    1de6:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1de8:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <xPendingReadyCoRoutineList>
    1dec:	88 23       	and	r24, r24
    1dee:	11 f1       	breq	.+68     	; 0x1e34 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1df0:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1df2:	e0 91 a2 01 	lds	r30, 0x01A2	; 0x8001a2 <xPendingReadyCoRoutineList+0x5>
    1df6:	f0 91 a3 01 	lds	r31, 0x01A3	; 0x8001a3 <xPendingReadyCoRoutineList+0x6>
    1dfa:	c6 81       	ldd	r28, Z+6	; 0x06
    1dfc:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1dfe:	ce 01       	movw	r24, r28
    1e00:	0c 96       	adiw	r24, 0x0c	; 12
    1e02:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e06:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e08:	8e 01       	movw	r16, r28
    1e0a:	0e 5f       	subi	r16, 0xFE	; 254
    1e0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e0e:	c8 01       	movw	r24, r16
    1e10:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e14:	8e 89       	ldd	r24, Y+22	; 0x16
    1e16:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>
    1e1a:	98 17       	cp	r25, r24
    1e1c:	10 f4       	brcc	.+4      	; 0x1e22 <vCoRoutineSchedule+0x48>
    1e1e:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
    1e22:	f8 9e       	mul	r15, r24
    1e24:	c0 01       	movw	r24, r0
    1e26:	11 24       	eor	r1, r1
    1e28:	b8 01       	movw	r22, r16
    1e2a:	84 54       	subi	r24, 0x44	; 68
    1e2c:	9e 4f       	sbci	r25, 0xFE	; 254
    1e2e:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
    1e32:	da cf       	rjmp	.-76     	; 0x1de8 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e34:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xTaskGetTickCount>
    1e38:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <xLastTickCount>
    1e3c:	30 91 99 01 	lds	r19, 0x0199	; 0x800199 <xLastTickCount+0x1>
    1e40:	82 1b       	sub	r24, r18
    1e42:	93 0b       	sbc	r25, r19
    1e44:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <xPassedTicks+0x1>
    1e48:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1e4c:	89 e0       	ldi	r24, 0x09	; 9
    1e4e:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e50:	20 91 96 01 	lds	r18, 0x0196	; 0x800196 <xPassedTicks>
    1e54:	30 91 97 01 	lds	r19, 0x0197	; 0x800197 <xPassedTicks+0x1>
    1e58:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1e5c:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1e60:	21 15       	cp	r18, r1
    1e62:	31 05       	cpc	r19, r1
    1e64:	09 f4       	brne	.+2      	; 0x1e68 <vCoRoutineSchedule+0x8e>
    1e66:	54 c0       	rjmp	.+168    	; 0x1f10 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1e68:	01 96       	adiw	r24, 0x01	; 1
    1e6a:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <xCoRoutineTickCount+0x1>
    1e6e:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <xCoRoutineTickCount>
		xPassedTicks--;
    1e72:	21 50       	subi	r18, 0x01	; 1
    1e74:	31 09       	sbc	r19, r1
    1e76:	30 93 97 01 	sts	0x0197, r19	; 0x800197 <xPassedTicks+0x1>
    1e7a:	20 93 96 01 	sts	0x0196, r18	; 0x800196 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1e7e:	89 2b       	or	r24, r25
    1e80:	09 f0       	breq	.+2      	; 0x1e84 <vCoRoutineSchedule+0xaa>
    1e82:	3e c0       	rjmp	.+124    	; 0x1f00 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1e84:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <pxDelayedCoRoutineList>
    1e88:	90 91 a9 01 	lds	r25, 0x01A9	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1e8c:	20 91 a6 01 	lds	r18, 0x01A6	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1e90:	30 91 a7 01 	lds	r19, 0x01A7	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1e94:	30 93 a9 01 	sts	0x01A9, r19	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1e98:	20 93 a8 01 	sts	0x01A8, r18	; 0x8001a8 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1e9c:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <pxOverflowDelayedCoRoutineList+0x1>
    1ea0:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <pxOverflowDelayedCoRoutineList>
    1ea4:	2d c0       	rjmp	.+90     	; 0x1f00 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1ea6:	05 80       	ldd	r0, Z+5	; 0x05
    1ea8:	f6 81       	ldd	r31, Z+6	; 0x06
    1eaa:	e0 2d       	mov	r30, r0
    1eac:	c6 81       	ldd	r28, Z+6	; 0x06
    1eae:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1eb0:	2a 81       	ldd	r18, Y+2	; 0x02
    1eb2:	3b 81       	ldd	r19, Y+3	; 0x03
    1eb4:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xCoRoutineTickCount>
    1eb8:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xCoRoutineTickCount+0x1>
    1ebc:	82 17       	cp	r24, r18
    1ebe:	93 07       	cpc	r25, r19
    1ec0:	38 f2       	brcs	.-114    	; 0x1e50 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1ec2:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1ec4:	8e 01       	movw	r16, r28
    1ec6:	0e 5f       	subi	r16, 0xFE	; 254
    1ec8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eca:	c8 01       	movw	r24, r16
    1ecc:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1ed0:	8c 89       	ldd	r24, Y+20	; 0x14
    1ed2:	9d 89       	ldd	r25, Y+21	; 0x15
    1ed4:	89 2b       	or	r24, r25
    1ed6:	21 f0       	breq	.+8      	; 0x1ee0 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1ed8:	ce 01       	movw	r24, r28
    1eda:	0c 96       	adiw	r24, 0x0c	; 12
    1edc:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1ee0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1ee2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ee4:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>
    1ee8:	98 17       	cp	r25, r24
    1eea:	10 f4       	brcc	.+4      	; 0x1ef0 <vCoRoutineSchedule+0x116>
    1eec:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
    1ef0:	f8 9e       	mul	r15, r24
    1ef2:	c0 01       	movw	r24, r0
    1ef4:	11 24       	eor	r1, r1
    1ef6:	b8 01       	movw	r22, r16
    1ef8:	84 54       	subi	r24, 0x44	; 68
    1efa:	9e 4f       	sbci	r25, 0xFE	; 254
    1efc:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f00:	e0 91 a8 01 	lds	r30, 0x01A8	; 0x8001a8 <pxDelayedCoRoutineList>
    1f04:	f0 91 a9 01 	lds	r31, 0x01A9	; 0x8001a9 <pxDelayedCoRoutineList+0x1>
    1f08:	80 81       	ld	r24, Z
    1f0a:	81 11       	cpse	r24, r1
    1f0c:	cc cf       	rjmp	.-104    	; 0x1ea6 <vCoRoutineSchedule+0xcc>
    1f0e:	a0 cf       	rjmp	.-192    	; 0x1e50 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f10:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <xLastTickCount+0x1>
    1f14:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <xLastTickCount>
    1f18:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f1c:	69 e0       	ldi	r22, 0x09	; 9
    1f1e:	48 2f       	mov	r20, r24
    1f20:	50 e0       	ldi	r21, 0x00	; 0
    1f22:	64 9f       	mul	r22, r20
    1f24:	90 01       	movw	r18, r0
    1f26:	65 9f       	mul	r22, r21
    1f28:	30 0d       	add	r19, r0
    1f2a:	11 24       	eor	r1, r1
    1f2c:	f9 01       	movw	r30, r18
    1f2e:	e4 54       	subi	r30, 0x44	; 68
    1f30:	fe 4f       	sbci	r31, 0xFE	; 254
    1f32:	90 81       	ld	r25, Z
    1f34:	91 11       	cpse	r25, r1
    1f36:	0c c0       	rjmp	.+24     	; 0x1f50 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1f38:	81 11       	cpse	r24, r1
    1f3a:	08 c0       	rjmp	.+16     	; 0x1f4c <vCoRoutineSchedule+0x172>
    1f3c:	10 92 9c 01 	sts	0x019C, r1	; 0x80019c <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1f40:	df 91       	pop	r29
    1f42:	cf 91       	pop	r28
    1f44:	1f 91       	pop	r17
    1f46:	0f 91       	pop	r16
    1f48:	ff 90       	pop	r15
    1f4a:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1f4c:	81 50       	subi	r24, 0x01	; 1
    1f4e:	e7 cf       	rjmp	.-50     	; 0x1f1e <vCoRoutineSchedule+0x144>
    1f50:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f54:	a1 81       	ldd	r26, Z+1	; 0x01
    1f56:	b2 81       	ldd	r27, Z+2	; 0x02
    1f58:	12 96       	adiw	r26, 0x02	; 2
    1f5a:	0d 90       	ld	r0, X+
    1f5c:	bc 91       	ld	r27, X
    1f5e:	a0 2d       	mov	r26, r0
    1f60:	b2 83       	std	Z+2, r27	; 0x02
    1f62:	a1 83       	std	Z+1, r26	; 0x01
    1f64:	21 54       	subi	r18, 0x41	; 65
    1f66:	3e 4f       	sbci	r19, 0xFE	; 254
    1f68:	a2 17       	cp	r26, r18
    1f6a:	b3 07       	cpc	r27, r19
    1f6c:	31 f4       	brne	.+12     	; 0x1f7a <vCoRoutineSchedule+0x1a0>
    1f6e:	12 96       	adiw	r26, 0x02	; 2
    1f70:	8d 91       	ld	r24, X+
    1f72:	9c 91       	ld	r25, X
    1f74:	13 97       	sbiw	r26, 0x03	; 3
    1f76:	92 83       	std	Z+2, r25	; 0x02
    1f78:	81 83       	std	Z+1, r24	; 0x01
    1f7a:	89 e0       	ldi	r24, 0x09	; 9
    1f7c:	84 9f       	mul	r24, r20
    1f7e:	f0 01       	movw	r30, r0
    1f80:	85 9f       	mul	r24, r21
    1f82:	f0 0d       	add	r31, r0
    1f84:	11 24       	eor	r1, r1
    1f86:	e4 54       	subi	r30, 0x44	; 68
    1f88:	fe 4f       	sbci	r31, 0xFE	; 254
    1f8a:	01 80       	ldd	r0, Z+1	; 0x01
    1f8c:	f2 81       	ldd	r31, Z+2	; 0x02
    1f8e:	e0 2d       	mov	r30, r0
    1f90:	86 81       	ldd	r24, Z+6	; 0x06
    1f92:	97 81       	ldd	r25, Z+7	; 0x07
    1f94:	90 93 95 01 	sts	0x0195, r25	; 0x800195 <pxCurrentCoRoutine+0x1>
    1f98:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	ed 91       	ld	r30, X+
    1fa0:	fc 91       	ld	r31, X
    1fa2:	11 97       	sbiw	r26, 0x01	; 1
    1fa4:	57 96       	adiw	r26, 0x17	; 23
    1fa6:	6c 91       	ld	r22, X

	return;
}
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	1f 91       	pop	r17
    1fae:	0f 91       	pop	r16
    1fb0:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fb2:	09 94       	ijmp

00001fb4 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1fb4:	0f 93       	push	r16
    1fb6:	1f 93       	push	r17
    1fb8:	cf 93       	push	r28
    1fba:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1fbc:	dc 01       	movw	r26, r24
    1fbe:	15 96       	adiw	r26, 0x05	; 5
    1fc0:	ed 91       	ld	r30, X+
    1fc2:	fc 91       	ld	r31, X
    1fc4:	16 97       	sbiw	r26, 0x06	; 6
    1fc6:	c6 81       	ldd	r28, Z+6	; 0x06
    1fc8:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1fca:	8e 01       	movw	r16, r28
    1fcc:	04 5f       	subi	r16, 0xF4	; 244
    1fce:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd0:	c8 01       	movw	r24, r16
    1fd2:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1fd6:	b8 01       	movw	r22, r16
    1fd8:	8d e9       	ldi	r24, 0x9D	; 157
    1fda:	91 e0       	ldi	r25, 0x01	; 1
    1fdc:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1fe0:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <pxCurrentCoRoutine>
    1fe4:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	2e 89       	ldd	r18, Y+22	; 0x16
    1fec:	96 89       	ldd	r25, Z+22	; 0x16
    1fee:	29 17       	cp	r18, r25
    1ff0:	08 f4       	brcc	.+2      	; 0x1ff4 <xCoRoutineRemoveFromEventList+0x40>
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
}
    1ff4:	df 91       	pop	r29
    1ff6:	cf 91       	pop	r28
    1ff8:	1f 91       	pop	r17
    1ffa:	0f 91       	pop	r16
    1ffc:	08 95       	ret

00001ffe <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
    2002:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2004:	0e 94 77 03 	call	0x6ee	; 0x6ee <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2008:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <pucAlignedHeap.2081>
    200c:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <pucAlignedHeap.2081+0x1>
    2010:	89 2b       	or	r24, r25
    2012:	31 f4       	brne	.+12     	; 0x2020 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2014:	83 ed       	ldi	r24, 0xD3	; 211
    2016:	91 e0       	ldi	r25, 0x01	; 1
    2018:	90 93 cf 01 	sts	0x01CF, r25	; 0x8001cf <pucAlignedHeap.2081+0x1>
    201c:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2020:	20 91 d0 01 	lds	r18, 0x01D0	; 0x8001d0 <xNextFreeByte>
    2024:	30 91 d1 01 	lds	r19, 0x01D1	; 0x8001d1 <xNextFreeByte+0x1>
    2028:	c9 01       	movw	r24, r18
    202a:	8c 0f       	add	r24, r28
    202c:	9d 1f       	adc	r25, r29
    202e:	8b 3d       	cpi	r24, 0xDB	; 219
    2030:	45 e0       	ldi	r20, 0x05	; 5
    2032:	94 07       	cpc	r25, r20
    2034:	70 f4       	brcc	.+28     	; 0x2052 <pvPortMalloc+0x54>
    2036:	28 17       	cp	r18, r24
    2038:	39 07       	cpc	r19, r25
    203a:	58 f4       	brcc	.+22     	; 0x2052 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    203c:	c0 91 ce 01 	lds	r28, 0x01CE	; 0x8001ce <pucAlignedHeap.2081>
    2040:	d0 91 cf 01 	lds	r29, 0x01CF	; 0x8001cf <pucAlignedHeap.2081+0x1>
    2044:	c2 0f       	add	r28, r18
    2046:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2048:	90 93 d1 01 	sts	0x01D1, r25	; 0x8001d1 <xNextFreeByte+0x1>
    204c:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <xNextFreeByte>
    2050:	02 c0       	rjmp	.+4      	; 0x2056 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2052:	c0 e0       	ldi	r28, 0x00	; 0
    2054:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2056:	0e 94 43 04 	call	0x886	; 0x886 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    205a:	ce 01       	movw	r24, r28
    205c:	df 91       	pop	r29
    205e:	cf 91       	pop	r28
    2060:	08 95       	ret

00002062 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2062:	08 95       	ret

00002064 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2064:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <xNextFreeByte+0x1>
    2068:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <xNextFreeByte>
    206c:	08 95       	ret

0000206e <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    206e:	20 91 d0 01 	lds	r18, 0x01D0	; 0x8001d0 <xNextFreeByte>
    2072:	30 91 d1 01 	lds	r19, 0x01D1	; 0x8001d1 <xNextFreeByte+0x1>
}
    2076:	8b ed       	ldi	r24, 0xDB	; 219
    2078:	95 e0       	ldi	r25, 0x05	; 5
    207a:	82 1b       	sub	r24, r18
    207c:	93 0b       	sbc	r25, r19
    207e:	08 95       	ret

00002080 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2080:	31 e1       	ldi	r19, 0x11	; 17
    2082:	fc 01       	movw	r30, r24
    2084:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2086:	31 97       	sbiw	r30, 0x01	; 1
    2088:	22 e2       	ldi	r18, 0x22	; 34
    208a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    208c:	31 97       	sbiw	r30, 0x01	; 1
    208e:	a3 e3       	ldi	r26, 0x33	; 51
    2090:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2092:	31 97       	sbiw	r30, 0x01	; 1
    2094:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2096:	31 97       	sbiw	r30, 0x01	; 1
    2098:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    209a:	31 97       	sbiw	r30, 0x01	; 1
    209c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    209e:	31 97       	sbiw	r30, 0x01	; 1
    20a0:	60 e8       	ldi	r22, 0x80	; 128
    20a2:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    20a4:	31 97       	sbiw	r30, 0x01	; 1
    20a6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    20a8:	31 97       	sbiw	r30, 0x01	; 1
    20aa:	62 e0       	ldi	r22, 0x02	; 2
    20ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    20ae:	31 97       	sbiw	r30, 0x01	; 1
    20b0:	63 e0       	ldi	r22, 0x03	; 3
    20b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    20b4:	31 97       	sbiw	r30, 0x01	; 1
    20b6:	64 e0       	ldi	r22, 0x04	; 4
    20b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    20ba:	31 97       	sbiw	r30, 0x01	; 1
    20bc:	65 e0       	ldi	r22, 0x05	; 5
    20be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    20c0:	31 97       	sbiw	r30, 0x01	; 1
    20c2:	66 e0       	ldi	r22, 0x06	; 6
    20c4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    20c6:	31 97       	sbiw	r30, 0x01	; 1
    20c8:	67 e0       	ldi	r22, 0x07	; 7
    20ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    20cc:	31 97       	sbiw	r30, 0x01	; 1
    20ce:	68 e0       	ldi	r22, 0x08	; 8
    20d0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    20d2:	31 97       	sbiw	r30, 0x01	; 1
    20d4:	69 e0       	ldi	r22, 0x09	; 9
    20d6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    20d8:	31 97       	sbiw	r30, 0x01	; 1
    20da:	60 e1       	ldi	r22, 0x10	; 16
    20dc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    20de:	31 97       	sbiw	r30, 0x01	; 1
    20e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    20e2:	31 97       	sbiw	r30, 0x01	; 1
    20e4:	32 e1       	ldi	r19, 0x12	; 18
    20e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    20e8:	31 97       	sbiw	r30, 0x01	; 1
    20ea:	33 e1       	ldi	r19, 0x13	; 19
    20ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    20ee:	31 97       	sbiw	r30, 0x01	; 1
    20f0:	34 e1       	ldi	r19, 0x14	; 20
    20f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    20f4:	31 97       	sbiw	r30, 0x01	; 1
    20f6:	35 e1       	ldi	r19, 0x15	; 21
    20f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    20fa:	31 97       	sbiw	r30, 0x01	; 1
    20fc:	36 e1       	ldi	r19, 0x16	; 22
    20fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2100:	31 97       	sbiw	r30, 0x01	; 1
    2102:	37 e1       	ldi	r19, 0x17	; 23
    2104:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2106:	31 97       	sbiw	r30, 0x01	; 1
    2108:	38 e1       	ldi	r19, 0x18	; 24
    210a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    210c:	31 97       	sbiw	r30, 0x01	; 1
    210e:	39 e1       	ldi	r19, 0x19	; 25
    2110:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2112:	31 97       	sbiw	r30, 0x01	; 1
    2114:	30 e2       	ldi	r19, 0x20	; 32
    2116:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2118:	31 97       	sbiw	r30, 0x01	; 1
    211a:	31 e2       	ldi	r19, 0x21	; 33
    211c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    211e:	31 97       	sbiw	r30, 0x01	; 1
    2120:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2122:	31 97       	sbiw	r30, 0x01	; 1
    2124:	23 e2       	ldi	r18, 0x23	; 35
    2126:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2128:	31 97       	sbiw	r30, 0x01	; 1
    212a:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	26 e2       	ldi	r18, 0x26	; 38
    2134:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	27 e2       	ldi	r18, 0x27	; 39
    213a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	28 e2       	ldi	r18, 0x28	; 40
    2140:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	29 e2       	ldi	r18, 0x29	; 41
    2146:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	20 e3       	ldi	r18, 0x30	; 48
    214c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    214e:	31 97       	sbiw	r30, 0x01	; 1
    2150:	21 e3       	ldi	r18, 0x31	; 49
    2152:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2154:	86 97       	sbiw	r24, 0x26	; 38
    2156:	08 95       	ret

00002158 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2158:	89 ef       	ldi	r24, 0xF9	; 249
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    2160:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    2164:	e0 e8       	ldi	r30, 0x80	; 128
    2166:	f0 e0       	ldi	r31, 0x00	; 0
    2168:	80 81       	ld	r24, Z
    216a:	8c 7f       	andi	r24, 0xFC	; 252
    216c:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    216e:	8b e0       	ldi	r24, 0x0B	; 11
    2170:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2174:	ef e6       	ldi	r30, 0x6F	; 111
    2176:	f0 e0       	ldi	r31, 0x00	; 0
    2178:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    217a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    217c:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    217e:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    2182:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    2186:	cd 91       	ld	r28, X+
    2188:	cd bf       	out	0x3d, r28	; 61
    218a:	dd 91       	ld	r29, X+
    218c:	de bf       	out	0x3e, r29	; 62
    218e:	ff 91       	pop	r31
    2190:	ef 91       	pop	r30
    2192:	df 91       	pop	r29
    2194:	cf 91       	pop	r28
    2196:	bf 91       	pop	r27
    2198:	af 91       	pop	r26
    219a:	9f 91       	pop	r25
    219c:	8f 91       	pop	r24
    219e:	7f 91       	pop	r23
    21a0:	6f 91       	pop	r22
    21a2:	5f 91       	pop	r21
    21a4:	4f 91       	pop	r20
    21a6:	3f 91       	pop	r19
    21a8:	2f 91       	pop	r18
    21aa:	1f 91       	pop	r17
    21ac:	0f 91       	pop	r16
    21ae:	ff 90       	pop	r15
    21b0:	ef 90       	pop	r14
    21b2:	df 90       	pop	r13
    21b4:	cf 90       	pop	r12
    21b6:	bf 90       	pop	r11
    21b8:	af 90       	pop	r10
    21ba:	9f 90       	pop	r9
    21bc:	8f 90       	pop	r8
    21be:	7f 90       	pop	r7
    21c0:	6f 90       	pop	r6
    21c2:	5f 90       	pop	r5
    21c4:	4f 90       	pop	r4
    21c6:	3f 90       	pop	r3
    21c8:	2f 90       	pop	r2
    21ca:	1f 90       	pop	r1
    21cc:	0f 90       	pop	r0
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    21d2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	08 95       	ret

000021d8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    21d8:	08 95       	ret

000021da <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    21da:	0f 92       	push	r0
    21dc:	0f b6       	in	r0, 0x3f	; 63
    21de:	f8 94       	cli
    21e0:	0f 92       	push	r0
    21e2:	1f 92       	push	r1
    21e4:	11 24       	eor	r1, r1
    21e6:	2f 92       	push	r2
    21e8:	3f 92       	push	r3
    21ea:	4f 92       	push	r4
    21ec:	5f 92       	push	r5
    21ee:	6f 92       	push	r6
    21f0:	7f 92       	push	r7
    21f2:	8f 92       	push	r8
    21f4:	9f 92       	push	r9
    21f6:	af 92       	push	r10
    21f8:	bf 92       	push	r11
    21fa:	cf 92       	push	r12
    21fc:	df 92       	push	r13
    21fe:	ef 92       	push	r14
    2200:	ff 92       	push	r15
    2202:	0f 93       	push	r16
    2204:	1f 93       	push	r17
    2206:	2f 93       	push	r18
    2208:	3f 93       	push	r19
    220a:	4f 93       	push	r20
    220c:	5f 93       	push	r21
    220e:	6f 93       	push	r22
    2210:	7f 93       	push	r23
    2212:	8f 93       	push	r24
    2214:	9f 93       	push	r25
    2216:	af 93       	push	r26
    2218:	bf 93       	push	r27
    221a:	cf 93       	push	r28
    221c:	df 93       	push	r29
    221e:	ef 93       	push	r30
    2220:	ff 93       	push	r31
    2222:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    2226:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    222a:	0d b6       	in	r0, 0x3d	; 61
    222c:	0d 92       	st	X+, r0
    222e:	0e b6       	in	r0, 0x3e	; 62
    2230:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2232:	0e 94 ff 04 	call	0x9fe	; 0x9fe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2236:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    223a:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    223e:	cd 91       	ld	r28, X+
    2240:	cd bf       	out	0x3d, r28	; 61
    2242:	dd 91       	ld	r29, X+
    2244:	de bf       	out	0x3e, r29	; 62
    2246:	ff 91       	pop	r31
    2248:	ef 91       	pop	r30
    224a:	df 91       	pop	r29
    224c:	cf 91       	pop	r28
    224e:	bf 91       	pop	r27
    2250:	af 91       	pop	r26
    2252:	9f 91       	pop	r25
    2254:	8f 91       	pop	r24
    2256:	7f 91       	pop	r23
    2258:	6f 91       	pop	r22
    225a:	5f 91       	pop	r21
    225c:	4f 91       	pop	r20
    225e:	3f 91       	pop	r19
    2260:	2f 91       	pop	r18
    2262:	1f 91       	pop	r17
    2264:	0f 91       	pop	r16
    2266:	ff 90       	pop	r15
    2268:	ef 90       	pop	r14
    226a:	df 90       	pop	r13
    226c:	cf 90       	pop	r12
    226e:	bf 90       	pop	r11
    2270:	af 90       	pop	r10
    2272:	9f 90       	pop	r9
    2274:	8f 90       	pop	r8
    2276:	7f 90       	pop	r7
    2278:	6f 90       	pop	r6
    227a:	5f 90       	pop	r5
    227c:	4f 90       	pop	r4
    227e:	3f 90       	pop	r3
    2280:	2f 90       	pop	r2
    2282:	1f 90       	pop	r1
    2284:	0f 90       	pop	r0
    2286:	0f be       	out	0x3f, r0	; 63
    2288:	0f 90       	pop	r0

	asm volatile ( "ret" );
    228a:	08 95       	ret

0000228c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    228c:	0f 92       	push	r0
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	f8 94       	cli
    2292:	0f 92       	push	r0
    2294:	1f 92       	push	r1
    2296:	11 24       	eor	r1, r1
    2298:	2f 92       	push	r2
    229a:	3f 92       	push	r3
    229c:	4f 92       	push	r4
    229e:	5f 92       	push	r5
    22a0:	6f 92       	push	r6
    22a2:	7f 92       	push	r7
    22a4:	8f 92       	push	r8
    22a6:	9f 92       	push	r9
    22a8:	af 92       	push	r10
    22aa:	bf 92       	push	r11
    22ac:	cf 92       	push	r12
    22ae:	df 92       	push	r13
    22b0:	ef 92       	push	r14
    22b2:	ff 92       	push	r15
    22b4:	0f 93       	push	r16
    22b6:	1f 93       	push	r17
    22b8:	2f 93       	push	r18
    22ba:	3f 93       	push	r19
    22bc:	4f 93       	push	r20
    22be:	5f 93       	push	r21
    22c0:	6f 93       	push	r22
    22c2:	7f 93       	push	r23
    22c4:	8f 93       	push	r24
    22c6:	9f 93       	push	r25
    22c8:	af 93       	push	r26
    22ca:	bf 93       	push	r27
    22cc:	cf 93       	push	r28
    22ce:	df 93       	push	r29
    22d0:	ef 93       	push	r30
    22d2:	ff 93       	push	r31
    22d4:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    22d8:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    22dc:	0d b6       	in	r0, 0x3d	; 61
    22de:	0d 92       	st	X+, r0
    22e0:	0e b6       	in	r0, 0x3e	; 62
    22e2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    22e4:	0e 94 97 03 	call	0x72e	; 0x72e <xTaskIncrementTick>
    22e8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    22ea:	0e 94 ff 04 	call	0x9fe	; 0x9fe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    22ee:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <__data_end>
    22f2:	b0 91 2f 01 	lds	r27, 0x012F	; 0x80012f <__data_end+0x1>
    22f6:	cd 91       	ld	r28, X+
    22f8:	cd bf       	out	0x3d, r28	; 61
    22fa:	dd 91       	ld	r29, X+
    22fc:	de bf       	out	0x3e, r29	; 62
    22fe:	ff 91       	pop	r31
    2300:	ef 91       	pop	r30
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	bf 91       	pop	r27
    2308:	af 91       	pop	r26
    230a:	9f 91       	pop	r25
    230c:	8f 91       	pop	r24
    230e:	7f 91       	pop	r23
    2310:	6f 91       	pop	r22
    2312:	5f 91       	pop	r21
    2314:	4f 91       	pop	r20
    2316:	3f 91       	pop	r19
    2318:	2f 91       	pop	r18
    231a:	1f 91       	pop	r17
    231c:	0f 91       	pop	r16
    231e:	ff 90       	pop	r15
    2320:	ef 90       	pop	r14
    2322:	df 90       	pop	r13
    2324:	cf 90       	pop	r12
    2326:	bf 90       	pop	r11
    2328:	af 90       	pop	r10
    232a:	9f 90       	pop	r9
    232c:	8f 90       	pop	r8
    232e:	7f 90       	pop	r7
    2330:	6f 90       	pop	r6
    2332:	5f 90       	pop	r5
    2334:	4f 90       	pop	r4
    2336:	3f 90       	pop	r3
    2338:	2f 90       	pop	r2
    233a:	1f 90       	pop	r1
    233c:	0f 90       	pop	r0
    233e:	0f be       	out	0x3f, r0	; 63
    2340:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2342:	08 95       	ret

00002344 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2344:	0e 94 46 11 	call	0x228c	; 0x228c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2348:	18 95       	reti

0000234a <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
}

int uart_transmit(char c, FILE *stream) {
    234a:	cf 93       	push	r28
    234c:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
    234e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    2352:	85 fd       	sbrc	r24, 5
    2354:	03 c0       	rjmp	.+6      	; 0x235c <uart_transmit+0x12>
    2356:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    235a:	f9 cf       	rjmp	.-14     	; 0x234e <uart_transmit+0x4>
  UDR0 = c;
    235c:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
  return 0;
}
    2360:	80 e0       	ldi	r24, 0x00	; 0
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	cf 91       	pop	r28
    2366:	08 95       	ret

00002368 <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
    2368:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    236c:	87 fd       	sbrc	r24, 7
    236e:	03 c0       	rjmp	.+6      	; 0x2376 <uart_receive+0xe>
    2370:	0e 94 ed 10 	call	0x21da	; 0x21da <vPortYield>
    2374:	f9 cf       	rjmp	.-14     	; 0x2368 <uart_receive>
  return UDR0;
    2376:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}
    237a:	90 e0       	ldi	r25, 0x00	; 0
    237c:	08 95       	ret

0000237e <uart_init>:
    237e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    2382:	87 e6       	ldi	r24, 0x67	; 103
    2384:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    2388:	e0 ec       	ldi	r30, 0xC0	; 192
    238a:	f0 e0       	ldi	r31, 0x00	; 0
    238c:	80 81       	ld	r24, Z
    238e:	8d 7f       	andi	r24, 0xFD	; 253
    2390:	80 83       	st	Z, r24
    2392:	86 e0       	ldi	r24, 0x06	; 6
    2394:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
    2398:	88 e1       	ldi	r24, 0x18	; 24
    239a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    239e:	08 95       	ret

000023a0 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    23a0:	cf 92       	push	r12
    23a2:	df 92       	push	r13
    23a4:	ef 92       	push	r14
    23a6:	ff 92       	push	r15
    23a8:	0f 93       	push	r16
    23aa:	cf 93       	push	r28
    23ac:	df 93       	push	r29
    23ae:	00 d0       	rcall	.+0      	; 0x23b0 <main+0x10>
    23b0:	00 d0       	rcall	.+0      	; 0x23b2 <main+0x12>
    23b2:	cd b7       	in	r28, 0x3d	; 61
    23b4:	de b7       	in	r29, 0x3e	; 62
	// Create task.
	xTaskHandle blink_handle;
	xTaskHandle serial_handle;

	QueueHandle_t xQueue = xQueueCreate(100, sizeof(uint16_t));
    23b6:	40 e0       	ldi	r20, 0x00	; 0
    23b8:	62 e0       	ldi	r22, 0x02	; 2
    23ba:	84 e6       	ldi	r24, 0x64	; 100
    23bc:	0e 94 a8 09 	call	0x1350	; 0x1350 <xQueueGenericCreate>
    23c0:	6c 01       	movw	r12, r24

	xTaskCreate
    23c2:	ce 01       	movw	r24, r28
    23c4:	03 96       	adiw	r24, 0x03	; 3
    23c6:	7c 01       	movw	r14, r24
    23c8:	02 e0       	ldi	r16, 0x02	; 2
    23ca:	96 01       	movw	r18, r12
    23cc:	45 e5       	ldi	r20, 0x55	; 85
    23ce:	50 e0       	ldi	r21, 0x00	; 0
    23d0:	6b e1       	ldi	r22, 0x1B	; 27
    23d2:	71 e0       	ldi	r23, 0x01	; 1
    23d4:	82 e9       	ldi	r24, 0x92	; 146
    23d6:	90 e0       	ldi	r25, 0x00	; 0
    23d8:	0e 94 63 01 	call	0x2c6	; 0x2c6 <xTaskCreate>
		 (void *)xQueue,
		 mainLED_TASK_PRIORITY,
		 &blink_handle
		);

	xTaskCreate
    23dc:	ce 01       	movw	r24, r28
    23de:	01 96       	adiw	r24, 0x01	; 1
    23e0:	7c 01       	movw	r14, r24
    23e2:	01 e0       	ldi	r16, 0x01	; 1
    23e4:	96 01       	movw	r18, r12
    23e6:	45 e5       	ldi	r20, 0x55	; 85
    23e8:	50 e0       	ldi	r21, 0x00	; 0
    23ea:	61 e2       	ldi	r22, 0x21	; 33
    23ec:	71 e0       	ldi	r23, 0x01	; 1
    23ee:	83 e5       	ldi	r24, 0x53	; 83
    23f0:	90 e0       	ldi	r25, 0x00	; 0
    23f2:	0e 94 63 01 	call	0x2c6	; 0x2c6 <xTaskCreate>
		 mainSERIAL_TASK_PRIORITY,
		 &serial_handle
		);

	// Start scheduler.
	vTaskStartScheduler();
    23f6:	0e 94 48 03 	call	0x690	; 0x690 <vTaskStartScheduler>

	return 0;
}
    23fa:	80 e0       	ldi	r24, 0x00	; 0
    23fc:	90 e0       	ldi	r25, 0x00	; 0
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	0f 90       	pop	r0
    2406:	df 91       	pop	r29
    2408:	cf 91       	pop	r28
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	ef 90       	pop	r14
    2410:	df 90       	pop	r13
    2412:	cf 90       	pop	r12
    2414:	08 95       	ret

00002416 <memcpy>:
    2416:	fb 01       	movw	r30, r22
    2418:	dc 01       	movw	r26, r24
    241a:	02 c0       	rjmp	.+4      	; 0x2420 <memcpy+0xa>
    241c:	01 90       	ld	r0, Z+
    241e:	0d 92       	st	X+, r0
    2420:	41 50       	subi	r20, 0x01	; 1
    2422:	50 40       	sbci	r21, 0x00	; 0
    2424:	d8 f7       	brcc	.-10     	; 0x241c <memcpy+0x6>
    2426:	08 95       	ret

00002428 <fgetc>:
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
    242c:	ec 01       	movw	r28, r24
    242e:	2b 81       	ldd	r18, Y+3	; 0x03
    2430:	20 ff       	sbrs	r18, 0
    2432:	33 c0       	rjmp	.+102    	; 0x249a <fgetc+0x72>
    2434:	26 ff       	sbrs	r18, 6
    2436:	0a c0       	rjmp	.+20     	; 0x244c <fgetc+0x24>
    2438:	2f 7b       	andi	r18, 0xBF	; 191
    243a:	2b 83       	std	Y+3, r18	; 0x03
    243c:	8e 81       	ldd	r24, Y+6	; 0x06
    243e:	9f 81       	ldd	r25, Y+7	; 0x07
    2440:	01 96       	adiw	r24, 0x01	; 1
    2442:	9f 83       	std	Y+7, r25	; 0x07
    2444:	8e 83       	std	Y+6, r24	; 0x06
    2446:	8a 81       	ldd	r24, Y+2	; 0x02
    2448:	90 e0       	ldi	r25, 0x00	; 0
    244a:	29 c0       	rjmp	.+82     	; 0x249e <fgetc+0x76>
    244c:	22 ff       	sbrs	r18, 2
    244e:	0f c0       	rjmp	.+30     	; 0x246e <fgetc+0x46>
    2450:	e8 81       	ld	r30, Y
    2452:	f9 81       	ldd	r31, Y+1	; 0x01
    2454:	80 81       	ld	r24, Z
    2456:	08 2e       	mov	r0, r24
    2458:	00 0c       	add	r0, r0
    245a:	99 0b       	sbc	r25, r25
    245c:	00 97       	sbiw	r24, 0x00	; 0
    245e:	19 f4       	brne	.+6      	; 0x2466 <fgetc+0x3e>
    2460:	20 62       	ori	r18, 0x20	; 32
    2462:	2b 83       	std	Y+3, r18	; 0x03
    2464:	1a c0       	rjmp	.+52     	; 0x249a <fgetc+0x72>
    2466:	31 96       	adiw	r30, 0x01	; 1
    2468:	f9 83       	std	Y+1, r31	; 0x01
    246a:	e8 83       	st	Y, r30
    246c:	0e c0       	rjmp	.+28     	; 0x248a <fgetc+0x62>
    246e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2470:	fb 85       	ldd	r31, Y+11	; 0x0b
    2472:	09 95       	icall
    2474:	97 ff       	sbrs	r25, 7
    2476:	09 c0       	rjmp	.+18     	; 0x248a <fgetc+0x62>
    2478:	2b 81       	ldd	r18, Y+3	; 0x03
    247a:	01 96       	adiw	r24, 0x01	; 1
    247c:	11 f0       	breq	.+4      	; 0x2482 <fgetc+0x5a>
    247e:	80 e2       	ldi	r24, 0x20	; 32
    2480:	01 c0       	rjmp	.+2      	; 0x2484 <fgetc+0x5c>
    2482:	80 e1       	ldi	r24, 0x10	; 16
    2484:	82 2b       	or	r24, r18
    2486:	8b 83       	std	Y+3, r24	; 0x03
    2488:	08 c0       	rjmp	.+16     	; 0x249a <fgetc+0x72>
    248a:	2e 81       	ldd	r18, Y+6	; 0x06
    248c:	3f 81       	ldd	r19, Y+7	; 0x07
    248e:	2f 5f       	subi	r18, 0xFF	; 255
    2490:	3f 4f       	sbci	r19, 0xFF	; 255
    2492:	3f 83       	std	Y+7, r19	; 0x07
    2494:	2e 83       	std	Y+6, r18	; 0x06
    2496:	99 27       	eor	r25, r25
    2498:	02 c0       	rjmp	.+4      	; 0x249e <fgetc+0x76>
    249a:	8f ef       	ldi	r24, 0xFF	; 255
    249c:	9f ef       	ldi	r25, 0xFF	; 255
    249e:	df 91       	pop	r29
    24a0:	cf 91       	pop	r28
    24a2:	08 95       	ret

000024a4 <printf>:
    24a4:	a0 e0       	ldi	r26, 0x00	; 0
    24a6:	b0 e0       	ldi	r27, 0x00	; 0
    24a8:	e8 e5       	ldi	r30, 0x58	; 88
    24aa:	f2 e1       	ldi	r31, 0x12	; 18
    24ac:	0c 94 09 15 	jmp	0x2a12	; 0x2a12 <__prologue_saves__+0x20>
    24b0:	ae 01       	movw	r20, r28
    24b2:	4b 5f       	subi	r20, 0xFB	; 251
    24b4:	5f 4f       	sbci	r21, 0xFF	; 255
    24b6:	fa 01       	movw	r30, r20
    24b8:	61 91       	ld	r22, Z+
    24ba:	71 91       	ld	r23, Z+
    24bc:	af 01       	movw	r20, r30
    24be:	80 91 b0 07 	lds	r24, 0x07B0	; 0x8007b0 <__iob+0x2>
    24c2:	90 91 b1 07 	lds	r25, 0x07B1	; 0x8007b1 <__iob+0x3>
    24c6:	0e 94 68 12 	call	0x24d0	; 0x24d0 <vfprintf>
    24ca:	e2 e0       	ldi	r30, 0x02	; 2
    24cc:	0c 94 25 15 	jmp	0x2a4a	; 0x2a4a <__epilogue_restores__+0x20>

000024d0 <vfprintf>:
    24d0:	ab e0       	ldi	r26, 0x0B	; 11
    24d2:	b0 e0       	ldi	r27, 0x00	; 0
    24d4:	ee e6       	ldi	r30, 0x6E	; 110
    24d6:	f2 e1       	ldi	r31, 0x12	; 18
    24d8:	0c 94 f9 14 	jmp	0x29f2	; 0x29f2 <__prologue_saves__>
    24dc:	6c 01       	movw	r12, r24
    24de:	7b 01       	movw	r14, r22
    24e0:	8a 01       	movw	r16, r20
    24e2:	fc 01       	movw	r30, r24
    24e4:	17 82       	std	Z+7, r1	; 0x07
    24e6:	16 82       	std	Z+6, r1	; 0x06
    24e8:	83 81       	ldd	r24, Z+3	; 0x03
    24ea:	81 ff       	sbrs	r24, 1
    24ec:	cc c1       	rjmp	.+920    	; 0x2886 <vfprintf+0x3b6>
    24ee:	ce 01       	movw	r24, r28
    24f0:	01 96       	adiw	r24, 0x01	; 1
    24f2:	3c 01       	movw	r6, r24
    24f4:	f6 01       	movw	r30, r12
    24f6:	93 81       	ldd	r25, Z+3	; 0x03
    24f8:	f7 01       	movw	r30, r14
    24fa:	93 fd       	sbrc	r25, 3
    24fc:	85 91       	lpm	r24, Z+
    24fe:	93 ff       	sbrs	r25, 3
    2500:	81 91       	ld	r24, Z+
    2502:	7f 01       	movw	r14, r30
    2504:	88 23       	and	r24, r24
    2506:	09 f4       	brne	.+2      	; 0x250a <vfprintf+0x3a>
    2508:	ba c1       	rjmp	.+884    	; 0x287e <vfprintf+0x3ae>
    250a:	85 32       	cpi	r24, 0x25	; 37
    250c:	39 f4       	brne	.+14     	; 0x251c <vfprintf+0x4c>
    250e:	93 fd       	sbrc	r25, 3
    2510:	85 91       	lpm	r24, Z+
    2512:	93 ff       	sbrs	r25, 3
    2514:	81 91       	ld	r24, Z+
    2516:	7f 01       	movw	r14, r30
    2518:	85 32       	cpi	r24, 0x25	; 37
    251a:	29 f4       	brne	.+10     	; 0x2526 <vfprintf+0x56>
    251c:	b6 01       	movw	r22, r12
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2524:	e7 cf       	rjmp	.-50     	; 0x24f4 <vfprintf+0x24>
    2526:	91 2c       	mov	r9, r1
    2528:	21 2c       	mov	r2, r1
    252a:	31 2c       	mov	r3, r1
    252c:	ff e1       	ldi	r31, 0x1F	; 31
    252e:	f3 15       	cp	r31, r3
    2530:	d8 f0       	brcs	.+54     	; 0x2568 <vfprintf+0x98>
    2532:	8b 32       	cpi	r24, 0x2B	; 43
    2534:	79 f0       	breq	.+30     	; 0x2554 <vfprintf+0x84>
    2536:	38 f4       	brcc	.+14     	; 0x2546 <vfprintf+0x76>
    2538:	80 32       	cpi	r24, 0x20	; 32
    253a:	79 f0       	breq	.+30     	; 0x255a <vfprintf+0x8a>
    253c:	83 32       	cpi	r24, 0x23	; 35
    253e:	a1 f4       	brne	.+40     	; 0x2568 <vfprintf+0x98>
    2540:	23 2d       	mov	r18, r3
    2542:	20 61       	ori	r18, 0x10	; 16
    2544:	1d c0       	rjmp	.+58     	; 0x2580 <vfprintf+0xb0>
    2546:	8d 32       	cpi	r24, 0x2D	; 45
    2548:	61 f0       	breq	.+24     	; 0x2562 <vfprintf+0x92>
    254a:	80 33       	cpi	r24, 0x30	; 48
    254c:	69 f4       	brne	.+26     	; 0x2568 <vfprintf+0x98>
    254e:	23 2d       	mov	r18, r3
    2550:	21 60       	ori	r18, 0x01	; 1
    2552:	16 c0       	rjmp	.+44     	; 0x2580 <vfprintf+0xb0>
    2554:	83 2d       	mov	r24, r3
    2556:	82 60       	ori	r24, 0x02	; 2
    2558:	38 2e       	mov	r3, r24
    255a:	e3 2d       	mov	r30, r3
    255c:	e4 60       	ori	r30, 0x04	; 4
    255e:	3e 2e       	mov	r3, r30
    2560:	2a c0       	rjmp	.+84     	; 0x25b6 <vfprintf+0xe6>
    2562:	f3 2d       	mov	r31, r3
    2564:	f8 60       	ori	r31, 0x08	; 8
    2566:	1d c0       	rjmp	.+58     	; 0x25a2 <vfprintf+0xd2>
    2568:	37 fc       	sbrc	r3, 7
    256a:	2d c0       	rjmp	.+90     	; 0x25c6 <vfprintf+0xf6>
    256c:	20 ed       	ldi	r18, 0xD0	; 208
    256e:	28 0f       	add	r18, r24
    2570:	2a 30       	cpi	r18, 0x0A	; 10
    2572:	40 f0       	brcs	.+16     	; 0x2584 <vfprintf+0xb4>
    2574:	8e 32       	cpi	r24, 0x2E	; 46
    2576:	b9 f4       	brne	.+46     	; 0x25a6 <vfprintf+0xd6>
    2578:	36 fc       	sbrc	r3, 6
    257a:	81 c1       	rjmp	.+770    	; 0x287e <vfprintf+0x3ae>
    257c:	23 2d       	mov	r18, r3
    257e:	20 64       	ori	r18, 0x40	; 64
    2580:	32 2e       	mov	r3, r18
    2582:	19 c0       	rjmp	.+50     	; 0x25b6 <vfprintf+0xe6>
    2584:	36 fe       	sbrs	r3, 6
    2586:	06 c0       	rjmp	.+12     	; 0x2594 <vfprintf+0xc4>
    2588:	8a e0       	ldi	r24, 0x0A	; 10
    258a:	98 9e       	mul	r9, r24
    258c:	20 0d       	add	r18, r0
    258e:	11 24       	eor	r1, r1
    2590:	92 2e       	mov	r9, r18
    2592:	11 c0       	rjmp	.+34     	; 0x25b6 <vfprintf+0xe6>
    2594:	ea e0       	ldi	r30, 0x0A	; 10
    2596:	2e 9e       	mul	r2, r30
    2598:	20 0d       	add	r18, r0
    259a:	11 24       	eor	r1, r1
    259c:	22 2e       	mov	r2, r18
    259e:	f3 2d       	mov	r31, r3
    25a0:	f0 62       	ori	r31, 0x20	; 32
    25a2:	3f 2e       	mov	r3, r31
    25a4:	08 c0       	rjmp	.+16     	; 0x25b6 <vfprintf+0xe6>
    25a6:	8c 36       	cpi	r24, 0x6C	; 108
    25a8:	21 f4       	brne	.+8      	; 0x25b2 <vfprintf+0xe2>
    25aa:	83 2d       	mov	r24, r3
    25ac:	80 68       	ori	r24, 0x80	; 128
    25ae:	38 2e       	mov	r3, r24
    25b0:	02 c0       	rjmp	.+4      	; 0x25b6 <vfprintf+0xe6>
    25b2:	88 36       	cpi	r24, 0x68	; 104
    25b4:	41 f4       	brne	.+16     	; 0x25c6 <vfprintf+0xf6>
    25b6:	f7 01       	movw	r30, r14
    25b8:	93 fd       	sbrc	r25, 3
    25ba:	85 91       	lpm	r24, Z+
    25bc:	93 ff       	sbrs	r25, 3
    25be:	81 91       	ld	r24, Z+
    25c0:	7f 01       	movw	r14, r30
    25c2:	81 11       	cpse	r24, r1
    25c4:	b3 cf       	rjmp	.-154    	; 0x252c <vfprintf+0x5c>
    25c6:	98 2f       	mov	r25, r24
    25c8:	9f 7d       	andi	r25, 0xDF	; 223
    25ca:	95 54       	subi	r25, 0x45	; 69
    25cc:	93 30       	cpi	r25, 0x03	; 3
    25ce:	28 f4       	brcc	.+10     	; 0x25da <vfprintf+0x10a>
    25d0:	0c 5f       	subi	r16, 0xFC	; 252
    25d2:	1f 4f       	sbci	r17, 0xFF	; 255
    25d4:	9f e3       	ldi	r25, 0x3F	; 63
    25d6:	99 83       	std	Y+1, r25	; 0x01
    25d8:	0d c0       	rjmp	.+26     	; 0x25f4 <vfprintf+0x124>
    25da:	83 36       	cpi	r24, 0x63	; 99
    25dc:	31 f0       	breq	.+12     	; 0x25ea <vfprintf+0x11a>
    25de:	83 37       	cpi	r24, 0x73	; 115
    25e0:	71 f0       	breq	.+28     	; 0x25fe <vfprintf+0x12e>
    25e2:	83 35       	cpi	r24, 0x53	; 83
    25e4:	09 f0       	breq	.+2      	; 0x25e8 <vfprintf+0x118>
    25e6:	59 c0       	rjmp	.+178    	; 0x269a <vfprintf+0x1ca>
    25e8:	21 c0       	rjmp	.+66     	; 0x262c <vfprintf+0x15c>
    25ea:	f8 01       	movw	r30, r16
    25ec:	80 81       	ld	r24, Z
    25ee:	89 83       	std	Y+1, r24	; 0x01
    25f0:	0e 5f       	subi	r16, 0xFE	; 254
    25f2:	1f 4f       	sbci	r17, 0xFF	; 255
    25f4:	88 24       	eor	r8, r8
    25f6:	83 94       	inc	r8
    25f8:	91 2c       	mov	r9, r1
    25fa:	53 01       	movw	r10, r6
    25fc:	13 c0       	rjmp	.+38     	; 0x2624 <vfprintf+0x154>
    25fe:	28 01       	movw	r4, r16
    2600:	f2 e0       	ldi	r31, 0x02	; 2
    2602:	4f 0e       	add	r4, r31
    2604:	51 1c       	adc	r5, r1
    2606:	f8 01       	movw	r30, r16
    2608:	a0 80       	ld	r10, Z
    260a:	b1 80       	ldd	r11, Z+1	; 0x01
    260c:	36 fe       	sbrs	r3, 6
    260e:	03 c0       	rjmp	.+6      	; 0x2616 <vfprintf+0x146>
    2610:	69 2d       	mov	r22, r9
    2612:	70 e0       	ldi	r23, 0x00	; 0
    2614:	02 c0       	rjmp	.+4      	; 0x261a <vfprintf+0x14a>
    2616:	6f ef       	ldi	r22, 0xFF	; 255
    2618:	7f ef       	ldi	r23, 0xFF	; 255
    261a:	c5 01       	movw	r24, r10
    261c:	0e 94 54 14 	call	0x28a8	; 0x28a8 <strnlen>
    2620:	4c 01       	movw	r8, r24
    2622:	82 01       	movw	r16, r4
    2624:	f3 2d       	mov	r31, r3
    2626:	ff 77       	andi	r31, 0x7F	; 127
    2628:	3f 2e       	mov	r3, r31
    262a:	16 c0       	rjmp	.+44     	; 0x2658 <vfprintf+0x188>
    262c:	28 01       	movw	r4, r16
    262e:	22 e0       	ldi	r18, 0x02	; 2
    2630:	42 0e       	add	r4, r18
    2632:	51 1c       	adc	r5, r1
    2634:	f8 01       	movw	r30, r16
    2636:	a0 80       	ld	r10, Z
    2638:	b1 80       	ldd	r11, Z+1	; 0x01
    263a:	36 fe       	sbrs	r3, 6
    263c:	03 c0       	rjmp	.+6      	; 0x2644 <vfprintf+0x174>
    263e:	69 2d       	mov	r22, r9
    2640:	70 e0       	ldi	r23, 0x00	; 0
    2642:	02 c0       	rjmp	.+4      	; 0x2648 <vfprintf+0x178>
    2644:	6f ef       	ldi	r22, 0xFF	; 255
    2646:	7f ef       	ldi	r23, 0xFF	; 255
    2648:	c5 01       	movw	r24, r10
    264a:	0e 94 49 14 	call	0x2892	; 0x2892 <strnlen_P>
    264e:	4c 01       	movw	r8, r24
    2650:	f3 2d       	mov	r31, r3
    2652:	f0 68       	ori	r31, 0x80	; 128
    2654:	3f 2e       	mov	r3, r31
    2656:	82 01       	movw	r16, r4
    2658:	33 fc       	sbrc	r3, 3
    265a:	1b c0       	rjmp	.+54     	; 0x2692 <vfprintf+0x1c2>
    265c:	82 2d       	mov	r24, r2
    265e:	90 e0       	ldi	r25, 0x00	; 0
    2660:	88 16       	cp	r8, r24
    2662:	99 06       	cpc	r9, r25
    2664:	b0 f4       	brcc	.+44     	; 0x2692 <vfprintf+0x1c2>
    2666:	b6 01       	movw	r22, r12
    2668:	80 e2       	ldi	r24, 0x20	; 32
    266a:	90 e0       	ldi	r25, 0x00	; 0
    266c:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2670:	2a 94       	dec	r2
    2672:	f4 cf       	rjmp	.-24     	; 0x265c <vfprintf+0x18c>
    2674:	f5 01       	movw	r30, r10
    2676:	37 fc       	sbrc	r3, 7
    2678:	85 91       	lpm	r24, Z+
    267a:	37 fe       	sbrs	r3, 7
    267c:	81 91       	ld	r24, Z+
    267e:	5f 01       	movw	r10, r30
    2680:	b6 01       	movw	r22, r12
    2682:	90 e0       	ldi	r25, 0x00	; 0
    2684:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2688:	21 10       	cpse	r2, r1
    268a:	2a 94       	dec	r2
    268c:	21 e0       	ldi	r18, 0x01	; 1
    268e:	82 1a       	sub	r8, r18
    2690:	91 08       	sbc	r9, r1
    2692:	81 14       	cp	r8, r1
    2694:	91 04       	cpc	r9, r1
    2696:	71 f7       	brne	.-36     	; 0x2674 <vfprintf+0x1a4>
    2698:	e8 c0       	rjmp	.+464    	; 0x286a <vfprintf+0x39a>
    269a:	84 36       	cpi	r24, 0x64	; 100
    269c:	11 f0       	breq	.+4      	; 0x26a2 <vfprintf+0x1d2>
    269e:	89 36       	cpi	r24, 0x69	; 105
    26a0:	41 f5       	brne	.+80     	; 0x26f2 <vfprintf+0x222>
    26a2:	f8 01       	movw	r30, r16
    26a4:	37 fe       	sbrs	r3, 7
    26a6:	07 c0       	rjmp	.+14     	; 0x26b6 <vfprintf+0x1e6>
    26a8:	60 81       	ld	r22, Z
    26aa:	71 81       	ldd	r23, Z+1	; 0x01
    26ac:	82 81       	ldd	r24, Z+2	; 0x02
    26ae:	93 81       	ldd	r25, Z+3	; 0x03
    26b0:	0c 5f       	subi	r16, 0xFC	; 252
    26b2:	1f 4f       	sbci	r17, 0xFF	; 255
    26b4:	08 c0       	rjmp	.+16     	; 0x26c6 <vfprintf+0x1f6>
    26b6:	60 81       	ld	r22, Z
    26b8:	71 81       	ldd	r23, Z+1	; 0x01
    26ba:	07 2e       	mov	r0, r23
    26bc:	00 0c       	add	r0, r0
    26be:	88 0b       	sbc	r24, r24
    26c0:	99 0b       	sbc	r25, r25
    26c2:	0e 5f       	subi	r16, 0xFE	; 254
    26c4:	1f 4f       	sbci	r17, 0xFF	; 255
    26c6:	f3 2d       	mov	r31, r3
    26c8:	ff 76       	andi	r31, 0x6F	; 111
    26ca:	3f 2e       	mov	r3, r31
    26cc:	97 ff       	sbrs	r25, 7
    26ce:	09 c0       	rjmp	.+18     	; 0x26e2 <vfprintf+0x212>
    26d0:	90 95       	com	r25
    26d2:	80 95       	com	r24
    26d4:	70 95       	com	r23
    26d6:	61 95       	neg	r22
    26d8:	7f 4f       	sbci	r23, 0xFF	; 255
    26da:	8f 4f       	sbci	r24, 0xFF	; 255
    26dc:	9f 4f       	sbci	r25, 0xFF	; 255
    26de:	f0 68       	ori	r31, 0x80	; 128
    26e0:	3f 2e       	mov	r3, r31
    26e2:	2a e0       	ldi	r18, 0x0A	; 10
    26e4:	30 e0       	ldi	r19, 0x00	; 0
    26e6:	a3 01       	movw	r20, r6
    26e8:	0e 94 9b 14 	call	0x2936	; 0x2936 <__ultoa_invert>
    26ec:	88 2e       	mov	r8, r24
    26ee:	86 18       	sub	r8, r6
    26f0:	45 c0       	rjmp	.+138    	; 0x277c <vfprintf+0x2ac>
    26f2:	85 37       	cpi	r24, 0x75	; 117
    26f4:	31 f4       	brne	.+12     	; 0x2702 <vfprintf+0x232>
    26f6:	23 2d       	mov	r18, r3
    26f8:	2f 7e       	andi	r18, 0xEF	; 239
    26fa:	b2 2e       	mov	r11, r18
    26fc:	2a e0       	ldi	r18, 0x0A	; 10
    26fe:	30 e0       	ldi	r19, 0x00	; 0
    2700:	25 c0       	rjmp	.+74     	; 0x274c <vfprintf+0x27c>
    2702:	93 2d       	mov	r25, r3
    2704:	99 7f       	andi	r25, 0xF9	; 249
    2706:	b9 2e       	mov	r11, r25
    2708:	8f 36       	cpi	r24, 0x6F	; 111
    270a:	c1 f0       	breq	.+48     	; 0x273c <vfprintf+0x26c>
    270c:	18 f4       	brcc	.+6      	; 0x2714 <vfprintf+0x244>
    270e:	88 35       	cpi	r24, 0x58	; 88
    2710:	79 f0       	breq	.+30     	; 0x2730 <vfprintf+0x260>
    2712:	b5 c0       	rjmp	.+362    	; 0x287e <vfprintf+0x3ae>
    2714:	80 37       	cpi	r24, 0x70	; 112
    2716:	19 f0       	breq	.+6      	; 0x271e <vfprintf+0x24e>
    2718:	88 37       	cpi	r24, 0x78	; 120
    271a:	21 f0       	breq	.+8      	; 0x2724 <vfprintf+0x254>
    271c:	b0 c0       	rjmp	.+352    	; 0x287e <vfprintf+0x3ae>
    271e:	e9 2f       	mov	r30, r25
    2720:	e0 61       	ori	r30, 0x10	; 16
    2722:	be 2e       	mov	r11, r30
    2724:	b4 fe       	sbrs	r11, 4
    2726:	0d c0       	rjmp	.+26     	; 0x2742 <vfprintf+0x272>
    2728:	fb 2d       	mov	r31, r11
    272a:	f4 60       	ori	r31, 0x04	; 4
    272c:	bf 2e       	mov	r11, r31
    272e:	09 c0       	rjmp	.+18     	; 0x2742 <vfprintf+0x272>
    2730:	34 fe       	sbrs	r3, 4
    2732:	0a c0       	rjmp	.+20     	; 0x2748 <vfprintf+0x278>
    2734:	29 2f       	mov	r18, r25
    2736:	26 60       	ori	r18, 0x06	; 6
    2738:	b2 2e       	mov	r11, r18
    273a:	06 c0       	rjmp	.+12     	; 0x2748 <vfprintf+0x278>
    273c:	28 e0       	ldi	r18, 0x08	; 8
    273e:	30 e0       	ldi	r19, 0x00	; 0
    2740:	05 c0       	rjmp	.+10     	; 0x274c <vfprintf+0x27c>
    2742:	20 e1       	ldi	r18, 0x10	; 16
    2744:	30 e0       	ldi	r19, 0x00	; 0
    2746:	02 c0       	rjmp	.+4      	; 0x274c <vfprintf+0x27c>
    2748:	20 e1       	ldi	r18, 0x10	; 16
    274a:	32 e0       	ldi	r19, 0x02	; 2
    274c:	f8 01       	movw	r30, r16
    274e:	b7 fe       	sbrs	r11, 7
    2750:	07 c0       	rjmp	.+14     	; 0x2760 <vfprintf+0x290>
    2752:	60 81       	ld	r22, Z
    2754:	71 81       	ldd	r23, Z+1	; 0x01
    2756:	82 81       	ldd	r24, Z+2	; 0x02
    2758:	93 81       	ldd	r25, Z+3	; 0x03
    275a:	0c 5f       	subi	r16, 0xFC	; 252
    275c:	1f 4f       	sbci	r17, 0xFF	; 255
    275e:	06 c0       	rjmp	.+12     	; 0x276c <vfprintf+0x29c>
    2760:	60 81       	ld	r22, Z
    2762:	71 81       	ldd	r23, Z+1	; 0x01
    2764:	80 e0       	ldi	r24, 0x00	; 0
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	0e 5f       	subi	r16, 0xFE	; 254
    276a:	1f 4f       	sbci	r17, 0xFF	; 255
    276c:	a3 01       	movw	r20, r6
    276e:	0e 94 9b 14 	call	0x2936	; 0x2936 <__ultoa_invert>
    2772:	88 2e       	mov	r8, r24
    2774:	86 18       	sub	r8, r6
    2776:	fb 2d       	mov	r31, r11
    2778:	ff 77       	andi	r31, 0x7F	; 127
    277a:	3f 2e       	mov	r3, r31
    277c:	36 fe       	sbrs	r3, 6
    277e:	0d c0       	rjmp	.+26     	; 0x279a <vfprintf+0x2ca>
    2780:	23 2d       	mov	r18, r3
    2782:	2e 7f       	andi	r18, 0xFE	; 254
    2784:	a2 2e       	mov	r10, r18
    2786:	89 14       	cp	r8, r9
    2788:	58 f4       	brcc	.+22     	; 0x27a0 <vfprintf+0x2d0>
    278a:	34 fe       	sbrs	r3, 4
    278c:	0b c0       	rjmp	.+22     	; 0x27a4 <vfprintf+0x2d4>
    278e:	32 fc       	sbrc	r3, 2
    2790:	09 c0       	rjmp	.+18     	; 0x27a4 <vfprintf+0x2d4>
    2792:	83 2d       	mov	r24, r3
    2794:	8e 7e       	andi	r24, 0xEE	; 238
    2796:	a8 2e       	mov	r10, r24
    2798:	05 c0       	rjmp	.+10     	; 0x27a4 <vfprintf+0x2d4>
    279a:	b8 2c       	mov	r11, r8
    279c:	a3 2c       	mov	r10, r3
    279e:	03 c0       	rjmp	.+6      	; 0x27a6 <vfprintf+0x2d6>
    27a0:	b8 2c       	mov	r11, r8
    27a2:	01 c0       	rjmp	.+2      	; 0x27a6 <vfprintf+0x2d6>
    27a4:	b9 2c       	mov	r11, r9
    27a6:	a4 fe       	sbrs	r10, 4
    27a8:	0f c0       	rjmp	.+30     	; 0x27c8 <vfprintf+0x2f8>
    27aa:	fe 01       	movw	r30, r28
    27ac:	e8 0d       	add	r30, r8
    27ae:	f1 1d       	adc	r31, r1
    27b0:	80 81       	ld	r24, Z
    27b2:	80 33       	cpi	r24, 0x30	; 48
    27b4:	21 f4       	brne	.+8      	; 0x27be <vfprintf+0x2ee>
    27b6:	9a 2d       	mov	r25, r10
    27b8:	99 7e       	andi	r25, 0xE9	; 233
    27ba:	a9 2e       	mov	r10, r25
    27bc:	09 c0       	rjmp	.+18     	; 0x27d0 <vfprintf+0x300>
    27be:	a2 fe       	sbrs	r10, 2
    27c0:	06 c0       	rjmp	.+12     	; 0x27ce <vfprintf+0x2fe>
    27c2:	b3 94       	inc	r11
    27c4:	b3 94       	inc	r11
    27c6:	04 c0       	rjmp	.+8      	; 0x27d0 <vfprintf+0x300>
    27c8:	8a 2d       	mov	r24, r10
    27ca:	86 78       	andi	r24, 0x86	; 134
    27cc:	09 f0       	breq	.+2      	; 0x27d0 <vfprintf+0x300>
    27ce:	b3 94       	inc	r11
    27d0:	a3 fc       	sbrc	r10, 3
    27d2:	11 c0       	rjmp	.+34     	; 0x27f6 <vfprintf+0x326>
    27d4:	a0 fe       	sbrs	r10, 0
    27d6:	06 c0       	rjmp	.+12     	; 0x27e4 <vfprintf+0x314>
    27d8:	b2 14       	cp	r11, r2
    27da:	88 f4       	brcc	.+34     	; 0x27fe <vfprintf+0x32e>
    27dc:	28 0c       	add	r2, r8
    27de:	92 2c       	mov	r9, r2
    27e0:	9b 18       	sub	r9, r11
    27e2:	0e c0       	rjmp	.+28     	; 0x2800 <vfprintf+0x330>
    27e4:	b2 14       	cp	r11, r2
    27e6:	60 f4       	brcc	.+24     	; 0x2800 <vfprintf+0x330>
    27e8:	b6 01       	movw	r22, r12
    27ea:	80 e2       	ldi	r24, 0x20	; 32
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    27f2:	b3 94       	inc	r11
    27f4:	f7 cf       	rjmp	.-18     	; 0x27e4 <vfprintf+0x314>
    27f6:	b2 14       	cp	r11, r2
    27f8:	18 f4       	brcc	.+6      	; 0x2800 <vfprintf+0x330>
    27fa:	2b 18       	sub	r2, r11
    27fc:	02 c0       	rjmp	.+4      	; 0x2802 <vfprintf+0x332>
    27fe:	98 2c       	mov	r9, r8
    2800:	21 2c       	mov	r2, r1
    2802:	a4 fe       	sbrs	r10, 4
    2804:	10 c0       	rjmp	.+32     	; 0x2826 <vfprintf+0x356>
    2806:	b6 01       	movw	r22, r12
    2808:	80 e3       	ldi	r24, 0x30	; 48
    280a:	90 e0       	ldi	r25, 0x00	; 0
    280c:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2810:	a2 fe       	sbrs	r10, 2
    2812:	17 c0       	rjmp	.+46     	; 0x2842 <vfprintf+0x372>
    2814:	a1 fc       	sbrc	r10, 1
    2816:	03 c0       	rjmp	.+6      	; 0x281e <vfprintf+0x34e>
    2818:	88 e7       	ldi	r24, 0x78	; 120
    281a:	90 e0       	ldi	r25, 0x00	; 0
    281c:	02 c0       	rjmp	.+4      	; 0x2822 <vfprintf+0x352>
    281e:	88 e5       	ldi	r24, 0x58	; 88
    2820:	90 e0       	ldi	r25, 0x00	; 0
    2822:	b6 01       	movw	r22, r12
    2824:	0c c0       	rjmp	.+24     	; 0x283e <vfprintf+0x36e>
    2826:	8a 2d       	mov	r24, r10
    2828:	86 78       	andi	r24, 0x86	; 134
    282a:	59 f0       	breq	.+22     	; 0x2842 <vfprintf+0x372>
    282c:	a1 fe       	sbrs	r10, 1
    282e:	02 c0       	rjmp	.+4      	; 0x2834 <vfprintf+0x364>
    2830:	8b e2       	ldi	r24, 0x2B	; 43
    2832:	01 c0       	rjmp	.+2      	; 0x2836 <vfprintf+0x366>
    2834:	80 e2       	ldi	r24, 0x20	; 32
    2836:	a7 fc       	sbrc	r10, 7
    2838:	8d e2       	ldi	r24, 0x2D	; 45
    283a:	b6 01       	movw	r22, r12
    283c:	90 e0       	ldi	r25, 0x00	; 0
    283e:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2842:	89 14       	cp	r8, r9
    2844:	38 f4       	brcc	.+14     	; 0x2854 <vfprintf+0x384>
    2846:	b6 01       	movw	r22, r12
    2848:	80 e3       	ldi	r24, 0x30	; 48
    284a:	90 e0       	ldi	r25, 0x00	; 0
    284c:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2850:	9a 94       	dec	r9
    2852:	f7 cf       	rjmp	.-18     	; 0x2842 <vfprintf+0x372>
    2854:	8a 94       	dec	r8
    2856:	f3 01       	movw	r30, r6
    2858:	e8 0d       	add	r30, r8
    285a:	f1 1d       	adc	r31, r1
    285c:	80 81       	ld	r24, Z
    285e:	b6 01       	movw	r22, r12
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    2866:	81 10       	cpse	r8, r1
    2868:	f5 cf       	rjmp	.-22     	; 0x2854 <vfprintf+0x384>
    286a:	22 20       	and	r2, r2
    286c:	09 f4       	brne	.+2      	; 0x2870 <vfprintf+0x3a0>
    286e:	42 ce       	rjmp	.-892    	; 0x24f4 <vfprintf+0x24>
    2870:	b6 01       	movw	r22, r12
    2872:	80 e2       	ldi	r24, 0x20	; 32
    2874:	90 e0       	ldi	r25, 0x00	; 0
    2876:	0e 94 5f 14 	call	0x28be	; 0x28be <fputc>
    287a:	2a 94       	dec	r2
    287c:	f6 cf       	rjmp	.-20     	; 0x286a <vfprintf+0x39a>
    287e:	f6 01       	movw	r30, r12
    2880:	86 81       	ldd	r24, Z+6	; 0x06
    2882:	97 81       	ldd	r25, Z+7	; 0x07
    2884:	02 c0       	rjmp	.+4      	; 0x288a <vfprintf+0x3ba>
    2886:	8f ef       	ldi	r24, 0xFF	; 255
    2888:	9f ef       	ldi	r25, 0xFF	; 255
    288a:	2b 96       	adiw	r28, 0x0b	; 11
    288c:	e2 e1       	ldi	r30, 0x12	; 18
    288e:	0c 94 15 15 	jmp	0x2a2a	; 0x2a2a <__epilogue_restores__>

00002892 <strnlen_P>:
    2892:	fc 01       	movw	r30, r24
    2894:	05 90       	lpm	r0, Z+
    2896:	61 50       	subi	r22, 0x01	; 1
    2898:	70 40       	sbci	r23, 0x00	; 0
    289a:	01 10       	cpse	r0, r1
    289c:	d8 f7       	brcc	.-10     	; 0x2894 <strnlen_P+0x2>
    289e:	80 95       	com	r24
    28a0:	90 95       	com	r25
    28a2:	8e 0f       	add	r24, r30
    28a4:	9f 1f       	adc	r25, r31
    28a6:	08 95       	ret

000028a8 <strnlen>:
    28a8:	fc 01       	movw	r30, r24
    28aa:	61 50       	subi	r22, 0x01	; 1
    28ac:	70 40       	sbci	r23, 0x00	; 0
    28ae:	01 90       	ld	r0, Z+
    28b0:	01 10       	cpse	r0, r1
    28b2:	d8 f7       	brcc	.-10     	; 0x28aa <strnlen+0x2>
    28b4:	80 95       	com	r24
    28b6:	90 95       	com	r25
    28b8:	8e 0f       	add	r24, r30
    28ba:	9f 1f       	adc	r25, r31
    28bc:	08 95       	ret

000028be <fputc>:
    28be:	0f 93       	push	r16
    28c0:	1f 93       	push	r17
    28c2:	cf 93       	push	r28
    28c4:	df 93       	push	r29
    28c6:	fb 01       	movw	r30, r22
    28c8:	23 81       	ldd	r18, Z+3	; 0x03
    28ca:	21 fd       	sbrc	r18, 1
    28cc:	03 c0       	rjmp	.+6      	; 0x28d4 <fputc+0x16>
    28ce:	8f ef       	ldi	r24, 0xFF	; 255
    28d0:	9f ef       	ldi	r25, 0xFF	; 255
    28d2:	2c c0       	rjmp	.+88     	; 0x292c <fputc+0x6e>
    28d4:	22 ff       	sbrs	r18, 2
    28d6:	16 c0       	rjmp	.+44     	; 0x2904 <fputc+0x46>
    28d8:	46 81       	ldd	r20, Z+6	; 0x06
    28da:	57 81       	ldd	r21, Z+7	; 0x07
    28dc:	24 81       	ldd	r18, Z+4	; 0x04
    28de:	35 81       	ldd	r19, Z+5	; 0x05
    28e0:	42 17       	cp	r20, r18
    28e2:	53 07       	cpc	r21, r19
    28e4:	44 f4       	brge	.+16     	; 0x28f6 <fputc+0x38>
    28e6:	a0 81       	ld	r26, Z
    28e8:	b1 81       	ldd	r27, Z+1	; 0x01
    28ea:	9d 01       	movw	r18, r26
    28ec:	2f 5f       	subi	r18, 0xFF	; 255
    28ee:	3f 4f       	sbci	r19, 0xFF	; 255
    28f0:	31 83       	std	Z+1, r19	; 0x01
    28f2:	20 83       	st	Z, r18
    28f4:	8c 93       	st	X, r24
    28f6:	26 81       	ldd	r18, Z+6	; 0x06
    28f8:	37 81       	ldd	r19, Z+7	; 0x07
    28fa:	2f 5f       	subi	r18, 0xFF	; 255
    28fc:	3f 4f       	sbci	r19, 0xFF	; 255
    28fe:	37 83       	std	Z+7, r19	; 0x07
    2900:	26 83       	std	Z+6, r18	; 0x06
    2902:	14 c0       	rjmp	.+40     	; 0x292c <fputc+0x6e>
    2904:	8b 01       	movw	r16, r22
    2906:	ec 01       	movw	r28, r24
    2908:	fb 01       	movw	r30, r22
    290a:	00 84       	ldd	r0, Z+8	; 0x08
    290c:	f1 85       	ldd	r31, Z+9	; 0x09
    290e:	e0 2d       	mov	r30, r0
    2910:	09 95       	icall
    2912:	89 2b       	or	r24, r25
    2914:	e1 f6       	brne	.-72     	; 0x28ce <fputc+0x10>
    2916:	d8 01       	movw	r26, r16
    2918:	16 96       	adiw	r26, 0x06	; 6
    291a:	8d 91       	ld	r24, X+
    291c:	9c 91       	ld	r25, X
    291e:	17 97       	sbiw	r26, 0x07	; 7
    2920:	01 96       	adiw	r24, 0x01	; 1
    2922:	17 96       	adiw	r26, 0x07	; 7
    2924:	9c 93       	st	X, r25
    2926:	8e 93       	st	-X, r24
    2928:	16 97       	sbiw	r26, 0x06	; 6
    292a:	ce 01       	movw	r24, r28
    292c:	df 91       	pop	r29
    292e:	cf 91       	pop	r28
    2930:	1f 91       	pop	r17
    2932:	0f 91       	pop	r16
    2934:	08 95       	ret

00002936 <__ultoa_invert>:
    2936:	fa 01       	movw	r30, r20
    2938:	aa 27       	eor	r26, r26
    293a:	28 30       	cpi	r18, 0x08	; 8
    293c:	51 f1       	breq	.+84     	; 0x2992 <__ultoa_invert+0x5c>
    293e:	20 31       	cpi	r18, 0x10	; 16
    2940:	81 f1       	breq	.+96     	; 0x29a2 <__ultoa_invert+0x6c>
    2942:	e8 94       	clt
    2944:	6f 93       	push	r22
    2946:	6e 7f       	andi	r22, 0xFE	; 254
    2948:	6e 5f       	subi	r22, 0xFE	; 254
    294a:	7f 4f       	sbci	r23, 0xFF	; 255
    294c:	8f 4f       	sbci	r24, 0xFF	; 255
    294e:	9f 4f       	sbci	r25, 0xFF	; 255
    2950:	af 4f       	sbci	r26, 0xFF	; 255
    2952:	b1 e0       	ldi	r27, 0x01	; 1
    2954:	3e d0       	rcall	.+124    	; 0x29d2 <__ultoa_invert+0x9c>
    2956:	b4 e0       	ldi	r27, 0x04	; 4
    2958:	3c d0       	rcall	.+120    	; 0x29d2 <__ultoa_invert+0x9c>
    295a:	67 0f       	add	r22, r23
    295c:	78 1f       	adc	r23, r24
    295e:	89 1f       	adc	r24, r25
    2960:	9a 1f       	adc	r25, r26
    2962:	a1 1d       	adc	r26, r1
    2964:	68 0f       	add	r22, r24
    2966:	79 1f       	adc	r23, r25
    2968:	8a 1f       	adc	r24, r26
    296a:	91 1d       	adc	r25, r1
    296c:	a1 1d       	adc	r26, r1
    296e:	6a 0f       	add	r22, r26
    2970:	71 1d       	adc	r23, r1
    2972:	81 1d       	adc	r24, r1
    2974:	91 1d       	adc	r25, r1
    2976:	a1 1d       	adc	r26, r1
    2978:	20 d0       	rcall	.+64     	; 0x29ba <__ultoa_invert+0x84>
    297a:	09 f4       	brne	.+2      	; 0x297e <__ultoa_invert+0x48>
    297c:	68 94       	set
    297e:	3f 91       	pop	r19
    2980:	2a e0       	ldi	r18, 0x0A	; 10
    2982:	26 9f       	mul	r18, r22
    2984:	11 24       	eor	r1, r1
    2986:	30 19       	sub	r19, r0
    2988:	30 5d       	subi	r19, 0xD0	; 208
    298a:	31 93       	st	Z+, r19
    298c:	de f6       	brtc	.-74     	; 0x2944 <__ultoa_invert+0xe>
    298e:	cf 01       	movw	r24, r30
    2990:	08 95       	ret
    2992:	46 2f       	mov	r20, r22
    2994:	47 70       	andi	r20, 0x07	; 7
    2996:	40 5d       	subi	r20, 0xD0	; 208
    2998:	41 93       	st	Z+, r20
    299a:	b3 e0       	ldi	r27, 0x03	; 3
    299c:	0f d0       	rcall	.+30     	; 0x29bc <__ultoa_invert+0x86>
    299e:	c9 f7       	brne	.-14     	; 0x2992 <__ultoa_invert+0x5c>
    29a0:	f6 cf       	rjmp	.-20     	; 0x298e <__ultoa_invert+0x58>
    29a2:	46 2f       	mov	r20, r22
    29a4:	4f 70       	andi	r20, 0x0F	; 15
    29a6:	40 5d       	subi	r20, 0xD0	; 208
    29a8:	4a 33       	cpi	r20, 0x3A	; 58
    29aa:	18 f0       	brcs	.+6      	; 0x29b2 <__ultoa_invert+0x7c>
    29ac:	49 5d       	subi	r20, 0xD9	; 217
    29ae:	31 fd       	sbrc	r19, 1
    29b0:	40 52       	subi	r20, 0x20	; 32
    29b2:	41 93       	st	Z+, r20
    29b4:	02 d0       	rcall	.+4      	; 0x29ba <__ultoa_invert+0x84>
    29b6:	a9 f7       	brne	.-22     	; 0x29a2 <__ultoa_invert+0x6c>
    29b8:	ea cf       	rjmp	.-44     	; 0x298e <__ultoa_invert+0x58>
    29ba:	b4 e0       	ldi	r27, 0x04	; 4
    29bc:	a6 95       	lsr	r26
    29be:	97 95       	ror	r25
    29c0:	87 95       	ror	r24
    29c2:	77 95       	ror	r23
    29c4:	67 95       	ror	r22
    29c6:	ba 95       	dec	r27
    29c8:	c9 f7       	brne	.-14     	; 0x29bc <__ultoa_invert+0x86>
    29ca:	00 97       	sbiw	r24, 0x00	; 0
    29cc:	61 05       	cpc	r22, r1
    29ce:	71 05       	cpc	r23, r1
    29d0:	08 95       	ret
    29d2:	9b 01       	movw	r18, r22
    29d4:	ac 01       	movw	r20, r24
    29d6:	0a 2e       	mov	r0, r26
    29d8:	06 94       	lsr	r0
    29da:	57 95       	ror	r21
    29dc:	47 95       	ror	r20
    29de:	37 95       	ror	r19
    29e0:	27 95       	ror	r18
    29e2:	ba 95       	dec	r27
    29e4:	c9 f7       	brne	.-14     	; 0x29d8 <__ultoa_invert+0xa2>
    29e6:	62 0f       	add	r22, r18
    29e8:	73 1f       	adc	r23, r19
    29ea:	84 1f       	adc	r24, r20
    29ec:	95 1f       	adc	r25, r21
    29ee:	a0 1d       	adc	r26, r0
    29f0:	08 95       	ret

000029f2 <__prologue_saves__>:
    29f2:	2f 92       	push	r2
    29f4:	3f 92       	push	r3
    29f6:	4f 92       	push	r4
    29f8:	5f 92       	push	r5
    29fa:	6f 92       	push	r6
    29fc:	7f 92       	push	r7
    29fe:	8f 92       	push	r8
    2a00:	9f 92       	push	r9
    2a02:	af 92       	push	r10
    2a04:	bf 92       	push	r11
    2a06:	cf 92       	push	r12
    2a08:	df 92       	push	r13
    2a0a:	ef 92       	push	r14
    2a0c:	ff 92       	push	r15
    2a0e:	0f 93       	push	r16
    2a10:	1f 93       	push	r17
    2a12:	cf 93       	push	r28
    2a14:	df 93       	push	r29
    2a16:	cd b7       	in	r28, 0x3d	; 61
    2a18:	de b7       	in	r29, 0x3e	; 62
    2a1a:	ca 1b       	sub	r28, r26
    2a1c:	db 0b       	sbc	r29, r27
    2a1e:	0f b6       	in	r0, 0x3f	; 63
    2a20:	f8 94       	cli
    2a22:	de bf       	out	0x3e, r29	; 62
    2a24:	0f be       	out	0x3f, r0	; 63
    2a26:	cd bf       	out	0x3d, r28	; 61
    2a28:	09 94       	ijmp

00002a2a <__epilogue_restores__>:
    2a2a:	2a 88       	ldd	r2, Y+18	; 0x12
    2a2c:	39 88       	ldd	r3, Y+17	; 0x11
    2a2e:	48 88       	ldd	r4, Y+16	; 0x10
    2a30:	5f 84       	ldd	r5, Y+15	; 0x0f
    2a32:	6e 84       	ldd	r6, Y+14	; 0x0e
    2a34:	7d 84       	ldd	r7, Y+13	; 0x0d
    2a36:	8c 84       	ldd	r8, Y+12	; 0x0c
    2a38:	9b 84       	ldd	r9, Y+11	; 0x0b
    2a3a:	aa 84       	ldd	r10, Y+10	; 0x0a
    2a3c:	b9 84       	ldd	r11, Y+9	; 0x09
    2a3e:	c8 84       	ldd	r12, Y+8	; 0x08
    2a40:	df 80       	ldd	r13, Y+7	; 0x07
    2a42:	ee 80       	ldd	r14, Y+6	; 0x06
    2a44:	fd 80       	ldd	r15, Y+5	; 0x05
    2a46:	0c 81       	ldd	r16, Y+4	; 0x04
    2a48:	1b 81       	ldd	r17, Y+3	; 0x03
    2a4a:	aa 81       	ldd	r26, Y+2	; 0x02
    2a4c:	b9 81       	ldd	r27, Y+1	; 0x01
    2a4e:	ce 0f       	add	r28, r30
    2a50:	d1 1d       	adc	r29, r1
    2a52:	0f b6       	in	r0, 0x3f	; 63
    2a54:	f8 94       	cli
    2a56:	de bf       	out	0x3e, r29	; 62
    2a58:	0f be       	out	0x3f, r0	; 63
    2a5a:	cd bf       	out	0x3d, r28	; 61
    2a5c:	ed 01       	movw	r28, r26
    2a5e:	08 95       	ret

00002a60 <_exit>:
    2a60:	f8 94       	cli

00002a62 <__stop_program>:
    2a62:	ff cf       	rjmp	.-2      	; 0x2a62 <__stop_program>
