
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800100  00002b98  00002c2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068a  0080013e  0080013e  00002c6a  2**0
                  ALLOC
  3 .stab         00007704  00000000  00000000  00002c6c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000043db  00000000  00000000  0000a370  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e74b  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e75c  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e79c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000ed90  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f332  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f34c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 da 11 	jmp	0x23b4	; 0x23b4 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__vector_18>
      4c:	0c 94 89 00 	jmp	0x112	; 0x112 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 e9       	ldi	r30, 0x98	; 152
      7c:	fb e2       	ldi	r31, 0x2B	; 43
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ae 33       	cpi	r26, 0x3E	; 62
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ae e3       	ldi	r26, 0x3E	; 62
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a8 3c       	cpi	r26, 0xC8	; 200
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 42 12 	call	0x2484	; 0x2484 <main>
      9e:	0c 94 ca 15 	jmp	0x2b94	; 0x2b94 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
    uart_init();
      a6:	0e 94 1f 12 	call	0x243e	; 0x243e <uart_init>
    stdin = stdout = stderr = &uart_file;
      aa:	80 e0       	ldi	r24, 0x00	; 0
      ac:	91 e0       	ldi	r25, 0x01	; 1
      ae:	90 93 c7 07 	sts	0x07C7, r25	; 0x8007c7 <__iob+0x5>
      b2:	80 93 c6 07 	sts	0x07C6, r24	; 0x8007c6 <__iob+0x4>
      b6:	90 93 c5 07 	sts	0x07C5, r25	; 0x8007c5 <__iob+0x3>
      ba:	80 93 c4 07 	sts	0x07C4, r24	; 0x8007c4 <__iob+0x2>
      be:	90 93 c3 07 	sts	0x07C3, r25	; 0x8007c3 <__iob+0x1>
      c2:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <__iob>

    while(1)
    {
        puts("Hello World\r\n");
        input = getchar();
        printf("You wrote %c\r\n", input); 
      c6:	cc e1       	ldi	r28, 0x1C	; 28
      c8:	d1 e0       	ldi	r29, 0x01	; 1

    char input;

    while(1)
    {
        puts("Hello World\r\n");
      ca:	8e e0       	ldi	r24, 0x0E	; 14
      cc:	91 e0       	ldi	r25, 0x01	; 1
      ce:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <puts>
        input = getchar();
      d2:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <__iob>
      d6:	90 91 c3 07 	lds	r25, 0x07C3	; 0x8007c3 <__iob+0x1>
      da:	0e 94 7e 12 	call	0x24fc	; 0x24fc <fgetc>
        printf("You wrote %c\r\n", input); 
      de:	28 2f       	mov	r18, r24
      e0:	08 2e       	mov	r0, r24
      e2:	00 0c       	add	r0, r0
      e4:	33 0b       	sbc	r19, r19
      e6:	3f 93       	push	r19
      e8:	8f 93       	push	r24
      ea:	df 93       	push	r29
      ec:	cf 93       	push	r28
      ee:	0e 94 bc 12 	call	0x2578	; 0x2578 <printf>
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	0f 90       	pop	r0
      f8:	0f 90       	pop	r0
      fa:	e7 cf       	rjmp	.-50     	; 0xca <vSerial+0x24>

000000fc <vBlinkLed>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
    DDRB |= _BV(PB5);
      fc:	25 9a       	sbi	0x04, 5	; 4

    while(1)
    {
        PORTB ^= _BV(PB5);
      fe:	c0 e2       	ldi	r28, 0x20	; 32
     100:	85 b1       	in	r24, 0x05	; 5
     102:	8c 27       	eor	r24, r28
     104:	85 b9       	out	0x05, r24	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
     106:	84 ef       	ldi	r24, 0xF4	; 244
     108:	91 e0       	ldi	r25, 0x01	; 1
     10a:	0e 94 22 05 	call	0xa44	; 0xa44 <vTaskDelay>
     10e:	f8 cf       	rjmp	.-16     	; 0x100 <vBlinkLed+0x4>

00000110 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     110:	08 95       	ret

00000112 <__vector_19>:
        input = getchar();
        printf("You wrote %c\r\n", input); 
    }
}

ISR(USART_UDRE_vect) {
     112:	1f 92       	push	r1
     114:	0f 92       	push	r0
     116:	0f b6       	in	r0, 0x3f	; 63
     118:	0f 92       	push	r0
     11a:	11 24       	eor	r1, r1
     11c:	2f 93       	push	r18
     11e:	3f 93       	push	r19
     120:	4f 93       	push	r20
     122:	5f 93       	push	r21
     124:	6f 93       	push	r22
     126:	7f 93       	push	r23
     128:	8f 93       	push	r24
     12a:	9f 93       	push	r25
     12c:	af 93       	push	r26
     12e:	bf 93       	push	r27
     130:	ef 93       	push	r30
     132:	ff 93       	push	r31
    if (xQueueIsQueueEmptyFromISR(bufor_out) == pdFALSE)
     134:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <bufor_out>
     138:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <bufor_out+0x1>
     13c:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <xQueueIsQueueEmptyFromISR>
     140:	81 11       	cpse	r24, r1
     142:	0a c0       	rjmp	.+20     	; 0x158 <__vector_19+0x46>
        xQueueReceiveFromISR(bufor_out, (void*)&UDR0, NULL);
     144:	40 e0       	ldi	r20, 0x00	; 0
     146:	50 e0       	ldi	r21, 0x00	; 0
     148:	66 ec       	ldi	r22, 0xC6	; 198
     14a:	70 e0       	ldi	r23, 0x00	; 0
     14c:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <bufor_out>
     150:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <bufor_out+0x1>
     154:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueReceiveFromISR>
}
     158:	ff 91       	pop	r31
     15a:	ef 91       	pop	r30
     15c:	bf 91       	pop	r27
     15e:	af 91       	pop	r26
     160:	9f 91       	pop	r25
     162:	8f 91       	pop	r24
     164:	7f 91       	pop	r23
     166:	6f 91       	pop	r22
     168:	5f 91       	pop	r21
     16a:	4f 91       	pop	r20
     16c:	3f 91       	pop	r19
     16e:	2f 91       	pop	r18
     170:	0f 90       	pop	r0
     172:	0f be       	out	0x3f, r0	; 63
     174:	0f 90       	pop	r0
     176:	1f 90       	pop	r1
     178:	18 95       	reti

0000017a <__vector_18>:

ISR(USART_RX_vect) {
     17a:	1f 92       	push	r1
     17c:	0f 92       	push	r0
     17e:	0f b6       	in	r0, 0x3f	; 63
     180:	0f 92       	push	r0
     182:	11 24       	eor	r1, r1
     184:	2f 93       	push	r18
     186:	3f 93       	push	r19
     188:	4f 93       	push	r20
     18a:	5f 93       	push	r21
     18c:	6f 93       	push	r22
     18e:	7f 93       	push	r23
     190:	8f 93       	push	r24
     192:	9f 93       	push	r25
     194:	af 93       	push	r26
     196:	bf 93       	push	r27
     198:	ef 93       	push	r30
     19a:	ff 93       	push	r31
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	1f 92       	push	r1
     1a2:	cd b7       	in	r28, 0x3d	; 61
     1a4:	de b7       	in	r29, 0x3e	; 62
    uint8_t value = UDR0;
     1a6:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
     1aa:	89 83       	std	Y+1, r24	; 0x01
    xQueueSendFromISR(bufor_in, (void*)&value, NULL);
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	40 e0       	ldi	r20, 0x00	; 0
     1b0:	50 e0       	ldi	r21, 0x00	; 0
     1b2:	be 01       	movw	r22, r28
     1b4:	6f 5f       	subi	r22, 0xFF	; 255
     1b6:	7f 4f       	sbci	r23, 0xFF	; 255
     1b8:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <bufor_in>
     1bc:	90 91 c1 07 	lds	r25, 0x07C1	; 0x8007c1 <bufor_in+0x1>
     1c0:	0e 94 9e 0a 	call	0x153c	; 0x153c <xQueueGenericSendFromISR>
     1c4:	0f 90       	pop	r0
     1c6:	df 91       	pop	r29
     1c8:	cf 91       	pop	r28
     1ca:	ff 91       	pop	r31
     1cc:	ef 91       	pop	r30
     1ce:	bf 91       	pop	r27
     1d0:	af 91       	pop	r26
     1d2:	9f 91       	pop	r25
     1d4:	8f 91       	pop	r24
     1d6:	7f 91       	pop	r23
     1d8:	6f 91       	pop	r22
     1da:	5f 91       	pop	r21
     1dc:	4f 91       	pop	r20
     1de:	3f 91       	pop	r19
     1e0:	2f 91       	pop	r18
     1e2:	0f 90       	pop	r0
     1e4:	0f be       	out	0x3f, r0	; 63
     1e6:	0f 90       	pop	r0
     1e8:	1f 90       	pop	r1
     1ea:	18 95       	reti

000001ec <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1ec:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     1f0:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     1f4:	80 81       	ld	r24, Z
     1f6:	81 11       	cpse	r24, r1
     1f8:	03 c0       	rjmp	.+6      	; 0x200 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1fa:	8f ef       	ldi	r24, 0xFF	; 255
     1fc:	9f ef       	ldi	r25, 0xFF	; 255
     1fe:	0c c0       	rjmp	.+24     	; 0x218 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     200:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     204:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     208:	05 80       	ldd	r0, Z+5	; 0x05
     20a:	f6 81       	ldd	r31, Z+6	; 0x06
     20c:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     20e:	06 80       	ldd	r0, Z+6	; 0x06
     210:	f7 81       	ldd	r31, Z+7	; 0x07
     212:	e0 2d       	mov	r30, r0
     214:	82 81       	ldd	r24, Z+2	; 0x02
     216:	93 81       	ldd	r25, Z+3	; 0x03
     218:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
     21c:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
     220:	08 95       	ret

00000222 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     222:	ff 92       	push	r15
     224:	0f 93       	push	r16
     226:	1f 93       	push	r17
     228:	cf 93       	push	r28
     22a:	df 93       	push	r29
     22c:	ec 01       	movw	r28, r24
     22e:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     230:	00 91 4b 01 	lds	r16, 0x014B	; 0x80014b <xTickCount>
     234:	10 91 4c 01 	lds	r17, 0x014C	; 0x80014c <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     238:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     23c:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     240:	02 96       	adiw	r24, 0x02	; 2
     242:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     246:	cf 3f       	cpi	r28, 0xFF	; 255
     248:	8f ef       	ldi	r24, 0xFF	; 255
     24a:	d8 07       	cpc	r29, r24
     24c:	89 f4       	brne	.+34     	; 0x270 <prvAddCurrentTaskToDelayedList+0x4e>
     24e:	ff 20       	and	r15, r15
     250:	79 f0       	breq	.+30     	; 0x270 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     252:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     256:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
     25a:	6e 5f       	subi	r22, 0xFE	; 254
     25c:	7f 4f       	sbci	r23, 0xFF	; 255
     25e:	8e e4       	ldi	r24, 0x4E	; 78
     260:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     262:	df 91       	pop	r29
     264:	cf 91       	pop	r28
     266:	1f 91       	pop	r17
     268:	0f 91       	pop	r16
     26a:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     26c:	0c 94 f4 0d 	jmp	0x1be8	; 0x1be8 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     270:	c0 0f       	add	r28, r16
     272:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     274:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     278:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     27c:	d3 83       	std	Z+3, r29	; 0x03
     27e:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     280:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     284:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     288:	c0 17       	cp	r28, r16
     28a:	d1 07       	cpc	r29, r17
     28c:	68 f4       	brcc	.+26     	; 0x2a8 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     28e:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <pxOverflowDelayedTaskList>
     292:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     296:	6e 5f       	subi	r22, 0xFE	; 254
     298:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     29a:	df 91       	pop	r29
     29c:	cf 91       	pop	r28
     29e:	1f 91       	pop	r17
     2a0:	0f 91       	pop	r16
     2a2:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2a4:	0c 94 15 0e 	jmp	0x1c2a	; 0x1c2a <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2a8:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <pxDelayedTaskList>
     2ac:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     2b0:	6e 5f       	subi	r22, 0xFE	; 254
     2b2:	7f 4f       	sbci	r23, 0xFF	; 255
     2b4:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     2b8:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xNextTaskUnblockTime>
     2bc:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <xNextTaskUnblockTime+0x1>
     2c0:	c8 17       	cp	r28, r24
     2c2:	d9 07       	cpc	r29, r25
     2c4:	20 f4       	brcc	.+8      	; 0x2ce <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     2c6:	d0 93 44 01 	sts	0x0144, r29	; 0x800144 <xNextTaskUnblockTime+0x1>
     2ca:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2ce:	df 91       	pop	r29
     2d0:	cf 91       	pop	r28
     2d2:	1f 91       	pop	r17
     2d4:	0f 91       	pop	r16
     2d6:	ff 90       	pop	r15
     2d8:	08 95       	ret

000002da <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     2da:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     2de:	88 23       	and	r24, r24
     2e0:	09 f1       	breq	.+66     	; 0x324 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     2e2:	0f b6       	in	r0, 0x3f	; 63
     2e4:	f8 94       	cli
     2e6:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2e8:	e0 91 5d 01 	lds	r30, 0x015D	; 0x80015d <xTasksWaitingTermination+0x5>
     2ec:	f0 91 5e 01 	lds	r31, 0x015E	; 0x80015e <xTasksWaitingTermination+0x6>
     2f0:	c6 81       	ldd	r28, Z+6	; 0x06
     2f2:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     2f4:	ce 01       	movw	r24, r28
     2f6:	02 96       	adiw	r24, 0x02	; 2
     2f8:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
				--uxCurrentNumberOfTasks;
     2fc:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     300:	81 50       	subi	r24, 0x01	; 1
     302:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     306:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     30a:	81 50       	subi	r24, 0x01	; 1
     30c:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     310:	0f 90       	pop	r0
     312:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     314:	8f 89       	ldd	r24, Y+23	; 0x17
     316:	98 8d       	ldd	r25, Y+24	; 0x18
     318:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vPortFree>
			vPortFree( pxTCB );
     31c:	ce 01       	movw	r24, r28
     31e:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vPortFree>
     322:	db cf       	rjmp	.-74     	; 0x2da <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     324:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <pxReadyTasksLists>
     328:	82 30       	cpi	r24, 0x02	; 2
     32a:	10 f0       	brcs	.+4      	; 0x330 <prvIdleTask+0x56>
			{
				taskYIELD();
     32c:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     330:	0e 94 88 00 	call	0x110	; 0x110 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     334:	d2 cf       	rjmp	.-92     	; 0x2da <prvIdleTask>

00000336 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     336:	3f 92       	push	r3
     338:	4f 92       	push	r4
     33a:	5f 92       	push	r5
     33c:	6f 92       	push	r6
     33e:	7f 92       	push	r7
     340:	8f 92       	push	r8
     342:	9f 92       	push	r9
     344:	af 92       	push	r10
     346:	bf 92       	push	r11
     348:	cf 92       	push	r12
     34a:	df 92       	push	r13
     34c:	ef 92       	push	r14
     34e:	ff 92       	push	r15
     350:	0f 93       	push	r16
     352:	1f 93       	push	r17
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	4c 01       	movw	r8, r24
     35a:	16 2f       	mov	r17, r22
     35c:	37 2e       	mov	r3, r23
     35e:	6a 01       	movw	r12, r20
     360:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     362:	ca 01       	movw	r24, r20
     364:	0e 94 37 10 	call	0x206e	; 0x206e <pvPortMalloc>
     368:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     36a:	89 2b       	or	r24, r25
     36c:	09 f4       	brne	.+2      	; 0x370 <xTaskCreate+0x3a>
     36e:	d1 c0       	rjmp	.+418    	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     370:	86 e2       	ldi	r24, 0x26	; 38
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 37 10 	call	0x206e	; 0x206e <pvPortMalloc>
     378:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     37a:	89 2b       	or	r24, r25
     37c:	79 f0       	breq	.+30     	; 0x39c <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     37e:	58 8e       	std	Y+24, r5	; 0x18
     380:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     382:	c6 01       	movw	r24, r12
     384:	01 97       	sbiw	r24, 0x01	; 1
     386:	32 01       	movw	r6, r4
     388:	68 0e       	add	r6, r24
     38a:	79 1e       	adc	r7, r25
     38c:	be 01       	movw	r22, r28
     38e:	67 5e       	subi	r22, 0xE7	; 231
     390:	7f 4f       	sbci	r23, 0xFF	; 255
     392:	e1 2f       	mov	r30, r17
     394:	f3 2d       	mov	r31, r3
     396:	cf 01       	movw	r24, r30
     398:	08 96       	adiw	r24, 0x08	; 8
     39a:	07 c0       	rjmp	.+14     	; 0x3aa <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     39c:	c2 01       	movw	r24, r4
     39e:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vPortFree>
     3a2:	b7 c0       	rjmp	.+366    	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     3a4:	e8 17       	cp	r30, r24
     3a6:	f9 07       	cpc	r31, r25
     3a8:	49 f0       	breq	.+18     	; 0x3bc <xTaskCreate+0x86>
     3aa:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     3ac:	41 91       	ld	r20, Z+
     3ae:	db 01       	movw	r26, r22
     3b0:	4d 93       	st	X+, r20
     3b2:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     3b4:	d9 01       	movw	r26, r18
     3b6:	2c 91       	ld	r18, X
     3b8:	21 11       	cpse	r18, r1
     3ba:	f4 cf       	rjmp	.-24     	; 0x3a4 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     3bc:	18 a2       	std	Y+32, r1	; 0x20
     3be:	04 30       	cpi	r16, 0x04	; 4
     3c0:	08 f0       	brcs	.+2      	; 0x3c4 <xTaskCreate+0x8e>
     3c2:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     3c4:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     3c6:	6e 01       	movw	r12, r28
     3c8:	b2 e0       	ldi	r27, 0x02	; 2
     3ca:	cb 0e       	add	r12, r27
     3cc:	d1 1c       	adc	r13, r1
     3ce:	c6 01       	movw	r24, r12
     3d0:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     3d4:	ce 01       	movw	r24, r28
     3d6:	0c 96       	adiw	r24, 0x0c	; 12
     3d8:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     3dc:	d9 87       	std	Y+9, r29	; 0x09
     3de:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     3e0:	84 e0       	ldi	r24, 0x04	; 4
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	80 1b       	sub	r24, r16
     3e6:	91 09       	sbc	r25, r1
     3e8:	9d 87       	std	Y+13, r25	; 0x0d
     3ea:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     3ec:	db 8b       	std	Y+19, r29	; 0x13
     3ee:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     3f0:	19 a2       	std	Y+33, r1	; 0x21
     3f2:	1a a2       	std	Y+34, r1	; 0x22
     3f4:	1b a2       	std	Y+35, r1	; 0x23
     3f6:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     3f8:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     3fa:	a5 01       	movw	r20, r10
     3fc:	b4 01       	movw	r22, r8
     3fe:	c3 01       	movw	r24, r6
     400:	0e 94 78 10 	call	0x20f0	; 0x20f0 <pxPortInitialiseStack>
     404:	99 83       	std	Y+1, r25	; 0x01
     406:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     408:	e1 14       	cp	r14, r1
     40a:	f1 04       	cpc	r15, r1
     40c:	19 f0       	breq	.+6      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     40e:	f7 01       	movw	r30, r14
     410:	d1 83       	std	Z+1, r29	; 0x01
     412:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     414:	0f b6       	in	r0, 0x3f	; 63
     416:	f8 94       	cli
     418:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     41a:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     41e:	8f 5f       	subi	r24, 0xFF	; 255
     420:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     424:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     428:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     42c:	89 2b       	or	r24, r25
     42e:	d1 f5       	brne	.+116    	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     430:	d0 93 3f 01 	sts	0x013F, r29	; 0x80013f <__data_end+0x1>
     434:	c0 93 3e 01 	sts	0x013E, r28	; 0x80013e <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     438:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     43c:	81 30       	cpi	r24, 0x01	; 1
     43e:	09 f0       	breq	.+2      	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
     440:	41 c0       	rjmp	.+130    	; 0x4c4 <__LOCK_REGION_LENGTH__+0xc4>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     442:	80 e8       	ldi	r24, 0x80	; 128
     444:	91 e0       	ldi	r25, 0x01	; 1
     446:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
     44a:	89 e8       	ldi	r24, 0x89	; 137
     44c:	91 e0       	ldi	r25, 0x01	; 1
     44e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
     452:	82 e9       	ldi	r24, 0x92	; 146
     454:	91 e0       	ldi	r25, 0x01	; 1
     456:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
     45a:	8b e9       	ldi	r24, 0x9B	; 155
     45c:	91 e0       	ldi	r25, 0x01	; 1
     45e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     462:	87 e7       	ldi	r24, 0x77	; 119
     464:	91 e0       	ldi	r25, 0x01	; 1
     466:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     46a:	8e e6       	ldi	r24, 0x6E	; 110
     46c:	91 e0       	ldi	r25, 0x01	; 1
     46e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     472:	81 e6       	ldi	r24, 0x61	; 97
     474:	91 e0       	ldi	r25, 0x01	; 1
     476:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     47a:	88 e5       	ldi	r24, 0x58	; 88
     47c:	91 e0       	ldi	r25, 0x01	; 1
     47e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     482:	8e e4       	ldi	r24, 0x4E	; 78
     484:	91 e0       	ldi	r25, 0x01	; 1
     486:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     48a:	87 e7       	ldi	r24, 0x77	; 119
     48c:	91 e0       	ldi	r25, 0x01	; 1
     48e:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <pxDelayedTaskList+0x1>
     492:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     496:	8e e6       	ldi	r24, 0x6E	; 110
     498:	91 e0       	ldi	r25, 0x01	; 1
     49a:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     49e:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <pxOverflowDelayedTaskList>
     4a2:	10 c0       	rjmp	.+32     	; 0x4c4 <__LOCK_REGION_LENGTH__+0xc4>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     4a4:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     4a8:	81 11       	cpse	r24, r1
     4aa:	0c c0       	rjmp	.+24     	; 0x4c4 <__LOCK_REGION_LENGTH__+0xc4>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4ac:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     4b0:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     4b4:	96 89       	ldd	r25, Z+22	; 0x16
     4b6:	8e 89       	ldd	r24, Y+22	; 0x16
     4b8:	89 17       	cp	r24, r25
     4ba:	20 f0       	brcs	.+8      	; 0x4c4 <__LOCK_REGION_LENGTH__+0xc4>
				{
					pxCurrentTCB = pxNewTCB;
     4bc:	d0 93 3f 01 	sts	0x013F, r29	; 0x80013f <__data_end+0x1>
     4c0:	c0 93 3e 01 	sts	0x013E, r28	; 0x80013e <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     4c4:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <uxTaskNumber>
     4c8:	8f 5f       	subi	r24, 0xFF	; 255
     4ca:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     4ce:	8e 89       	ldd	r24, Y+22	; 0x16
     4d0:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     4d4:	98 17       	cp	r25, r24
     4d6:	10 f4       	brcc	.+4      	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
     4d8:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     4dc:	f9 e0       	ldi	r31, 0x09	; 9
     4de:	8f 9f       	mul	r24, r31
     4e0:	c0 01       	movw	r24, r0
     4e2:	11 24       	eor	r1, r1
     4e4:	b6 01       	movw	r22, r12
     4e6:	80 58       	subi	r24, 0x80	; 128
     4e8:	9e 4f       	sbci	r25, 0xFE	; 254
     4ea:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     4ee:	0f 90       	pop	r0
     4f0:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     4f2:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     4f6:	88 23       	and	r24, r24
     4f8:	51 f0       	breq	.+20     	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     4fa:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     4fe:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     502:	96 89       	ldd	r25, Z+22	; 0x16
     504:	8e 89       	ldd	r24, Y+22	; 0x16
     506:	98 17       	cp	r25, r24
     508:	10 f4       	brcc	.+4      	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
		{
			taskYIELD_IF_USING_PREEMPTION();
     50a:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     50e:	81 e0       	ldi	r24, 0x01	; 1
     510:	01 c0       	rjmp	.+2      	; 0x514 <__LOCK_REGION_LENGTH__+0x114>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     512:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     514:	df 91       	pop	r29
     516:	cf 91       	pop	r28
     518:	1f 91       	pop	r17
     51a:	0f 91       	pop	r16
     51c:	ff 90       	pop	r15
     51e:	ef 90       	pop	r14
     520:	df 90       	pop	r13
     522:	cf 90       	pop	r12
     524:	bf 90       	pop	r11
     526:	af 90       	pop	r10
     528:	9f 90       	pop	r9
     52a:	8f 90       	pop	r8
     52c:	7f 90       	pop	r7
     52e:	6f 90       	pop	r6
     530:	5f 90       	pop	r5
     532:	4f 90       	pop	r4
     534:	3f 90       	pop	r3
     536:	08 95       	ret

00000538 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	cf 93       	push	r28
     53e:	df 93       	push	r29
     540:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     542:	0f b6       	in	r0, 0x3f	; 63
     544:	f8 94       	cli
     546:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     548:	89 2b       	or	r24, r25
     54a:	21 f4       	brne	.+8      	; 0x554 <vTaskDelete+0x1c>
     54c:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <__data_end>
     550:	d0 91 3f 01 	lds	r29, 0x013F	; 0x80013f <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     554:	8e 01       	movw	r16, r28
     556:	0e 5f       	subi	r16, 0xFE	; 254
     558:	1f 4f       	sbci	r17, 0xFF	; 255
     55a:	c8 01       	movw	r24, r16
     55c:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     560:	8c 89       	ldd	r24, Y+20	; 0x14
     562:	9d 89       	ldd	r25, Y+21	; 0x15
     564:	89 2b       	or	r24, r25
     566:	21 f0       	breq	.+8      	; 0x570 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     568:	ce 01       	movw	r24, r28
     56a:	0c 96       	adiw	r24, 0x0c	; 12
     56c:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     570:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <uxTaskNumber>
     574:	8f 5f       	subi	r24, 0xFF	; 255
     576:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     57a:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     57e:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     582:	c8 17       	cp	r28, r24
     584:	d9 07       	cpc	r29, r25
     586:	59 f4       	brne	.+22     	; 0x59e <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     588:	b8 01       	movw	r22, r16
     58a:	88 e5       	ldi	r24, 0x58	; 88
     58c:	91 e0       	ldi	r25, 0x01	; 1
     58e:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     592:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     596:	8f 5f       	subi	r24, 0xFF	; 255
     598:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     59c:	0e c0       	rjmp	.+28     	; 0x5ba <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     59e:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     5a2:	81 50       	subi	r24, 0x01	; 1
     5a4:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     5a8:	8f 89       	ldd	r24, Y+23	; 0x17
     5aa:	98 8d       	ldd	r25, Y+24	; 0x18
     5ac:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vPortFree>
			vPortFree( pxTCB );
     5b0:	ce 01       	movw	r24, r28
     5b2:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     5b6:	0e 94 f6 00 	call	0x1ec	; 0x1ec <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     5be:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     5c2:	88 23       	and	r24, r24
     5c4:	49 f0       	breq	.+18     	; 0x5d8 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     5c6:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     5ca:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     5ce:	c8 17       	cp	r28, r24
     5d0:	d9 07       	cpc	r29, r25
     5d2:	11 f4       	brne	.+4      	; 0x5d8 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     5d4:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     5d8:	df 91       	pop	r29
     5da:	cf 91       	pop	r28
     5dc:	1f 91       	pop	r17
     5de:	0f 91       	pop	r16
     5e0:	08 95       	ret

000005e2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     5e2:	0f 93       	push	r16
     5e4:	1f 93       	push	r17
     5e6:	cf 93       	push	r28
     5e8:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     5ea:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <__data_end>
     5ee:	30 91 3f 01 	lds	r19, 0x013F	; 0x80013f <__data_end+0x1>
     5f2:	82 17       	cp	r24, r18
     5f4:	93 07       	cpc	r25, r19
     5f6:	b9 f1       	breq	.+110    	; 0x666 <vTaskResume+0x84>
     5f8:	00 97       	sbiw	r24, 0x00	; 0
     5fa:	a9 f1       	breq	.+106    	; 0x666 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     5fc:	0f b6       	in	r0, 0x3f	; 63
     5fe:	f8 94       	cli
     600:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     602:	fc 01       	movw	r30, r24
     604:	22 85       	ldd	r18, Z+10	; 0x0a
     606:	33 85       	ldd	r19, Z+11	; 0x0b
     608:	2e 54       	subi	r18, 0x4E	; 78
     60a:	31 40       	sbci	r19, 0x01	; 1
     60c:	51 f5       	brne	.+84     	; 0x662 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     60e:	fc 01       	movw	r30, r24
     610:	24 89       	ldd	r18, Z+20	; 0x14
     612:	35 89       	ldd	r19, Z+21	; 0x15
     614:	f1 e0       	ldi	r31, 0x01	; 1
     616:	21 36       	cpi	r18, 0x61	; 97
     618:	3f 07       	cpc	r19, r31
     61a:	19 f1       	breq	.+70     	; 0x662 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     61c:	23 2b       	or	r18, r19
     61e:	09 f5       	brne	.+66     	; 0x662 <vTaskResume+0x80>
     620:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     622:	8c 01       	movw	r16, r24
     624:	0e 5f       	subi	r16, 0xFE	; 254
     626:	1f 4f       	sbci	r17, 0xFF	; 255
     628:	c8 01       	movw	r24, r16
     62a:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     62e:	8e 89       	ldd	r24, Y+22	; 0x16
     630:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     634:	98 17       	cp	r25, r24
     636:	10 f4       	brcc	.+4      	; 0x63c <vTaskResume+0x5a>
     638:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     63c:	29 e0       	ldi	r18, 0x09	; 9
     63e:	82 9f       	mul	r24, r18
     640:	c0 01       	movw	r24, r0
     642:	11 24       	eor	r1, r1
     644:	b8 01       	movw	r22, r16
     646:	80 58       	subi	r24, 0x80	; 128
     648:	9e 4f       	sbci	r25, 0xFE	; 254
     64a:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     64e:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     652:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     656:	9e 89       	ldd	r25, Y+22	; 0x16
     658:	86 89       	ldd	r24, Z+22	; 0x16
     65a:	98 17       	cp	r25, r24
     65c:	10 f0       	brcs	.+4      	; 0x662 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     65e:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     662:	0f 90       	pop	r0
     664:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	08 95       	ret

00000670 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     670:	ef 92       	push	r14
     672:	ff 92       	push	r15
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     67c:	8a 85       	ldd	r24, Y+10	; 0x0a
     67e:	9b 85       	ldd	r25, Y+11	; 0x0b
     680:	8e 54       	subi	r24, 0x4E	; 78
     682:	91 40       	sbci	r25, 0x01	; 1
     684:	99 f4       	brne	.+38     	; 0x6ac <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     686:	8c 89       	ldd	r24, Y+20	; 0x14
     688:	9d 89       	ldd	r25, Y+21	; 0x15
     68a:	21 e0       	ldi	r18, 0x01	; 1
     68c:	81 36       	cpi	r24, 0x61	; 97
     68e:	92 07       	cpc	r25, r18
     690:	69 f0       	breq	.+26     	; 0x6ac <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     692:	89 2b       	or	r24, r25
     694:	59 f4       	brne	.+22     	; 0x6ac <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     696:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     69a:	88 23       	and	r24, r24
     69c:	49 f0       	breq	.+18     	; 0x6b0 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     69e:	be 01       	movw	r22, r28
     6a0:	64 5f       	subi	r22, 0xF4	; 244
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	81 e6       	ldi	r24, 0x61	; 97
     6a6:	91 e0       	ldi	r25, 0x01	; 1
     6a8:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     6ac:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     6ae:	21 c0       	rjmp	.+66     	; 0x6f2 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     6b0:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     6b4:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     6b8:	11 e0       	ldi	r17, 0x01	; 1
     6ba:	9e 89       	ldd	r25, Y+22	; 0x16
     6bc:	86 89       	ldd	r24, Z+22	; 0x16
     6be:	98 17       	cp	r25, r24
     6c0:	08 f4       	brcc	.+2      	; 0x6c4 <xTaskResumeFromISR+0x54>
     6c2:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     6c4:	7e 01       	movw	r14, r28
     6c6:	82 e0       	ldi	r24, 0x02	; 2
     6c8:	e8 0e       	add	r14, r24
     6ca:	f1 1c       	adc	r15, r1
     6cc:	c7 01       	movw	r24, r14
     6ce:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6d2:	8e 89       	ldd	r24, Y+22	; 0x16
     6d4:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     6d8:	98 17       	cp	r25, r24
     6da:	10 f4       	brcc	.+4      	; 0x6e0 <xTaskResumeFromISR+0x70>
     6dc:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     6e0:	29 e0       	ldi	r18, 0x09	; 9
     6e2:	82 9f       	mul	r24, r18
     6e4:	c0 01       	movw	r24, r0
     6e6:	11 24       	eor	r1, r1
     6e8:	b7 01       	movw	r22, r14
     6ea:	80 58       	subi	r24, 0x80	; 128
     6ec:	9e 4f       	sbci	r25, 0xFE	; 254
     6ee:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     6f2:	81 2f       	mov	r24, r17
     6f4:	df 91       	pop	r29
     6f6:	cf 91       	pop	r28
     6f8:	1f 91       	pop	r17
     6fa:	ff 90       	pop	r15
     6fc:	ef 90       	pop	r14
     6fe:	08 95       	ret

00000700 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     700:	ef 92       	push	r14
     702:	ff 92       	push	r15
     704:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     706:	81 e4       	ldi	r24, 0x41	; 65
     708:	e8 2e       	mov	r14, r24
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	f8 2e       	mov	r15, r24
     70e:	00 e0       	ldi	r16, 0x00	; 0
     710:	20 e0       	ldi	r18, 0x00	; 0
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	45 e5       	ldi	r20, 0x55	; 85
     716:	50 e0       	ldi	r21, 0x00	; 0
     718:	68 e3       	ldi	r22, 0x38	; 56
     71a:	71 e0       	ldi	r23, 0x01	; 1
     71c:	8d e6       	ldi	r24, 0x6D	; 109
     71e:	91 e0       	ldi	r25, 0x01	; 1
     720:	0e 94 9b 01 	call	0x336	; 0x336 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     724:	81 30       	cpi	r24, 0x01	; 1
     726:	91 f4       	brne	.+36     	; 0x74c <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     728:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     72a:	2f ef       	ldi	r18, 0xFF	; 255
     72c:	3f ef       	ldi	r19, 0xFF	; 255
     72e:	30 93 44 01 	sts	0x0144, r19	; 0x800144 <xNextTaskUnblockTime+0x1>
     732:	20 93 43 01 	sts	0x0143, r18	; 0x800143 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     736:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     73a:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <xTickCount+0x1>
     73e:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     742:	0f 91       	pop	r16
     744:	ff 90       	pop	r15
     746:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     748:	0c 94 e4 10 	jmp	0x21c8	; 0x21c8 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     74c:	0f 91       	pop	r16
     74e:	ff 90       	pop	r15
     750:	ef 90       	pop	r14
     752:	08 95       	ret

00000754 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     754:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     756:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <xSchedulerRunning>
	vPortEndScheduler();
     75a:	0c 94 24 11 	jmp	0x2248	; 0x2248 <vPortEndScheduler>

0000075e <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     75e:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     762:	8f 5f       	subi	r24, 0xFF	; 255
     764:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxSchedulerSuspended>
     768:	08 95       	ret

0000076a <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     76a:	0f b6       	in	r0, 0x3f	; 63
     76c:	f8 94       	cli
     76e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     770:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <xTickCount>
     774:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     778:	0f 90       	pop	r0
     77a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     77c:	08 95       	ret

0000077e <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     77e:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <xTickCount>
     782:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     786:	08 95       	ret

00000788 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     788:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
}
     78c:	08 95       	ret

0000078e <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     78e:	00 97       	sbiw	r24, 0x00	; 0
     790:	21 f4       	brne	.+8      	; 0x79a <pcTaskGetName+0xc>
     792:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     796:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     79a:	49 96       	adiw	r24, 0x19	; 25
     79c:	08 95       	ret

0000079e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     79e:	cf 92       	push	r12
     7a0:	df 92       	push	r13
     7a2:	ef 92       	push	r14
     7a4:	ff 92       	push	r15
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     7ae:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     7b2:	81 11       	cpse	r24, r1
     7b4:	8c c0       	rjmp	.+280    	; 0x8ce <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     7b6:	00 91 4b 01 	lds	r16, 0x014B	; 0x80014b <xTickCount>
     7ba:	10 91 4c 01 	lds	r17, 0x014C	; 0x80014c <xTickCount+0x1>
     7be:	0f 5f       	subi	r16, 0xFF	; 255
     7c0:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     7c2:	10 93 4c 01 	sts	0x014C, r17	; 0x80014c <xTickCount+0x1>
     7c6:	00 93 4b 01 	sts	0x014B, r16	; 0x80014b <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     7ca:	01 15       	cp	r16, r1
     7cc:	11 05       	cpc	r17, r1
     7ce:	b9 f4       	brne	.+46     	; 0x7fe <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     7d0:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <pxDelayedTaskList>
     7d4:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     7d8:	20 91 6a 01 	lds	r18, 0x016A	; 0x80016a <pxOverflowDelayedTaskList>
     7dc:	30 91 6b 01 	lds	r19, 0x016B	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     7e0:	30 93 6d 01 	sts	0x016D, r19	; 0x80016d <pxDelayedTaskList+0x1>
     7e4:	20 93 6c 01 	sts	0x016C, r18	; 0x80016c <pxDelayedTaskList>
     7e8:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     7ec:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <pxOverflowDelayedTaskList>
     7f0:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <xNumOfOverflows>
     7f4:	8f 5f       	subi	r24, 0xFF	; 255
     7f6:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <xNumOfOverflows>
     7fa:	0e 94 f6 00 	call	0x1ec	; 0x1ec <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     7fe:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xNextTaskUnblockTime>
     802:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <xNextTaskUnblockTime+0x1>
     806:	c0 e0       	ldi	r28, 0x00	; 0
     808:	08 17       	cp	r16, r24
     80a:	19 07       	cpc	r17, r25
     80c:	08 f4       	brcc	.+2      	; 0x810 <xTaskIncrementTick+0x72>
     80e:	4f c0       	rjmp	.+158    	; 0x8ae <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     810:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     812:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     816:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     81a:	80 81       	ld	r24, Z
     81c:	81 11       	cpse	r24, r1
     81e:	03 c0       	rjmp	.+6      	; 0x826 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     820:	8f ef       	ldi	r24, 0xFF	; 255
     822:	9f ef       	ldi	r25, 0xFF	; 255
     824:	11 c0       	rjmp	.+34     	; 0x848 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     826:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     82a:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     82e:	05 80       	ldd	r0, Z+5	; 0x05
     830:	f6 81       	ldd	r31, Z+6	; 0x06
     832:	e0 2d       	mov	r30, r0
     834:	e6 80       	ldd	r14, Z+6	; 0x06
     836:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     838:	d7 01       	movw	r26, r14
     83a:	12 96       	adiw	r26, 0x02	; 2
     83c:	8d 91       	ld	r24, X+
     83e:	9c 91       	ld	r25, X
     840:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     842:	08 17       	cp	r16, r24
     844:	19 07       	cpc	r17, r25
     846:	28 f4       	brcc	.+10     	; 0x852 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     848:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
     84c:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     850:	2e c0       	rjmp	.+92     	; 0x8ae <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     852:	67 01       	movw	r12, r14
     854:	b2 e0       	ldi	r27, 0x02	; 2
     856:	cb 0e       	add	r12, r27
     858:	d1 1c       	adc	r13, r1
     85a:	c6 01       	movw	r24, r12
     85c:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     860:	f7 01       	movw	r30, r14
     862:	84 89       	ldd	r24, Z+20	; 0x14
     864:	95 89       	ldd	r25, Z+21	; 0x15
     866:	89 2b       	or	r24, r25
     868:	21 f0       	breq	.+8      	; 0x872 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     86a:	c7 01       	movw	r24, r14
     86c:	0c 96       	adiw	r24, 0x0c	; 12
     86e:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     872:	d7 01       	movw	r26, r14
     874:	56 96       	adiw	r26, 0x16	; 22
     876:	8c 91       	ld	r24, X
     878:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     87c:	98 17       	cp	r25, r24
     87e:	10 f4       	brcc	.+4      	; 0x884 <xTaskIncrementTick+0xe6>
     880:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     884:	d8 9f       	mul	r29, r24
     886:	c0 01       	movw	r24, r0
     888:	11 24       	eor	r1, r1
     88a:	b6 01       	movw	r22, r12
     88c:	80 58       	subi	r24, 0x80	; 128
     88e:	9e 4f       	sbci	r25, 0xFE	; 254
     890:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     894:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     898:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     89c:	d7 01       	movw	r26, r14
     89e:	56 96       	adiw	r26, 0x16	; 22
     8a0:	9c 91       	ld	r25, X
     8a2:	86 89       	ldd	r24, Z+22	; 0x16
     8a4:	98 17       	cp	r25, r24
     8a6:	08 f4       	brcc	.+2      	; 0x8aa <xTaskIncrementTick+0x10c>
     8a8:	b4 cf       	rjmp	.-152    	; 0x812 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     8aa:	c1 e0       	ldi	r28, 0x01	; 1
     8ac:	b2 cf       	rjmp	.-156    	; 0x812 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     8ae:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     8b2:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     8b6:	e6 89       	ldd	r30, Z+22	; 0x16
     8b8:	b9 e0       	ldi	r27, 0x09	; 9
     8ba:	eb 9f       	mul	r30, r27
     8bc:	f0 01       	movw	r30, r0
     8be:	11 24       	eor	r1, r1
     8c0:	e0 58       	subi	r30, 0x80	; 128
     8c2:	fe 4f       	sbci	r31, 0xFE	; 254
     8c4:	80 81       	ld	r24, Z
     8c6:	82 30       	cpi	r24, 0x02	; 2
     8c8:	40 f0       	brcs	.+16     	; 0x8da <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     8ca:	c1 e0       	ldi	r28, 0x01	; 1
     8cc:	06 c0       	rjmp	.+12     	; 0x8da <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     8ce:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <uxPendedTicks>
     8d2:	8f 5f       	subi	r24, 0xFF	; 255
     8d4:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     8d8:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     8da:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <xYieldPending>
     8de:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     8e0:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     8e2:	8c 2f       	mov	r24, r28
     8e4:	df 91       	pop	r29
     8e6:	cf 91       	pop	r28
     8e8:	1f 91       	pop	r17
     8ea:	0f 91       	pop	r16
     8ec:	ff 90       	pop	r15
     8ee:	ef 90       	pop	r14
     8f0:	df 90       	pop	r13
     8f2:	cf 90       	pop	r12
     8f4:	08 95       	ret

000008f6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	1f 93       	push	r17
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     902:	0f b6       	in	r0, 0x3f	; 63
     904:	f8 94       	cli
     906:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     908:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     90c:	81 50       	subi	r24, 0x01	; 1
     90e:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     912:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     916:	88 23       	and	r24, r24
     918:	11 f0       	breq	.+4      	; 0x91e <__stack+0x1f>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     91a:	80 e0       	ldi	r24, 0x00	; 0
     91c:	52 c0       	rjmp	.+164    	; 0x9c2 <__stack+0xc3>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     91e:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     922:	88 23       	and	r24, r24
     924:	d1 f3       	breq	.-12     	; 0x91a <__stack+0x1b>
     926:	c0 e0       	ldi	r28, 0x00	; 0
     928:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     92a:	89 e0       	ldi	r24, 0x09	; 9
     92c:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     92e:	ee 24       	eor	r14, r14
     930:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     932:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <xPendingReadyList>
     936:	88 23       	and	r24, r24
     938:	51 f1       	breq	.+84     	; 0x98e <__stack+0x8f>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     93a:	e0 91 66 01 	lds	r30, 0x0166	; 0x800166 <xPendingReadyList+0x5>
     93e:	f0 91 67 01 	lds	r31, 0x0167	; 0x800167 <xPendingReadyList+0x6>
     942:	c6 81       	ldd	r28, Z+6	; 0x06
     944:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     946:	ce 01       	movw	r24, r28
     948:	0c 96       	adiw	r24, 0x0c	; 12
     94a:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     94e:	8e 01       	movw	r16, r28
     950:	0e 5f       	subi	r16, 0xFE	; 254
     952:	1f 4f       	sbci	r17, 0xFF	; 255
     954:	c8 01       	movw	r24, r16
     956:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     95a:	8e 89       	ldd	r24, Y+22	; 0x16
     95c:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     960:	98 17       	cp	r25, r24
     962:	10 f4       	brcc	.+4      	; 0x968 <__stack+0x69>
     964:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     968:	f8 9e       	mul	r15, r24
     96a:	c0 01       	movw	r24, r0
     96c:	11 24       	eor	r1, r1
     96e:	b8 01       	movw	r22, r16
     970:	80 58       	subi	r24, 0x80	; 128
     972:	9e 4f       	sbci	r25, 0xFE	; 254
     974:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     978:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     97c:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     980:	9e 89       	ldd	r25, Y+22	; 0x16
     982:	86 89       	ldd	r24, Z+22	; 0x16
     984:	98 17       	cp	r25, r24
     986:	a8 f2       	brcs	.-86     	; 0x932 <__stack+0x33>
					{
						xYieldPending = pdTRUE;
     988:	e0 92 47 01 	sts	0x0147, r14	; 0x800147 <xYieldPending>
     98c:	d2 cf       	rjmp	.-92     	; 0x932 <__stack+0x33>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     98e:	cd 2b       	or	r28, r29
     990:	11 f0       	breq	.+4      	; 0x996 <__stack+0x97>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     992:	0e 94 f6 00 	call	0x1ec	; 0x1ec <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     996:	c0 91 48 01 	lds	r28, 0x0148	; 0x800148 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     99a:	cc 23       	and	r28, r28
     99c:	51 f0       	breq	.+20     	; 0x9b2 <__stack+0xb3>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     99e:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     9a0:	0e 94 cf 03 	call	0x79e	; 0x79e <xTaskIncrementTick>
     9a4:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     9a6:	d0 93 47 01 	sts	0x0147, r29	; 0x800147 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     9aa:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     9ac:	c9 f7       	brne	.-14     	; 0x9a0 <__stack+0xa1>

						uxPendedTicks = 0;
     9ae:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     9b2:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <xYieldPending>
     9b6:	88 23       	and	r24, r24
     9b8:	09 f4       	brne	.+2      	; 0x9bc <__stack+0xbd>
     9ba:	af cf       	rjmp	.-162    	; 0x91a <__stack+0x1b>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     9bc:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     9c0:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     9c2:	0f 90       	pop	r0
     9c4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     9c6:	df 91       	pop	r29
     9c8:	cf 91       	pop	r28
     9ca:	1f 91       	pop	r17
     9cc:	0f 91       	pop	r16
     9ce:	ff 90       	pop	r15
     9d0:	ef 90       	pop	r14
     9d2:	08 95       	ret

000009d4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     9d4:	0f 93       	push	r16
     9d6:	1f 93       	push	r17
     9d8:	cf 93       	push	r28
     9da:	df 93       	push	r29
     9dc:	8c 01       	movw	r16, r24
     9de:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     9e0:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     9e4:	40 91 4b 01 	lds	r20, 0x014B	; 0x80014b <xTickCount>
     9e8:	50 91 4c 01 	lds	r21, 0x014C	; 0x80014c <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     9ec:	f8 01       	movw	r30, r16
     9ee:	20 81       	ld	r18, Z
     9f0:	31 81       	ldd	r19, Z+1	; 0x01
     9f2:	c9 01       	movw	r24, r18
     9f4:	8c 0f       	add	r24, r28
     9f6:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     9f8:	42 17       	cp	r20, r18
     9fa:	53 07       	cpc	r21, r19
     9fc:	20 f4       	brcc	.+8      	; 0xa06 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     9fe:	82 17       	cp	r24, r18
     a00:	93 07       	cpc	r25, r19
     a02:	40 f4       	brcc	.+16     	; 0xa14 <vTaskDelayUntil+0x40>
     a04:	03 c0       	rjmp	.+6      	; 0xa0c <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     a06:	82 17       	cp	r24, r18
     a08:	93 07       	cpc	r25, r19
     a0a:	30 f0       	brcs	.+12     	; 0xa18 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     a0c:	21 e0       	ldi	r18, 0x01	; 1
     a0e:	48 17       	cp	r20, r24
     a10:	59 07       	cpc	r21, r25
     a12:	18 f0       	brcs	.+6      	; 0xa1a <vTaskDelayUntil+0x46>
     a14:	20 e0       	ldi	r18, 0x00	; 0
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     a18:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     a1a:	f8 01       	movw	r30, r16
     a1c:	91 83       	std	Z+1, r25	; 0x01
     a1e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     a20:	22 23       	and	r18, r18
     a22:	29 f0       	breq	.+10     	; 0xa2e <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	84 1b       	sub	r24, r20
     a28:	95 0b       	sbc	r25, r21
     a2a:	0e 94 11 01 	call	0x222	; 0x222 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a2e:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a32:	81 11       	cpse	r24, r1
     a34:	02 c0       	rjmp	.+4      	; 0xa3a <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a36:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	0f 91       	pop	r16
     a42:	08 95       	ret

00000a44 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     a4a:	89 2b       	or	r24, r25
     a4c:	19 f4       	brne	.+6      	; 0xa54 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     a4e:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
     a52:	0a c0       	rjmp	.+20     	; 0xa68 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     a54:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     a58:	60 e0       	ldi	r22, 0x00	; 0
     a5a:	ce 01       	movw	r24, r28
     a5c:	0e 94 11 01 	call	0x222	; 0x222 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a60:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a64:	88 23       	and	r24, r24
     a66:	99 f3       	breq	.-26     	; 0xa4e <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	08 95       	ret

00000a6e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a6e:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     a72:	88 23       	and	r24, r24
     a74:	21 f0       	breq	.+8      	; 0xa7e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a76:	81 e0       	ldi	r24, 0x01	; 1
     a78:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
     a7c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a7e:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a82:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <uxTopReadyPriority>
     a86:	69 e0       	ldi	r22, 0x09	; 9
     a88:	48 2f       	mov	r20, r24
     a8a:	50 e0       	ldi	r21, 0x00	; 0
     a8c:	64 9f       	mul	r22, r20
     a8e:	90 01       	movw	r18, r0
     a90:	65 9f       	mul	r22, r21
     a92:	30 0d       	add	r19, r0
     a94:	11 24       	eor	r1, r1
     a96:	f9 01       	movw	r30, r18
     a98:	e0 58       	subi	r30, 0x80	; 128
     a9a:	fe 4f       	sbci	r31, 0xFE	; 254
     a9c:	90 81       	ld	r25, Z
     a9e:	91 11       	cpse	r25, r1
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <vTaskSwitchContext+0x38>
     aa2:	81 50       	subi	r24, 0x01	; 1
     aa4:	f1 cf       	rjmp	.-30     	; 0xa88 <vTaskSwitchContext+0x1a>
     aa6:	a1 81       	ldd	r26, Z+1	; 0x01
     aa8:	b2 81       	ldd	r27, Z+2	; 0x02
     aaa:	12 96       	adiw	r26, 0x02	; 2
     aac:	0d 90       	ld	r0, X+
     aae:	bc 91       	ld	r27, X
     ab0:	a0 2d       	mov	r26, r0
     ab2:	b2 83       	std	Z+2, r27	; 0x02
     ab4:	a1 83       	std	Z+1, r26	; 0x01
     ab6:	2d 57       	subi	r18, 0x7D	; 125
     ab8:	3e 4f       	sbci	r19, 0xFE	; 254
     aba:	a2 17       	cp	r26, r18
     abc:	b3 07       	cpc	r27, r19
     abe:	31 f4       	brne	.+12     	; 0xacc <vTaskSwitchContext+0x5e>
     ac0:	12 96       	adiw	r26, 0x02	; 2
     ac2:	2d 91       	ld	r18, X+
     ac4:	3c 91       	ld	r19, X
     ac6:	13 97       	sbiw	r26, 0x03	; 3
     ac8:	32 83       	std	Z+2, r19	; 0x02
     aca:	21 83       	std	Z+1, r18	; 0x01
     acc:	99 e0       	ldi	r25, 0x09	; 9
     ace:	94 9f       	mul	r25, r20
     ad0:	f0 01       	movw	r30, r0
     ad2:	95 9f       	mul	r25, r21
     ad4:	f0 0d       	add	r31, r0
     ad6:	11 24       	eor	r1, r1
     ad8:	e0 58       	subi	r30, 0x80	; 128
     ada:	fe 4f       	sbci	r31, 0xFE	; 254
     adc:	01 80       	ldd	r0, Z+1	; 0x01
     ade:	f2 81       	ldd	r31, Z+2	; 0x02
     ae0:	e0 2d       	mov	r30, r0
     ae2:	26 81       	ldd	r18, Z+6	; 0x06
     ae4:	37 81       	ldd	r19, Z+7	; 0x07
     ae6:	30 93 3f 01 	sts	0x013F, r19	; 0x80013f <__data_end+0x1>
     aea:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <__data_end>
     aee:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     af2:	08 95       	ret

00000af4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
     afc:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     afe:	0f b6       	in	r0, 0x3f	; 63
     b00:	f8 94       	cli
     b02:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     b04:	89 2b       	or	r24, r25
     b06:	21 f4       	brne	.+8      	; 0xb10 <vTaskSuspend+0x1c>
     b08:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <__data_end>
     b0c:	d0 91 3f 01 	lds	r29, 0x013F	; 0x80013f <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     b10:	8e 01       	movw	r16, r28
     b12:	0e 5f       	subi	r16, 0xFE	; 254
     b14:	1f 4f       	sbci	r17, 0xFF	; 255
     b16:	c8 01       	movw	r24, r16
     b18:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b1c:	8c 89       	ldd	r24, Y+20	; 0x14
     b1e:	9d 89       	ldd	r25, Y+21	; 0x15
     b20:	89 2b       	or	r24, r25
     b22:	21 f0       	breq	.+8      	; 0xb2c <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b24:	ce 01       	movw	r24, r28
     b26:	0c 96       	adiw	r24, 0x0c	; 12
     b28:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     b2c:	b8 01       	movw	r22, r16
     b2e:	8e e4       	ldi	r24, 0x4E	; 78
     b30:	91 e0       	ldi	r25, 0x01	; 1
     b32:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b36:	8d a1       	ldd	r24, Y+37	; 0x25
     b38:	81 30       	cpi	r24, 0x01	; 1
     b3a:	09 f4       	brne	.+2      	; 0xb3e <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b3c:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b42:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     b46:	88 23       	and	r24, r24
     b48:	39 f0       	breq	.+14     	; 0xb58 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	f8 94       	cli
     b4e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     b50:	0e 94 f6 00 	call	0x1ec	; 0x1ec <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     b54:	0f 90       	pop	r0
     b56:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     b58:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     b5c:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     b60:	c8 17       	cp	r28, r24
     b62:	d9 07       	cpc	r29, r25
     b64:	c1 f4       	brne	.+48     	; 0xb96 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b66:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     b6a:	88 23       	and	r24, r24
     b6c:	19 f0       	breq	.+6      	; 0xb74 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b6e:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
     b72:	11 c0       	rjmp	.+34     	; 0xb96 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b74:	90 91 4e 01 	lds	r25, 0x014E	; 0x80014e <xSuspendedTaskList>
     b78:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     b7c:	98 13       	cpse	r25, r24
     b7e:	05 c0       	rjmp	.+10     	; 0xb8a <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b80:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <__data_end+0x1>
     b84:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <__data_end>
     b88:	06 c0       	rjmp	.+12     	; 0xb96 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b8a:	df 91       	pop	r29
     b8c:	cf 91       	pop	r28
     b8e:	1f 91       	pop	r17
     b90:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b92:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	08 95       	ret

00000ba0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     ba0:	cf 93       	push	r28
     ba2:	df 93       	push	r29
     ba4:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ba6:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     baa:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
     bae:	64 5f       	subi	r22, 0xF4	; 244
     bb0:	7f 4f       	sbci	r23, 0xFF	; 255
     bb2:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bb6:	61 e0       	ldi	r22, 0x01	; 1
     bb8:	ce 01       	movw	r24, r28
}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bbe:	0c 94 11 01 	jmp	0x222	; 0x222 <prvAddCurrentTaskToDelayedList>

00000bc2 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     bc2:	cf 93       	push	r28
     bc4:	df 93       	push	r29
     bc6:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     bc8:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     bcc:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     bd0:	70 68       	ori	r23, 0x80	; 128
     bd2:	75 87       	std	Z+13, r23	; 0x0d
     bd4:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     bd6:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     bda:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
     bde:	64 5f       	subi	r22, 0xF4	; 244
     be0:	7f 4f       	sbci	r23, 0xFF	; 255
     be2:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     be6:	61 e0       	ldi	r22, 0x01	; 1
     be8:	ce 01       	movw	r24, r28
}
     bea:	df 91       	pop	r29
     bec:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bee:	0c 94 11 01 	jmp	0x222	; 0x222 <prvAddCurrentTaskToDelayedList>

00000bf2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     bfa:	dc 01       	movw	r26, r24
     bfc:	15 96       	adiw	r26, 0x05	; 5
     bfe:	ed 91       	ld	r30, X+
     c00:	fc 91       	ld	r31, X
     c02:	16 97       	sbiw	r26, 0x06	; 6
     c04:	c6 81       	ldd	r28, Z+6	; 0x06
     c06:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c08:	8e 01       	movw	r16, r28
     c0a:	04 5f       	subi	r16, 0xF4	; 244
     c0c:	1f 4f       	sbci	r17, 0xFF	; 255
     c0e:	c8 01       	movw	r24, r16
     c10:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c14:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     c18:	81 11       	cpse	r24, r1
     c1a:	14 c0       	rjmp	.+40     	; 0xc44 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c1c:	0a 50       	subi	r16, 0x0A	; 10
     c1e:	11 09       	sbc	r17, r1
     c20:	c8 01       	movw	r24, r16
     c22:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c26:	8e 89       	ldd	r24, Y+22	; 0x16
     c28:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     c2c:	98 17       	cp	r25, r24
     c2e:	10 f4       	brcc	.+4      	; 0xc34 <xTaskRemoveFromEventList+0x42>
     c30:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     c34:	b9 e0       	ldi	r27, 0x09	; 9
     c36:	8b 9f       	mul	r24, r27
     c38:	c0 01       	movw	r24, r0
     c3a:	11 24       	eor	r1, r1
     c3c:	b8 01       	movw	r22, r16
     c3e:	80 58       	subi	r24, 0x80	; 128
     c40:	9e 4f       	sbci	r25, 0xFE	; 254
     c42:	03 c0       	rjmp	.+6      	; 0xc4a <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c44:	b8 01       	movw	r22, r16
     c46:	81 e6       	ldi	r24, 0x61	; 97
     c48:	91 e0       	ldi	r25, 0x01	; 1
     c4a:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c4e:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     c52:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     c56:	9e 89       	ldd	r25, Y+22	; 0x16
     c58:	86 89       	ldd	r24, Z+22	; 0x16
     c5a:	89 17       	cp	r24, r25
     c5c:	20 f4       	brcc	.+8      	; 0xc66 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
     c64:	01 c0       	rjmp	.+2      	; 0xc68 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c66:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c68:	df 91       	pop	r29
     c6a:	cf 91       	pop	r28
     c6c:	1f 91       	pop	r17
     c6e:	0f 91       	pop	r16
     c70:	08 95       	ret

00000c72 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c72:	0f 93       	push	r16
     c74:	1f 93       	push	r17
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c7a:	70 68       	ori	r23, 0x80	; 128
     c7c:	fc 01       	movw	r30, r24
     c7e:	71 83       	std	Z+1, r23	; 0x01
     c80:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c82:	c6 81       	ldd	r28, Z+6	; 0x06
     c84:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c86:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c8a:	8e 01       	movw	r16, r28
     c8c:	0e 5f       	subi	r16, 0xFE	; 254
     c8e:	1f 4f       	sbci	r17, 0xFF	; 255
     c90:	c8 01       	movw	r24, r16
     c92:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c96:	8e 89       	ldd	r24, Y+22	; 0x16
     c98:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     c9c:	98 17       	cp	r25, r24
     c9e:	10 f4       	brcc	.+4      	; 0xca4 <vTaskRemoveFromUnorderedEventList+0x32>
     ca0:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     ca4:	f9 e0       	ldi	r31, 0x09	; 9
     ca6:	8f 9f       	mul	r24, r31
     ca8:	c0 01       	movw	r24, r0
     caa:	11 24       	eor	r1, r1
     cac:	b8 01       	movw	r22, r16
     cae:	80 58       	subi	r24, 0x80	; 128
     cb0:	9e 4f       	sbci	r25, 0xFE	; 254
     cb2:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     cb6:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     cba:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     cbe:	9e 89       	ldd	r25, Y+22	; 0x16
     cc0:	86 89       	ldd	r24, Z+22	; 0x16
     cc2:	89 17       	cp	r24, r25
     cc4:	18 f4       	brcc	.+6      	; 0xccc <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     cc6:	81 e0       	ldi	r24, 0x01	; 1
     cc8:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
	}
}
     ccc:	df 91       	pop	r29
     cce:	cf 91       	pop	r28
     cd0:	1f 91       	pop	r17
     cd2:	0f 91       	pop	r16
     cd4:	08 95       	ret

00000cd6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     cd6:	0f b6       	in	r0, 0x3f	; 63
     cd8:	f8 94       	cli
     cda:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     cdc:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <xNumOfOverflows>
     ce0:	fc 01       	movw	r30, r24
     ce2:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     ce4:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <xTickCount>
     ce8:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <xTickCount+0x1>
     cec:	32 83       	std	Z+2, r19	; 0x02
     cee:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     cf0:	0f 90       	pop	r0
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	08 95       	ret

00000cf6 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     cf6:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <xNumOfOverflows>
     cfa:	fc 01       	movw	r30, r24
     cfc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     cfe:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <xTickCount>
     d02:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <xTickCount+0x1>
     d06:	32 83       	std	Z+2, r19	; 0x02
     d08:	21 83       	std	Z+1, r18	; 0x01
     d0a:	08 95       	ret

00000d0c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     d0c:	cf 93       	push	r28
     d0e:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     d10:	0f b6       	in	r0, 0x3f	; 63
     d12:	f8 94       	cli
     d14:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     d16:	40 91 4b 01 	lds	r20, 0x014B	; 0x80014b <xTickCount>
     d1a:	50 91 4c 01 	lds	r21, 0x014C	; 0x80014c <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     d1e:	db 01       	movw	r26, r22
     d20:	2d 91       	ld	r18, X+
     d22:	3c 91       	ld	r19, X
     d24:	2f 3f       	cpi	r18, 0xFF	; 255
     d26:	bf ef       	ldi	r27, 0xFF	; 255
     d28:	3b 07       	cpc	r19, r27
     d2a:	d9 f0       	breq	.+54     	; 0xd62 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d2c:	ec 01       	movw	r28, r24
     d2e:	e9 81       	ldd	r30, Y+1	; 0x01
     d30:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d32:	a0 91 46 01 	lds	r26, 0x0146	; 0x800146 <xNumOfOverflows>
     d36:	b8 81       	ld	r27, Y
     d38:	ba 17       	cp	r27, r26
     d3a:	19 f0       	breq	.+6      	; 0xd42 <xTaskCheckForTimeOut+0x36>
     d3c:	4e 17       	cp	r20, r30
     d3e:	5f 07       	cpc	r21, r31
     d40:	90 f4       	brcc	.+36     	; 0xd66 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d42:	4e 1b       	sub	r20, r30
     d44:	5f 0b       	sbc	r21, r31
     d46:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     d48:	42 17       	cp	r20, r18
     d4a:	53 07       	cpc	r21, r19
     d4c:	38 f4       	brcc	.+14     	; 0xd5c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     d4e:	24 1b       	sub	r18, r20
     d50:	35 0b       	sbc	r19, r21
     d52:	31 83       	std	Z+1, r19	; 0x01
     d54:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     d56:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <vTaskInternalSetTimeOutState>
     d5a:	03 c0       	rjmp	.+6      	; 0xd62 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     d5c:	11 82       	std	Z+1, r1	; 0x01
     d5e:	10 82       	st	Z, r1
     d60:	02 c0       	rjmp	.+4      	; 0xd66 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     d62:	80 e0       	ldi	r24, 0x00	; 0
     d64:	01 c0       	rjmp	.+2      	; 0xd68 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d66:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d68:	0f 90       	pop	r0
     d6a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	08 95       	ret

00000d72 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d72:	81 e0       	ldi	r24, 0x01	; 1
     d74:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
     d78:	08 95       	ret

00000d7a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d7a:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     d7e:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     d82:	84 85       	ldd	r24, Z+12	; 0x0c
     d84:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d86:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     d8a:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     d8e:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
     d92:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
     d96:	56 96       	adiw	r26, 0x16	; 22
     d98:	4c 91       	ld	r20, X
     d9a:	24 e0       	ldi	r18, 0x04	; 4
     d9c:	30 e0       	ldi	r19, 0x00	; 0
     d9e:	24 1b       	sub	r18, r20
     da0:	31 09       	sbc	r19, r1
     da2:	35 87       	std	Z+13, r19	; 0x0d
     da4:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     da6:	08 95       	ret

00000da8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     da8:	0f 93       	push	r16
     daa:	1f 93       	push	r17
     dac:	18 2f       	mov	r17, r24
     dae:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     db6:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     dba:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     dbe:	41 a1       	ldd	r20, Z+33	; 0x21
     dc0:	52 a1       	ldd	r21, Z+34	; 0x22
     dc2:	63 a1       	ldd	r22, Z+35	; 0x23
     dc4:	74 a1       	ldd	r23, Z+36	; 0x24
     dc6:	45 2b       	or	r20, r21
     dc8:	46 2b       	or	r20, r22
     dca:	47 2b       	or	r20, r23
     dcc:	69 f4       	brne	.+26     	; 0xde8 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     dce:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     dd2:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     dd6:	21 e0       	ldi	r18, 0x01	; 1
     dd8:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     dda:	00 97       	sbiw	r24, 0x00	; 0
     ddc:	29 f0       	breq	.+10     	; 0xde8 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     dde:	61 e0       	ldi	r22, 0x01	; 1
     de0:	0e 94 11 01 	call	0x222	; 0x222 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     de4:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     de8:	0f 90       	pop	r0
     dea:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     dec:	0f b6       	in	r0, 0x3f	; 63
     dee:	f8 94       	cli
     df0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     df2:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     df6:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     dfa:	61 a1       	ldd	r22, Z+33	; 0x21
     dfc:	72 a1       	ldd	r23, Z+34	; 0x22
     dfe:	83 a1       	ldd	r24, Z+35	; 0x23
     e00:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     e02:	61 15       	cp	r22, r1
     e04:	71 05       	cpc	r23, r1
     e06:	81 05       	cpc	r24, r1
     e08:	91 05       	cpc	r25, r1
     e0a:	a9 f0       	breq	.+42     	; 0xe36 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     e0c:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     e10:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     e14:	11 23       	and	r17, r17
     e16:	29 f0       	breq	.+10     	; 0xe22 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     e18:	11 a2       	std	Z+33, r1	; 0x21
     e1a:	12 a2       	std	Z+34, r1	; 0x22
     e1c:	13 a2       	std	Z+35, r1	; 0x23
     e1e:	14 a2       	std	Z+36, r1	; 0x24
     e20:	0a c0       	rjmp	.+20     	; 0xe36 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     e22:	8b 01       	movw	r16, r22
     e24:	9c 01       	movw	r18, r24
     e26:	01 50       	subi	r16, 0x01	; 1
     e28:	11 09       	sbc	r17, r1
     e2a:	21 09       	sbc	r18, r1
     e2c:	31 09       	sbc	r19, r1
     e2e:	01 a3       	std	Z+33, r16	; 0x21
     e30:	12 a3       	std	Z+34, r17	; 0x22
     e32:	23 a3       	std	Z+35, r18	; 0x23
     e34:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e36:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     e3a:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     e3e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     e44:	1f 91       	pop	r17
     e46:	0f 91       	pop	r16
     e48:	08 95       	ret

00000e4a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     e4a:	4f 92       	push	r4
     e4c:	5f 92       	push	r5
     e4e:	6f 92       	push	r6
     e50:	7f 92       	push	r7
     e52:	8f 92       	push	r8
     e54:	9f 92       	push	r9
     e56:	af 92       	push	r10
     e58:	bf 92       	push	r11
     e5a:	ef 92       	push	r14
     e5c:	ff 92       	push	r15
     e5e:	0f 93       	push	r16
     e60:	1f 93       	push	r17
     e62:	49 01       	movw	r8, r18
     e64:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     e66:	0f b6       	in	r0, 0x3f	; 63
     e68:	f8 94       	cli
     e6a:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e6c:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     e70:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     e74:	25 a1       	ldd	r18, Z+37	; 0x25
     e76:	22 30       	cpi	r18, 0x02	; 2
     e78:	39 f1       	breq	.+78     	; 0xec8 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e7a:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     e7e:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     e82:	21 a1       	ldd	r18, Z+33	; 0x21
     e84:	32 a1       	ldd	r19, Z+34	; 0x22
     e86:	43 a1       	ldd	r20, Z+35	; 0x23
     e88:	54 a1       	ldd	r21, Z+36	; 0x24
     e8a:	2b 01       	movw	r4, r22
     e8c:	3c 01       	movw	r6, r24
     e8e:	40 94       	com	r4
     e90:	50 94       	com	r5
     e92:	60 94       	com	r6
     e94:	70 94       	com	r7
     e96:	d3 01       	movw	r26, r6
     e98:	c2 01       	movw	r24, r4
     e9a:	82 23       	and	r24, r18
     e9c:	93 23       	and	r25, r19
     e9e:	a4 23       	and	r26, r20
     ea0:	b5 23       	and	r27, r21
     ea2:	81 a3       	std	Z+33, r24	; 0x21
     ea4:	92 a3       	std	Z+34, r25	; 0x22
     ea6:	a3 a3       	std	Z+35, r26	; 0x23
     ea8:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     eaa:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     eae:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     eb2:	81 e0       	ldi	r24, 0x01	; 1
     eb4:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     eb6:	e1 14       	cp	r14, r1
     eb8:	f1 04       	cpc	r15, r1
     eba:	31 f0       	breq	.+12     	; 0xec8 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ebc:	61 e0       	ldi	r22, 0x01	; 1
     ebe:	c7 01       	movw	r24, r14
     ec0:	0e 94 11 01 	call	0x222	; 0x222 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     ec4:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     ec8:	0f 90       	pop	r0
     eca:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     ecc:	0f b6       	in	r0, 0x3f	; 63
     ece:	f8 94       	cli
     ed0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     ed2:	01 15       	cp	r16, r1
     ed4:	11 05       	cpc	r17, r1
     ed6:	69 f0       	breq	.+26     	; 0xef2 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     ed8:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     edc:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     ee0:	81 a1       	ldd	r24, Z+33	; 0x21
     ee2:	92 a1       	ldd	r25, Z+34	; 0x22
     ee4:	a3 a1       	ldd	r26, Z+35	; 0x23
     ee6:	b4 a1       	ldd	r27, Z+36	; 0x24
     ee8:	f8 01       	movw	r30, r16
     eea:	80 83       	st	Z, r24
     eec:	91 83       	std	Z+1, r25	; 0x01
     eee:	a2 83       	std	Z+2, r26	; 0x02
     ef0:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     ef2:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     ef6:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     efa:	85 a1       	ldd	r24, Z+37	; 0x25
     efc:	82 30       	cpi	r24, 0x02	; 2
     efe:	c1 f4       	brne	.+48     	; 0xf30 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     f00:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     f04:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     f08:	41 a1       	ldd	r20, Z+33	; 0x21
     f0a:	52 a1       	ldd	r21, Z+34	; 0x22
     f0c:	63 a1       	ldd	r22, Z+35	; 0x23
     f0e:	74 a1       	ldd	r23, Z+36	; 0x24
     f10:	d5 01       	movw	r26, r10
     f12:	c4 01       	movw	r24, r8
     f14:	80 95       	com	r24
     f16:	90 95       	com	r25
     f18:	a0 95       	com	r26
     f1a:	b0 95       	com	r27
     f1c:	84 23       	and	r24, r20
     f1e:	95 23       	and	r25, r21
     f20:	a6 23       	and	r26, r22
     f22:	b7 23       	and	r27, r23
     f24:	81 a3       	std	Z+33, r24	; 0x21
     f26:	92 a3       	std	Z+34, r25	; 0x22
     f28:	a3 a3       	std	Z+35, r26	; 0x23
     f2a:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     f2c:	81 e0       	ldi	r24, 0x01	; 1
     f2e:	01 c0       	rjmp	.+2      	; 0xf32 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     f30:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     f32:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     f36:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     f3a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f3c:	0f 90       	pop	r0
     f3e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	ef 90       	pop	r14
     f48:	bf 90       	pop	r11
     f4a:	af 90       	pop	r10
     f4c:	9f 90       	pop	r9
     f4e:	8f 90       	pop	r8
     f50:	7f 90       	pop	r7
     f52:	6f 90       	pop	r6
     f54:	5f 90       	pop	r5
     f56:	4f 90       	pop	r4
     f58:	08 95       	ret

00000f5a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     f5a:	0f 93       	push	r16
     f5c:	1f 93       	push	r17
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	f8 94       	cli
     f68:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     f6a:	01 15       	cp	r16, r1
     f6c:	11 05       	cpc	r17, r1
     f6e:	49 f0       	breq	.+18     	; 0xf82 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f70:	81 a1       	ldd	r24, Z+33	; 0x21
     f72:	92 a1       	ldd	r25, Z+34	; 0x22
     f74:	a3 a1       	ldd	r26, Z+35	; 0x23
     f76:	b4 a1       	ldd	r27, Z+36	; 0x24
     f78:	e8 01       	movw	r28, r16
     f7a:	88 83       	st	Y, r24
     f7c:	99 83       	std	Y+1, r25	; 0x01
     f7e:	aa 83       	std	Y+2, r26	; 0x02
     f80:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f82:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f84:	82 e0       	ldi	r24, 0x02	; 2
     f86:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f88:	22 30       	cpi	r18, 0x02	; 2
     f8a:	89 f0       	breq	.+34     	; 0xfae <xTaskGenericNotify+0x54>
     f8c:	58 f4       	brcc	.+22     	; 0xfa4 <xTaskGenericNotify+0x4a>
     f8e:	21 30       	cpi	r18, 0x01	; 1
     f90:	01 f5       	brne	.+64     	; 0xfd2 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f92:	81 a1       	ldd	r24, Z+33	; 0x21
     f94:	92 a1       	ldd	r25, Z+34	; 0x22
     f96:	a3 a1       	ldd	r26, Z+35	; 0x23
     f98:	b4 a1       	ldd	r27, Z+36	; 0x24
     f9a:	48 2b       	or	r20, r24
     f9c:	59 2b       	or	r21, r25
     f9e:	6a 2b       	or	r22, r26
     fa0:	7b 2b       	or	r23, r27
     fa2:	13 c0       	rjmp	.+38     	; 0xfca <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     fa4:	23 30       	cpi	r18, 0x03	; 3
     fa6:	89 f0       	breq	.+34     	; 0xfca <xTaskGenericNotify+0x70>
     fa8:	24 30       	cpi	r18, 0x04	; 4
     faa:	69 f0       	breq	.+26     	; 0xfc6 <xTaskGenericNotify+0x6c>
     fac:	12 c0       	rjmp	.+36     	; 0xfd2 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     fae:	81 a1       	ldd	r24, Z+33	; 0x21
     fb0:	92 a1       	ldd	r25, Z+34	; 0x22
     fb2:	a3 a1       	ldd	r26, Z+35	; 0x23
     fb4:	b4 a1       	ldd	r27, Z+36	; 0x24
     fb6:	01 96       	adiw	r24, 0x01	; 1
     fb8:	a1 1d       	adc	r26, r1
     fba:	b1 1d       	adc	r27, r1
     fbc:	81 a3       	std	Z+33, r24	; 0x21
     fbe:	92 a3       	std	Z+34, r25	; 0x22
     fc0:	a3 a3       	std	Z+35, r26	; 0x23
     fc2:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     fc4:	06 c0       	rjmp	.+12     	; 0xfd2 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     fc6:	32 30       	cpi	r19, 0x02	; 2
     fc8:	49 f1       	breq	.+82     	; 0x101c <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     fca:	41 a3       	std	Z+33, r20	; 0x21
     fcc:	52 a3       	std	Z+34, r21	; 0x22
     fce:	63 a3       	std	Z+35, r22	; 0x23
     fd0:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     fd2:	31 30       	cpi	r19, 0x01	; 1
     fd4:	09 f5       	brne	.+66     	; 0x1018 <xTaskGenericNotify+0xbe>
     fd6:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     fd8:	8f 01       	movw	r16, r30
     fda:	0e 5f       	subi	r16, 0xFE	; 254
     fdc:	1f 4f       	sbci	r17, 0xFF	; 255
     fde:	c8 01       	movw	r24, r16
     fe0:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     fe4:	8e 89       	ldd	r24, Y+22	; 0x16
     fe6:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     fea:	98 17       	cp	r25, r24
     fec:	10 f4       	brcc	.+4      	; 0xff2 <xTaskGenericNotify+0x98>
     fee:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     ff2:	29 e0       	ldi	r18, 0x09	; 9
     ff4:	82 9f       	mul	r24, r18
     ff6:	c0 01       	movw	r24, r0
     ff8:	11 24       	eor	r1, r1
     ffa:	b8 01       	movw	r22, r16
     ffc:	80 58       	subi	r24, 0x80	; 128
     ffe:	9e 4f       	sbci	r25, 0xFE	; 254
    1000:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1004:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    1008:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    100c:	9e 89       	ldd	r25, Y+22	; 0x16
    100e:	86 89       	ldd	r24, Z+22	; 0x16
    1010:	89 17       	cp	r24, r25
    1012:	10 f4       	brcc	.+4      	; 0x1018 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    1014:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	01 c0       	rjmp	.+2      	; 0x101e <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    101c:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	08 95       	ret

0000102c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    102c:	ef 92       	push	r14
    102e:	ff 92       	push	r15
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    103a:	01 15       	cp	r16, r1
    103c:	11 05       	cpc	r17, r1
    103e:	49 f0       	breq	.+18     	; 0x1052 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1040:	81 a1       	ldd	r24, Z+33	; 0x21
    1042:	92 a1       	ldd	r25, Z+34	; 0x22
    1044:	a3 a1       	ldd	r26, Z+35	; 0x23
    1046:	b4 a1       	ldd	r27, Z+36	; 0x24
    1048:	e8 01       	movw	r28, r16
    104a:	88 83       	st	Y, r24
    104c:	99 83       	std	Y+1, r25	; 0x01
    104e:	aa 83       	std	Y+2, r26	; 0x02
    1050:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1052:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1054:	82 e0       	ldi	r24, 0x02	; 2
    1056:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1058:	22 30       	cpi	r18, 0x02	; 2
    105a:	89 f0       	breq	.+34     	; 0x107e <xTaskGenericNotifyFromISR+0x52>
    105c:	58 f4       	brcc	.+22     	; 0x1074 <xTaskGenericNotifyFromISR+0x48>
    105e:	21 30       	cpi	r18, 0x01	; 1
    1060:	01 f5       	brne	.+64     	; 0x10a2 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1062:	81 a1       	ldd	r24, Z+33	; 0x21
    1064:	92 a1       	ldd	r25, Z+34	; 0x22
    1066:	a3 a1       	ldd	r26, Z+35	; 0x23
    1068:	b4 a1       	ldd	r27, Z+36	; 0x24
    106a:	48 2b       	or	r20, r24
    106c:	59 2b       	or	r21, r25
    106e:	6a 2b       	or	r22, r26
    1070:	7b 2b       	or	r23, r27
    1072:	13 c0       	rjmp	.+38     	; 0x109a <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1074:	23 30       	cpi	r18, 0x03	; 3
    1076:	89 f0       	breq	.+34     	; 0x109a <xTaskGenericNotifyFromISR+0x6e>
    1078:	24 30       	cpi	r18, 0x04	; 4
    107a:	69 f0       	breq	.+26     	; 0x1096 <xTaskGenericNotifyFromISR+0x6a>
    107c:	12 c0       	rjmp	.+36     	; 0x10a2 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    107e:	81 a1       	ldd	r24, Z+33	; 0x21
    1080:	92 a1       	ldd	r25, Z+34	; 0x22
    1082:	a3 a1       	ldd	r26, Z+35	; 0x23
    1084:	b4 a1       	ldd	r27, Z+36	; 0x24
    1086:	01 96       	adiw	r24, 0x01	; 1
    1088:	a1 1d       	adc	r26, r1
    108a:	b1 1d       	adc	r27, r1
    108c:	81 a3       	std	Z+33, r24	; 0x21
    108e:	92 a3       	std	Z+34, r25	; 0x22
    1090:	a3 a3       	std	Z+35, r26	; 0x23
    1092:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1094:	06 c0       	rjmp	.+12     	; 0x10a2 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1096:	32 30       	cpi	r19, 0x02	; 2
    1098:	d9 f1       	breq	.+118    	; 0x1110 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    109a:	41 a3       	std	Z+33, r20	; 0x21
    109c:	52 a3       	std	Z+34, r21	; 0x22
    109e:	63 a3       	std	Z+35, r22	; 0x23
    10a0:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    10a2:	31 30       	cpi	r19, 0x01	; 1
    10a4:	11 f0       	breq	.+4      	; 0x10aa <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	34 c0       	rjmp	.+104    	; 0x1112 <xTaskGenericNotifyFromISR+0xe6>
    10aa:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10ac:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
    10b0:	81 11       	cpse	r24, r1
    10b2:	15 c0       	rjmp	.+42     	; 0x10de <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10b4:	8f 01       	movw	r16, r30
    10b6:	0e 5f       	subi	r16, 0xFE	; 254
    10b8:	1f 4f       	sbci	r17, 0xFF	; 255
    10ba:	c8 01       	movw	r24, r16
    10bc:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    10c0:	8e 89       	ldd	r24, Y+22	; 0x16
    10c2:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
    10c6:	98 17       	cp	r25, r24
    10c8:	10 f4       	brcc	.+4      	; 0x10ce <xTaskGenericNotifyFromISR+0xa2>
    10ca:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
    10ce:	e9 e0       	ldi	r30, 0x09	; 9
    10d0:	8e 9f       	mul	r24, r30
    10d2:	c0 01       	movw	r24, r0
    10d4:	11 24       	eor	r1, r1
    10d6:	b8 01       	movw	r22, r16
    10d8:	80 58       	subi	r24, 0x80	; 128
    10da:	9e 4f       	sbci	r25, 0xFE	; 254
    10dc:	05 c0       	rjmp	.+10     	; 0x10e8 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    10de:	bf 01       	movw	r22, r30
    10e0:	64 5f       	subi	r22, 0xF4	; 244
    10e2:	7f 4f       	sbci	r23, 0xFF	; 255
    10e4:	81 e6       	ldi	r24, 0x61	; 97
    10e6:	91 e0       	ldi	r25, 0x01	; 1
    10e8:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10ec:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    10f0:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    10f4:	9e 89       	ldd	r25, Y+22	; 0x16
    10f6:	86 89       	ldd	r24, Z+22	; 0x16
    10f8:	89 17       	cp	r24, r25
    10fa:	a8 f6       	brcc	.-86     	; 0x10a6 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    10fc:	e1 14       	cp	r14, r1
    10fe:	f1 04       	cpc	r15, r1
    1100:	19 f0       	breq	.+6      	; 0x1108 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	e7 01       	movw	r28, r14
    1106:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1108:	81 e0       	ldi	r24, 0x01	; 1
    110a:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
    110e:	01 c0       	rjmp	.+2      	; 0x1112 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1110:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1112:	df 91       	pop	r29
    1114:	cf 91       	pop	r28
    1116:	1f 91       	pop	r17
    1118:	0f 91       	pop	r16
    111a:	ff 90       	pop	r15
    111c:	ef 90       	pop	r14
    111e:	08 95       	ret

00001120 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1120:	ef 92       	push	r14
    1122:	ff 92       	push	r15
    1124:	0f 93       	push	r16
    1126:	1f 93       	push	r17
    1128:	cf 93       	push	r28
    112a:	df 93       	push	r29
    112c:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    112e:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1130:	82 e0       	ldi	r24, 0x02	; 2
    1132:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1134:	81 a1       	ldd	r24, Z+33	; 0x21
    1136:	92 a1       	ldd	r25, Z+34	; 0x22
    1138:	a3 a1       	ldd	r26, Z+35	; 0x23
    113a:	b4 a1       	ldd	r27, Z+36	; 0x24
    113c:	01 96       	adiw	r24, 0x01	; 1
    113e:	a1 1d       	adc	r26, r1
    1140:	b1 1d       	adc	r27, r1
    1142:	81 a3       	std	Z+33, r24	; 0x21
    1144:	92 a3       	std	Z+34, r25	; 0x22
    1146:	a3 a3       	std	Z+35, r26	; 0x23
    1148:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    114a:	21 30       	cpi	r18, 0x01	; 1
    114c:	a1 f5       	brne	.+104    	; 0x11b6 <vTaskNotifyGiveFromISR+0x96>
    114e:	8b 01       	movw	r16, r22
    1150:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1152:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
    1156:	81 11       	cpse	r24, r1
    1158:	16 c0       	rjmp	.+44     	; 0x1186 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    115a:	7f 01       	movw	r14, r30
    115c:	22 e0       	ldi	r18, 0x02	; 2
    115e:	e2 0e       	add	r14, r18
    1160:	f1 1c       	adc	r15, r1
    1162:	c7 01       	movw	r24, r14
    1164:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1168:	8e 89       	ldd	r24, Y+22	; 0x16
    116a:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
    116e:	98 17       	cp	r25, r24
    1170:	10 f4       	brcc	.+4      	; 0x1176 <vTaskNotifyGiveFromISR+0x56>
    1172:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
    1176:	e9 e0       	ldi	r30, 0x09	; 9
    1178:	8e 9f       	mul	r24, r30
    117a:	c0 01       	movw	r24, r0
    117c:	11 24       	eor	r1, r1
    117e:	b7 01       	movw	r22, r14
    1180:	80 58       	subi	r24, 0x80	; 128
    1182:	9e 4f       	sbci	r25, 0xFE	; 254
    1184:	05 c0       	rjmp	.+10     	; 0x1190 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1186:	bf 01       	movw	r22, r30
    1188:	64 5f       	subi	r22, 0xF4	; 244
    118a:	7f 4f       	sbci	r23, 0xFF	; 255
    118c:	81 e6       	ldi	r24, 0x61	; 97
    118e:	91 e0       	ldi	r25, 0x01	; 1
    1190:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1194:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    1198:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    119c:	9e 89       	ldd	r25, Y+22	; 0x16
    119e:	86 89       	ldd	r24, Z+22	; 0x16
    11a0:	89 17       	cp	r24, r25
    11a2:	48 f4       	brcc	.+18     	; 0x11b6 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    11a4:	01 15       	cp	r16, r1
    11a6:	11 05       	cpc	r17, r1
    11a8:	19 f0       	breq	.+6      	; 0x11b0 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	f8 01       	movw	r30, r16
    11ae:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    11b6:	df 91       	pop	r29
    11b8:	cf 91       	pop	r28
    11ba:	1f 91       	pop	r17
    11bc:	0f 91       	pop	r16
    11be:	ff 90       	pop	r15
    11c0:	ef 90       	pop	r14
    11c2:	08 95       	ret

000011c4 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    11c4:	00 97       	sbiw	r24, 0x00	; 0
    11c6:	21 f4       	brne	.+8      	; 0x11d0 <xTaskNotifyStateClear+0xc>
    11c8:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
    11cc:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>

		taskENTER_CRITICAL();
    11d0:	0f b6       	in	r0, 0x3f	; 63
    11d2:	f8 94       	cli
    11d4:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    11d6:	fc 01       	movw	r30, r24
    11d8:	25 a1       	ldd	r18, Z+37	; 0x25
    11da:	22 30       	cpi	r18, 0x02	; 2
    11dc:	19 f4       	brne	.+6      	; 0x11e4 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11de:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	01 c0       	rjmp	.+2      	; 0x11e6 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    11e4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    11e6:	0f 90       	pop	r0
    11e8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11ea:	08 95       	ret

000011ec <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    11f2:	fc 01       	movw	r30, r24
    11f4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    11f6:	0f 90       	pop	r0
    11f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	91 11       	cpse	r25, r1
    11fe:	80 e0       	ldi	r24, 0x00	; 0
}
    1200:	08 95       	ret

00001202 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1202:	0f 93       	push	r16
    1204:	1f 93       	push	r17
    1206:	cf 93       	push	r28
    1208:	df 93       	push	r29
    120a:	ec 01       	movw	r28, r24
    120c:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    120e:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1210:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1212:	44 23       	and	r20, r20
    1214:	b1 f1       	breq	.+108    	; 0x1282 <prvCopyDataToQueue+0x80>
    1216:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1218:	01 11       	cpse	r16, r1
    121a:	15 c0       	rjmp	.+42     	; 0x1246 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    121c:	8a 81       	ldd	r24, Y+2	; 0x02
    121e:	9b 81       	ldd	r25, Y+3	; 0x03
    1220:	0e 94 75 12 	call	0x24ea	; 0x24ea <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1224:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1226:	8a 81       	ldd	r24, Y+2	; 0x02
    1228:	9b 81       	ldd	r25, Y+3	; 0x03
    122a:	82 0f       	add	r24, r18
    122c:	91 1d       	adc	r25, r1
    122e:	9b 83       	std	Y+3, r25	; 0x03
    1230:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1232:	2c 81       	ldd	r18, Y+4	; 0x04
    1234:	3d 81       	ldd	r19, Y+5	; 0x05
    1236:	82 17       	cp	r24, r18
    1238:	93 07       	cpc	r25, r19
    123a:	18 f1       	brcs	.+70     	; 0x1282 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    123c:	88 81       	ld	r24, Y
    123e:	99 81       	ldd	r25, Y+1	; 0x01
    1240:	9b 83       	std	Y+3, r25	; 0x03
    1242:	8a 83       	std	Y+2, r24	; 0x02
    1244:	1e c0       	rjmp	.+60     	; 0x1282 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1246:	8e 81       	ldd	r24, Y+6	; 0x06
    1248:	9f 81       	ldd	r25, Y+7	; 0x07
    124a:	0e 94 75 12 	call	0x24ea	; 0x24ea <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    124e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	91 95       	neg	r25
    1254:	81 95       	neg	r24
    1256:	91 09       	sbc	r25, r1
    1258:	2e 81       	ldd	r18, Y+6	; 0x06
    125a:	3f 81       	ldd	r19, Y+7	; 0x07
    125c:	28 0f       	add	r18, r24
    125e:	39 1f       	adc	r19, r25
    1260:	3f 83       	std	Y+7, r19	; 0x07
    1262:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1264:	48 81       	ld	r20, Y
    1266:	59 81       	ldd	r21, Y+1	; 0x01
    1268:	24 17       	cp	r18, r20
    126a:	35 07       	cpc	r19, r21
    126c:	30 f4       	brcc	.+12     	; 0x127a <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    126e:	2c 81       	ldd	r18, Y+4	; 0x04
    1270:	3d 81       	ldd	r19, Y+5	; 0x05
    1272:	82 0f       	add	r24, r18
    1274:	93 1f       	adc	r25, r19
    1276:	9f 83       	std	Y+7, r25	; 0x07
    1278:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    127a:	02 30       	cpi	r16, 0x02	; 2
    127c:	11 f4       	brne	.+4      	; 0x1282 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    127e:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1280:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1282:	1f 5f       	subi	r17, 0xFF	; 255
    1284:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1286:	80 e0       	ldi	r24, 0x00	; 0
    1288:	df 91       	pop	r29
    128a:	cf 91       	pop	r28
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	08 95       	ret

00001292 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1292:	fc 01       	movw	r30, r24
    1294:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1296:	44 8d       	ldd	r20, Z+28	; 0x1c
    1298:	44 23       	and	r20, r20
    129a:	a1 f0       	breq	.+40     	; 0x12c4 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    129c:	50 e0       	ldi	r21, 0x00	; 0
    129e:	26 81       	ldd	r18, Z+6	; 0x06
    12a0:	37 81       	ldd	r19, Z+7	; 0x07
    12a2:	24 0f       	add	r18, r20
    12a4:	35 1f       	adc	r19, r21
    12a6:	37 83       	std	Z+7, r19	; 0x07
    12a8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    12aa:	64 81       	ldd	r22, Z+4	; 0x04
    12ac:	75 81       	ldd	r23, Z+5	; 0x05
    12ae:	26 17       	cp	r18, r22
    12b0:	37 07       	cpc	r19, r23
    12b2:	20 f0       	brcs	.+8      	; 0x12bc <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    12b4:	20 81       	ld	r18, Z
    12b6:	31 81       	ldd	r19, Z+1	; 0x01
    12b8:	37 83       	std	Z+7, r19	; 0x07
    12ba:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    12bc:	66 81       	ldd	r22, Z+6	; 0x06
    12be:	77 81       	ldd	r23, Z+7	; 0x07
    12c0:	0c 94 75 12 	jmp	0x24ea	; 0x24ea <memcpy>
    12c4:	08 95       	ret

000012c6 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    12c6:	ef 92       	push	r14
    12c8:	ff 92       	push	r15
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    12d2:	0f b6       	in	r0, 0x3f	; 63
    12d4:	f8 94       	cli
    12d6:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    12d8:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12da:	7c 01       	movw	r14, r24
    12dc:	81 e1       	ldi	r24, 0x11	; 17
    12de:	e8 0e       	add	r14, r24
    12e0:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    12e2:	11 16       	cp	r1, r17
    12e4:	5c f4       	brge	.+22     	; 0x12fc <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12e6:	89 89       	ldd	r24, Y+17	; 0x11
    12e8:	88 23       	and	r24, r24
    12ea:	41 f0       	breq	.+16     	; 0x12fc <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12ec:	c7 01       	movw	r24, r14
    12ee:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    12f2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    12f4:	0e 94 b9 06 	call	0xd72	; 0xd72 <vTaskMissedYield>
    12f8:	11 50       	subi	r17, 0x01	; 1
    12fa:	f3 cf       	rjmp	.-26     	; 0x12e2 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    12fc:	8f ef       	ldi	r24, 0xFF	; 255
    12fe:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1300:	0f 90       	pop	r0
    1302:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1304:	0f b6       	in	r0, 0x3f	; 63
    1306:	f8 94       	cli
    1308:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    130a:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    130c:	7e 01       	movw	r14, r28
    130e:	88 e0       	ldi	r24, 0x08	; 8
    1310:	e8 0e       	add	r14, r24
    1312:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1314:	11 16       	cp	r1, r17
    1316:	5c f4       	brge	.+22     	; 0x132e <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1318:	88 85       	ldd	r24, Y+8	; 0x08
    131a:	88 23       	and	r24, r24
    131c:	41 f0       	breq	.+16     	; 0x132e <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    131e:	c7 01       	movw	r24, r14
    1320:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    1324:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1326:	0e 94 b9 06 	call	0xd72	; 0xd72 <vTaskMissedYield>
    132a:	11 50       	subi	r17, 0x01	; 1
    132c:	f3 cf       	rjmp	.-26     	; 0x1314 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    132e:	8f ef       	ldi	r24, 0xFF	; 255
    1330:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63
}
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	1f 91       	pop	r17
    133c:	ff 90       	pop	r15
    133e:	ef 90       	pop	r14
    1340:	08 95       	ret

00001342 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
    1346:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    134e:	48 81       	ld	r20, Y
    1350:	59 81       	ldd	r21, Y+1	; 0x01
    1352:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1354:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1356:	9a 01       	movw	r18, r20
    1358:	87 9f       	mul	r24, r23
    135a:	20 0d       	add	r18, r0
    135c:	31 1d       	adc	r19, r1
    135e:	11 24       	eor	r1, r1
    1360:	3d 83       	std	Y+5, r19	; 0x05
    1362:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1364:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1366:	5b 83       	std	Y+3, r21	; 0x03
    1368:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	01 97       	sbiw	r24, 0x01	; 1
    136e:	78 9f       	mul	r23, r24
    1370:	90 01       	movw	r18, r0
    1372:	79 9f       	mul	r23, r25
    1374:	30 0d       	add	r19, r0
    1376:	11 24       	eor	r1, r1
    1378:	ca 01       	movw	r24, r20
    137a:	82 0f       	add	r24, r18
    137c:	93 1f       	adc	r25, r19
    137e:	9f 83       	std	Y+7, r25	; 0x07
    1380:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1382:	8f ef       	ldi	r24, 0xFF	; 255
    1384:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1386:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1388:	61 11       	cpse	r22, r1
    138a:	0c c0       	rjmp	.+24     	; 0x13a4 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    138c:	88 85       	ldd	r24, Y+8	; 0x08
    138e:	88 23       	and	r24, r24
    1390:	89 f0       	breq	.+34     	; 0x13b4 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1392:	ce 01       	movw	r24, r28
    1394:	08 96       	adiw	r24, 0x08	; 8
    1396:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    139a:	88 23       	and	r24, r24
    139c:	59 f0       	breq	.+22     	; 0x13b4 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    139e:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
    13a2:	08 c0       	rjmp	.+16     	; 0x13b4 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    13a4:	ce 01       	movw	r24, r28
    13a6:	08 96       	adiw	r24, 0x08	; 8
    13a8:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    13ac:	ce 01       	movw	r24, r28
    13ae:	41 96       	adiw	r24, 0x11	; 17
    13b0:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    13b4:	0f 90       	pop	r0
    13b6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	08 95       	ret

000013c0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    13c0:	0f 93       	push	r16
    13c2:	1f 93       	push	r17
    13c4:	cf 93       	push	r28
    13c6:	df 93       	push	r29
    13c8:	08 2f       	mov	r16, r24
    13ca:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    13cc:	66 23       	and	r22, r22
    13ce:	21 f0       	breq	.+8      	; 0x13d8 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13d0:	86 9f       	mul	r24, r22
    13d2:	c0 01       	movw	r24, r0
    13d4:	11 24       	eor	r1, r1
    13d6:	02 c0       	rjmp	.+4      	; 0x13dc <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    13dc:	4f 96       	adiw	r24, 0x1f	; 31
    13de:	0e 94 37 10 	call	0x206e	; 0x206e <pvPortMalloc>
    13e2:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    13e4:	00 97       	sbiw	r24, 0x00	; 0
    13e6:	71 f0       	breq	.+28     	; 0x1404 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    13e8:	11 11       	cpse	r17, r1
    13ea:	03 c0       	rjmp	.+6      	; 0x13f2 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    13ec:	99 83       	std	Y+1, r25	; 0x01
    13ee:	88 83       	st	Y, r24
    13f0:	03 c0       	rjmp	.+6      	; 0x13f8 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    13f2:	4f 96       	adiw	r24, 0x1f	; 31
    13f4:	99 83       	std	Y+1, r25	; 0x01
    13f6:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    13f8:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    13fa:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    13fc:	61 e0       	ldi	r22, 0x01	; 1
    13fe:	ce 01       	movw	r24, r28
    1400:	0e 94 a1 09 	call	0x1342	; 0x1342 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    1404:	ce 01       	movw	r24, r28
    1406:	df 91       	pop	r29
    1408:	cf 91       	pop	r28
    140a:	1f 91       	pop	r17
    140c:	0f 91       	pop	r16
    140e:	08 95       	ret

00001410 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1410:	af 92       	push	r10
    1412:	bf 92       	push	r11
    1414:	cf 92       	push	r12
    1416:	df 92       	push	r13
    1418:	ff 92       	push	r15
    141a:	0f 93       	push	r16
    141c:	1f 93       	push	r17
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
    1422:	00 d0       	rcall	.+0      	; 0x1424 <xQueueGenericSend+0x14>
    1424:	00 d0       	rcall	.+0      	; 0x1426 <xQueueGenericSend+0x16>
    1426:	1f 92       	push	r1
    1428:	cd b7       	in	r28, 0x3d	; 61
    142a:	de b7       	in	r29, 0x3e	; 62
    142c:	8c 01       	movw	r16, r24
    142e:	6b 01       	movw	r12, r22
    1430:	5d 83       	std	Y+5, r21	; 0x05
    1432:	4c 83       	std	Y+4, r20	; 0x04
    1434:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1436:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1438:	58 01       	movw	r10, r16
    143a:	98 e0       	ldi	r25, 0x08	; 8
    143c:	a9 0e       	add	r10, r25
    143e:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1440:	0f b6       	in	r0, 0x3f	; 63
    1442:	f8 94       	cli
    1444:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1446:	f8 01       	movw	r30, r16
    1448:	22 8d       	ldd	r18, Z+26	; 0x1a
    144a:	93 8d       	ldd	r25, Z+27	; 0x1b
    144c:	29 17       	cp	r18, r25
    144e:	18 f0       	brcs	.+6      	; 0x1456 <xQueueGenericSend+0x46>
    1450:	f2 e0       	ldi	r31, 0x02	; 2
    1452:	ff 12       	cpse	r15, r31
    1454:	14 c0       	rjmp	.+40     	; 0x147e <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1456:	4f 2d       	mov	r20, r15
    1458:	b6 01       	movw	r22, r12
    145a:	c8 01       	movw	r24, r16
    145c:	0e 94 01 09 	call	0x1202	; 0x1202 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1460:	f8 01       	movw	r30, r16
    1462:	91 89       	ldd	r25, Z+17	; 0x11
    1464:	99 23       	and	r25, r25
    1466:	21 f0       	breq	.+8      	; 0x1470 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1468:	c8 01       	movw	r24, r16
    146a:	41 96       	adiw	r24, 0x11	; 17
    146c:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    1470:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1472:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1476:	0f 90       	pop	r0
    1478:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	50 c0       	rjmp	.+160    	; 0x151e <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    147e:	2c 81       	ldd	r18, Y+4	; 0x04
    1480:	3d 81       	ldd	r19, Y+5	; 0x05
    1482:	23 2b       	or	r18, r19
    1484:	19 f4       	brne	.+6      	; 0x148c <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	48 c0       	rjmp	.+144    	; 0x151c <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    148c:	81 11       	cpse	r24, r1
    148e:	04 c0       	rjmp	.+8      	; 0x1498 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1490:	ce 01       	movw	r24, r28
    1492:	01 96       	adiw	r24, 0x01	; 1
    1494:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    149c:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14a0:	0f b6       	in	r0, 0x3f	; 63
    14a2:	f8 94       	cli
    14a4:	0f 92       	push	r0
    14a6:	f8 01       	movw	r30, r16
    14a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    14aa:	8f 3f       	cpi	r24, 0xFF	; 255
    14ac:	09 f4       	brne	.+2      	; 0x14b0 <xQueueGenericSend+0xa0>
    14ae:	15 8e       	std	Z+29, r1	; 0x1d
    14b0:	f8 01       	movw	r30, r16
    14b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    14b4:	8f 3f       	cpi	r24, 0xFF	; 255
    14b6:	09 f4       	brne	.+2      	; 0x14ba <xQueueGenericSend+0xaa>
    14b8:	16 8e       	std	Z+30, r1	; 0x1e
    14ba:	0f 90       	pop	r0
    14bc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14be:	be 01       	movw	r22, r28
    14c0:	6c 5f       	subi	r22, 0xFC	; 252
    14c2:	7f 4f       	sbci	r23, 0xFF	; 255
    14c4:	ce 01       	movw	r24, r28
    14c6:	01 96       	adiw	r24, 0x01	; 1
    14c8:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCheckForTimeOut>
    14cc:	81 11       	cpse	r24, r1
    14ce:	21 c0       	rjmp	.+66     	; 0x1512 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14d0:	0f b6       	in	r0, 0x3f	; 63
    14d2:	f8 94       	cli
    14d4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    14d6:	f8 01       	movw	r30, r16
    14d8:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14da:	0f 90       	pop	r0
    14dc:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14de:	83 8d       	ldd	r24, Z+27	; 0x1b
    14e0:	98 13       	cpse	r25, r24
    14e2:	11 c0       	rjmp	.+34     	; 0x1506 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14e4:	6c 81       	ldd	r22, Y+4	; 0x04
    14e6:	7d 81       	ldd	r23, Y+5	; 0x05
    14e8:	c5 01       	movw	r24, r10
    14ea:	0e 94 d0 05 	call	0xba0	; 0xba0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14ee:	c8 01       	movw	r24, r16
    14f0:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14f4:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    14f8:	88 23       	and	r24, r24
    14fa:	11 f0       	breq	.+4      	; 0x1500 <xQueueGenericSend+0xf0>
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	a0 cf       	rjmp	.-192    	; 0x1440 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1500:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
    1504:	fb cf       	rjmp	.-10     	; 0x14fc <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1506:	c8 01       	movw	r24, r16
    1508:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    150c:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    1510:	f5 cf       	rjmp	.-22     	; 0x14fc <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1512:	c8 01       	movw	r24, r16
    1514:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1518:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    151c:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    151e:	0f 90       	pop	r0
    1520:	0f 90       	pop	r0
    1522:	0f 90       	pop	r0
    1524:	0f 90       	pop	r0
    1526:	0f 90       	pop	r0
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	ff 90       	pop	r15
    1532:	df 90       	pop	r13
    1534:	cf 90       	pop	r12
    1536:	bf 90       	pop	r11
    1538:	af 90       	pop	r10
    153a:	08 95       	ret

0000153c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    153c:	ef 92       	push	r14
    153e:	ff 92       	push	r15
    1540:	1f 93       	push	r17
    1542:	cf 93       	push	r28
    1544:	df 93       	push	r29
    1546:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1548:	9a 8d       	ldd	r25, Y+26	; 0x1a
    154a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    154c:	98 17       	cp	r25, r24
    154e:	10 f0       	brcs	.+4      	; 0x1554 <xQueueGenericSendFromISR+0x18>
    1550:	22 30       	cpi	r18, 0x02	; 2
    1552:	e1 f4       	brne	.+56     	; 0x158c <xQueueGenericSendFromISR+0x50>
    1554:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1556:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1558:	42 2f       	mov	r20, r18
    155a:	ce 01       	movw	r24, r28
    155c:	0e 94 01 09 	call	0x1202	; 0x1202 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1560:	1f 3f       	cpi	r17, 0xFF	; 255
    1562:	81 f4       	brne	.+32     	; 0x1584 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1564:	89 89       	ldd	r24, Y+17	; 0x11
    1566:	88 23       	and	r24, r24
    1568:	79 f0       	breq	.+30     	; 0x1588 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    156a:	ce 01       	movw	r24, r28
    156c:	41 96       	adiw	r24, 0x11	; 17
    156e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    1572:	88 23       	and	r24, r24
    1574:	49 f0       	breq	.+18     	; 0x1588 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1576:	e1 14       	cp	r14, r1
    1578:	f1 04       	cpc	r15, r1
    157a:	31 f0       	breq	.+12     	; 0x1588 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	f7 01       	movw	r30, r14
    1580:	80 83       	st	Z, r24
    1582:	05 c0       	rjmp	.+10     	; 0x158e <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1584:	1f 5f       	subi	r17, 0xFF	; 255
    1586:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	01 c0       	rjmp	.+2      	; 0x158e <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    158c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	1f 91       	pop	r17
    1594:	ff 90       	pop	r15
    1596:	ef 90       	pop	r14
    1598:	08 95       	ret

0000159a <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15a0:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    15a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    15a4:	98 17       	cp	r25, r24
    15a6:	c0 f4       	brcc	.+48     	; 0x15d8 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    15a8:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    15aa:	9f 5f       	subi	r25, 0xFF	; 255
    15ac:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    15ae:	8f 3f       	cpi	r24, 0xFF	; 255
    15b0:	79 f4       	brne	.+30     	; 0x15d0 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15b2:	81 89       	ldd	r24, Z+17	; 0x11
    15b4:	88 23       	and	r24, r24
    15b6:	71 f0       	breq	.+28     	; 0x15d4 <xQueueGiveFromISR+0x3a>
    15b8:	eb 01       	movw	r28, r22
    15ba:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15bc:	41 96       	adiw	r24, 0x11	; 17
    15be:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    15c2:	88 23       	and	r24, r24
    15c4:	39 f0       	breq	.+14     	; 0x15d4 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15c6:	20 97       	sbiw	r28, 0x00	; 0
    15c8:	29 f0       	breq	.+10     	; 0x15d4 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15ca:	81 e0       	ldi	r24, 0x01	; 1
    15cc:	88 83       	st	Y, r24
    15ce:	05 c0       	rjmp	.+10     	; 0x15da <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15d0:	8f 5f       	subi	r24, 0xFF	; 255
    15d2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	01 c0       	rjmp	.+2      	; 0x15da <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15d8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15da:	df 91       	pop	r29
    15dc:	cf 91       	pop	r28
    15de:	08 95       	ret

000015e0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    15e0:	af 92       	push	r10
    15e2:	bf 92       	push	r11
    15e4:	cf 92       	push	r12
    15e6:	df 92       	push	r13
    15e8:	ff 92       	push	r15
    15ea:	0f 93       	push	r16
    15ec:	1f 93       	push	r17
    15ee:	cf 93       	push	r28
    15f0:	df 93       	push	r29
    15f2:	00 d0       	rcall	.+0      	; 0x15f4 <xQueueReceive+0x14>
    15f4:	00 d0       	rcall	.+0      	; 0x15f6 <xQueueReceive+0x16>
    15f6:	1f 92       	push	r1
    15f8:	cd b7       	in	r28, 0x3d	; 61
    15fa:	de b7       	in	r29, 0x3e	; 62
    15fc:	8c 01       	movw	r16, r24
    15fe:	6b 01       	movw	r12, r22
    1600:	5d 83       	std	Y+5, r21	; 0x05
    1602:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1604:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1606:	58 01       	movw	r10, r16
    1608:	91 e1       	ldi	r25, 0x11	; 17
    160a:	a9 0e       	add	r10, r25
    160c:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1614:	f8 01       	movw	r30, r16
    1616:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1618:	ff 20       	and	r15, r15
    161a:	a9 f0       	breq	.+42     	; 0x1646 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    161c:	b6 01       	movw	r22, r12
    161e:	c8 01       	movw	r24, r16
    1620:	0e 94 49 09 	call	0x1292	; 0x1292 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1624:	fa 94       	dec	r15
    1626:	f8 01       	movw	r30, r16
    1628:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    162a:	80 85       	ldd	r24, Z+8	; 0x08
    162c:	88 23       	and	r24, r24
    162e:	39 f0       	breq	.+14     	; 0x163e <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1630:	c8 01       	movw	r24, r16
    1632:	08 96       	adiw	r24, 0x08	; 8
    1634:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    1638:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    163a:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    163e:	0f 90       	pop	r0
    1640:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	50 c0       	rjmp	.+160    	; 0x16e6 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1646:	2c 81       	ldd	r18, Y+4	; 0x04
    1648:	3d 81       	ldd	r19, Y+5	; 0x05
    164a:	23 2b       	or	r18, r19
    164c:	19 f4       	brne	.+6      	; 0x1654 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    164e:	0f 90       	pop	r0
    1650:	0f be       	out	0x3f, r0	; 63
    1652:	48 c0       	rjmp	.+144    	; 0x16e4 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1654:	81 11       	cpse	r24, r1
    1656:	04 c0       	rjmp	.+8      	; 0x1660 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1658:	ce 01       	movw	r24, r28
    165a:	01 96       	adiw	r24, 0x01	; 1
    165c:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1660:	0f 90       	pop	r0
    1662:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1664:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1668:	0f b6       	in	r0, 0x3f	; 63
    166a:	f8 94       	cli
    166c:	0f 92       	push	r0
    166e:	f8 01       	movw	r30, r16
    1670:	85 8d       	ldd	r24, Z+29	; 0x1d
    1672:	8f 3f       	cpi	r24, 0xFF	; 255
    1674:	09 f4       	brne	.+2      	; 0x1678 <xQueueReceive+0x98>
    1676:	15 8e       	std	Z+29, r1	; 0x1d
    1678:	f8 01       	movw	r30, r16
    167a:	86 8d       	ldd	r24, Z+30	; 0x1e
    167c:	8f 3f       	cpi	r24, 0xFF	; 255
    167e:	09 f4       	brne	.+2      	; 0x1682 <xQueueReceive+0xa2>
    1680:	16 8e       	std	Z+30, r1	; 0x1e
    1682:	0f 90       	pop	r0
    1684:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1686:	be 01       	movw	r22, r28
    1688:	6c 5f       	subi	r22, 0xFC	; 252
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	ce 01       	movw	r24, r28
    168e:	01 96       	adiw	r24, 0x01	; 1
    1690:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCheckForTimeOut>
    1694:	81 11       	cpse	r24, r1
    1696:	1c c0       	rjmp	.+56     	; 0x16d0 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1698:	c8 01       	movw	r24, r16
    169a:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvIsQueueEmpty>
    169e:	88 23       	and	r24, r24
    16a0:	89 f0       	breq	.+34     	; 0x16c4 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16a2:	6c 81       	ldd	r22, Y+4	; 0x04
    16a4:	7d 81       	ldd	r23, Y+5	; 0x05
    16a6:	c5 01       	movw	r24, r10
    16a8:	0e 94 d0 05 	call	0xba0	; 0xba0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    16ac:	c8 01       	movw	r24, r16
    16ae:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    16b2:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    16b6:	88 23       	and	r24, r24
    16b8:	11 f0       	breq	.+4      	; 0x16be <xQueueReceive+0xde>
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	a8 cf       	rjmp	.-176    	; 0x160e <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    16be:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
    16c2:	fb cf       	rjmp	.-10     	; 0x16ba <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    16c4:	c8 01       	movw	r24, r16
    16c6:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16ca:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    16ce:	f5 cf       	rjmp	.-22     	; 0x16ba <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    16d0:	c8 01       	movw	r24, r16
    16d2:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16d6:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16da:	c8 01       	movw	r24, r16
    16dc:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvIsQueueEmpty>
    16e0:	88 23       	and	r24, r24
    16e2:	59 f3       	breq	.-42     	; 0x16ba <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    16e4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    16e6:	0f 90       	pop	r0
    16e8:	0f 90       	pop	r0
    16ea:	0f 90       	pop	r0
    16ec:	0f 90       	pop	r0
    16ee:	0f 90       	pop	r0
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	1f 91       	pop	r17
    16f6:	0f 91       	pop	r16
    16f8:	ff 90       	pop	r15
    16fa:	df 90       	pop	r13
    16fc:	cf 90       	pop	r12
    16fe:	bf 90       	pop	r11
    1700:	af 90       	pop	r10
    1702:	08 95       	ret

00001704 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1704:	ef 92       	push	r14
    1706:	ff 92       	push	r15
    1708:	0f 93       	push	r16
    170a:	1f 93       	push	r17
    170c:	cf 93       	push	r28
    170e:	df 93       	push	r29
    1710:	00 d0       	rcall	.+0      	; 0x1712 <xQueueSemaphoreTake+0xe>
    1712:	00 d0       	rcall	.+0      	; 0x1714 <xQueueSemaphoreTake+0x10>
    1714:	1f 92       	push	r1
    1716:	cd b7       	in	r28, 0x3d	; 61
    1718:	de b7       	in	r29, 0x3e	; 62
    171a:	8c 01       	movw	r16, r24
    171c:	7d 83       	std	Y+5, r23	; 0x05
    171e:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1720:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1722:	78 01       	movw	r14, r16
    1724:	81 e1       	ldi	r24, 0x11	; 17
    1726:	e8 0e       	add	r14, r24
    1728:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    172a:	0f b6       	in	r0, 0x3f	; 63
    172c:	f8 94       	cli
    172e:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1730:	f8 01       	movw	r30, r16
    1732:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1734:	88 23       	and	r24, r24
    1736:	81 f0       	breq	.+32     	; 0x1758 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1738:	81 50       	subi	r24, 0x01	; 1
    173a:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    173c:	80 85       	ldd	r24, Z+8	; 0x08
    173e:	88 23       	and	r24, r24
    1740:	39 f0       	breq	.+14     	; 0x1750 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1742:	c8 01       	movw	r24, r16
    1744:	08 96       	adiw	r24, 0x08	; 8
    1746:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    174a:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    174c:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1750:	0f 90       	pop	r0
    1752:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1754:	81 e0       	ldi	r24, 0x01	; 1
    1756:	50 c0       	rjmp	.+160    	; 0x17f8 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1758:	2c 81       	ldd	r18, Y+4	; 0x04
    175a:	3d 81       	ldd	r19, Y+5	; 0x05
    175c:	23 2b       	or	r18, r19
    175e:	19 f4       	brne	.+6      	; 0x1766 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1760:	0f 90       	pop	r0
    1762:	0f be       	out	0x3f, r0	; 63
    1764:	48 c0       	rjmp	.+144    	; 0x17f6 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1766:	91 11       	cpse	r25, r1
    1768:	04 c0       	rjmp	.+8      	; 0x1772 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    176a:	ce 01       	movw	r24, r28
    176c:	01 96       	adiw	r24, 0x01	; 1
    176e:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1772:	0f 90       	pop	r0
    1774:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1776:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    177a:	0f b6       	in	r0, 0x3f	; 63
    177c:	f8 94       	cli
    177e:	0f 92       	push	r0
    1780:	f8 01       	movw	r30, r16
    1782:	85 8d       	ldd	r24, Z+29	; 0x1d
    1784:	8f 3f       	cpi	r24, 0xFF	; 255
    1786:	09 f4       	brne	.+2      	; 0x178a <xQueueSemaphoreTake+0x86>
    1788:	15 8e       	std	Z+29, r1	; 0x1d
    178a:	f8 01       	movw	r30, r16
    178c:	86 8d       	ldd	r24, Z+30	; 0x1e
    178e:	8f 3f       	cpi	r24, 0xFF	; 255
    1790:	09 f4       	brne	.+2      	; 0x1794 <xQueueSemaphoreTake+0x90>
    1792:	16 8e       	std	Z+30, r1	; 0x1e
    1794:	0f 90       	pop	r0
    1796:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1798:	be 01       	movw	r22, r28
    179a:	6c 5f       	subi	r22, 0xFC	; 252
    179c:	7f 4f       	sbci	r23, 0xFF	; 255
    179e:	ce 01       	movw	r24, r28
    17a0:	01 96       	adiw	r24, 0x01	; 1
    17a2:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCheckForTimeOut>
    17a6:	81 11       	cpse	r24, r1
    17a8:	1c c0       	rjmp	.+56     	; 0x17e2 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17aa:	c8 01       	movw	r24, r16
    17ac:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvIsQueueEmpty>
    17b0:	88 23       	and	r24, r24
    17b2:	89 f0       	breq	.+34     	; 0x17d6 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17b4:	6c 81       	ldd	r22, Y+4	; 0x04
    17b6:	7d 81       	ldd	r23, Y+5	; 0x05
    17b8:	c7 01       	movw	r24, r14
    17ba:	0e 94 d0 05 	call	0xba0	; 0xba0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17be:	c8 01       	movw	r24, r16
    17c0:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    17c4:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    17c8:	88 23       	and	r24, r24
    17ca:	11 f0       	breq	.+4      	; 0x17d0 <xQueueSemaphoreTake+0xcc>
    17cc:	91 e0       	ldi	r25, 0x01	; 1
    17ce:	ad cf       	rjmp	.-166    	; 0x172a <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    17d0:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
    17d4:	fb cf       	rjmp	.-10     	; 0x17cc <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    17d6:	c8 01       	movw	r24, r16
    17d8:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17dc:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    17e0:	f5 cf       	rjmp	.-22     	; 0x17cc <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    17e2:	c8 01       	movw	r24, r16
    17e4:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17e8:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17ec:	c8 01       	movw	r24, r16
    17ee:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvIsQueueEmpty>
    17f2:	88 23       	and	r24, r24
    17f4:	59 f3       	breq	.-42     	; 0x17cc <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17f6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17f8:	0f 90       	pop	r0
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	df 91       	pop	r29
    1804:	cf 91       	pop	r28
    1806:	1f 91       	pop	r17
    1808:	0f 91       	pop	r16
    180a:	ff 90       	pop	r15
    180c:	ef 90       	pop	r14
    180e:	08 95       	ret

00001810 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1810:	cf 92       	push	r12
    1812:	df 92       	push	r13
    1814:	ef 92       	push	r14
    1816:	ff 92       	push	r15
    1818:	0f 93       	push	r16
    181a:	1f 93       	push	r17
    181c:	cf 93       	push	r28
    181e:	df 93       	push	r29
    1820:	00 d0       	rcall	.+0      	; 0x1822 <xQueuePeek+0x12>
    1822:	00 d0       	rcall	.+0      	; 0x1824 <xQueuePeek+0x14>
    1824:	1f 92       	push	r1
    1826:	cd b7       	in	r28, 0x3d	; 61
    1828:	de b7       	in	r29, 0x3e	; 62
    182a:	8c 01       	movw	r16, r24
    182c:	7b 01       	movw	r14, r22
    182e:	5d 83       	std	Y+5, r21	; 0x05
    1830:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1832:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1834:	68 01       	movw	r12, r16
    1836:	91 e1       	ldi	r25, 0x11	; 17
    1838:	c9 0e       	add	r12, r25
    183a:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1842:	f8 01       	movw	r30, r16
    1844:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1846:	99 23       	and	r25, r25
    1848:	b9 f0       	breq	.+46     	; 0x1878 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    184a:	c6 80       	ldd	r12, Z+6	; 0x06
    184c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    184e:	b7 01       	movw	r22, r14
    1850:	c8 01       	movw	r24, r16
    1852:	0e 94 49 09 	call	0x1292	; 0x1292 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1856:	f8 01       	movw	r30, r16
    1858:	d7 82       	std	Z+7, r13	; 0x07
    185a:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    185c:	81 89       	ldd	r24, Z+17	; 0x11
    185e:	88 23       	and	r24, r24
    1860:	39 f0       	breq	.+14     	; 0x1870 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1862:	c8 01       	movw	r24, r16
    1864:	41 96       	adiw	r24, 0x11	; 17
    1866:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    186a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    186c:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	50 c0       	rjmp	.+160    	; 0x1918 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1878:	2c 81       	ldd	r18, Y+4	; 0x04
    187a:	3d 81       	ldd	r19, Y+5	; 0x05
    187c:	23 2b       	or	r18, r19
    187e:	19 f4       	brne	.+6      	; 0x1886 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63
    1884:	48 c0       	rjmp	.+144    	; 0x1916 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1886:	81 11       	cpse	r24, r1
    1888:	04 c0       	rjmp	.+8      	; 0x1892 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    188a:	ce 01       	movw	r24, r28
    188c:	01 96       	adiw	r24, 0x01	; 1
    188e:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1896:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    189a:	0f b6       	in	r0, 0x3f	; 63
    189c:	f8 94       	cli
    189e:	0f 92       	push	r0
    18a0:	f8 01       	movw	r30, r16
    18a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    18a4:	8f 3f       	cpi	r24, 0xFF	; 255
    18a6:	09 f4       	brne	.+2      	; 0x18aa <xQueuePeek+0x9a>
    18a8:	15 8e       	std	Z+29, r1	; 0x1d
    18aa:	f8 01       	movw	r30, r16
    18ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    18ae:	8f 3f       	cpi	r24, 0xFF	; 255
    18b0:	09 f4       	brne	.+2      	; 0x18b4 <xQueuePeek+0xa4>
    18b2:	16 8e       	std	Z+30, r1	; 0x1e
    18b4:	0f 90       	pop	r0
    18b6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18b8:	be 01       	movw	r22, r28
    18ba:	6c 5f       	subi	r22, 0xFC	; 252
    18bc:	7f 4f       	sbci	r23, 0xFF	; 255
    18be:	ce 01       	movw	r24, r28
    18c0:	01 96       	adiw	r24, 0x01	; 1
    18c2:	0e 94 86 06 	call	0xd0c	; 0xd0c <xTaskCheckForTimeOut>
    18c6:	81 11       	cpse	r24, r1
    18c8:	1c c0       	rjmp	.+56     	; 0x1902 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18ca:	c8 01       	movw	r24, r16
    18cc:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvIsQueueEmpty>
    18d0:	88 23       	and	r24, r24
    18d2:	89 f0       	breq	.+34     	; 0x18f6 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18d4:	6c 81       	ldd	r22, Y+4	; 0x04
    18d6:	7d 81       	ldd	r23, Y+5	; 0x05
    18d8:	c6 01       	movw	r24, r12
    18da:	0e 94 d0 05 	call	0xba0	; 0xba0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18de:	c8 01       	movw	r24, r16
    18e0:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18e4:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    18e8:	88 23       	and	r24, r24
    18ea:	11 f0       	breq	.+4      	; 0x18f0 <xQueuePeek+0xe0>
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	a6 cf       	rjmp	.-180    	; 0x183c <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    18f0:	0e 94 25 11 	call	0x224a	; 0x224a <vPortYield>
    18f4:	fb cf       	rjmp	.-10     	; 0x18ec <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18f6:	c8 01       	movw	r24, r16
    18f8:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18fc:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
    1900:	f5 cf       	rjmp	.-22     	; 0x18ec <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1902:	c8 01       	movw	r24, r16
    1904:	0e 94 63 09 	call	0x12c6	; 0x12c6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1908:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    190c:	c8 01       	movw	r24, r16
    190e:	0e 94 f6 08 	call	0x11ec	; 0x11ec <prvIsQueueEmpty>
    1912:	88 23       	and	r24, r24
    1914:	59 f3       	breq	.-42     	; 0x18ec <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1916:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1918:	0f 90       	pop	r0
    191a:	0f 90       	pop	r0
    191c:	0f 90       	pop	r0
    191e:	0f 90       	pop	r0
    1920:	0f 90       	pop	r0
    1922:	df 91       	pop	r29
    1924:	cf 91       	pop	r28
    1926:	1f 91       	pop	r17
    1928:	0f 91       	pop	r16
    192a:	ff 90       	pop	r15
    192c:	ef 90       	pop	r14
    192e:	df 90       	pop	r13
    1930:	cf 90       	pop	r12
    1932:	08 95       	ret

00001934 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1934:	ef 92       	push	r14
    1936:	ff 92       	push	r15
    1938:	0f 93       	push	r16
    193a:	1f 93       	push	r17
    193c:	cf 93       	push	r28
    193e:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1940:	fc 01       	movw	r30, r24
    1942:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1944:	00 23       	and	r16, r16
    1946:	e9 f0       	breq	.+58     	; 0x1982 <xQueueReceiveFromISR+0x4e>
    1948:	7a 01       	movw	r14, r20
    194a:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    194c:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    194e:	0e 94 49 09 	call	0x1292	; 0x1292 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1952:	01 50       	subi	r16, 0x01	; 1
    1954:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1956:	1f 3f       	cpi	r17, 0xFF	; 255
    1958:	81 f4       	brne	.+32     	; 0x197a <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    195a:	88 85       	ldd	r24, Y+8	; 0x08
    195c:	88 23       	and	r24, r24
    195e:	79 f0       	breq	.+30     	; 0x197e <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1960:	ce 01       	movw	r24, r28
    1962:	08 96       	adiw	r24, 0x08	; 8
    1964:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <xTaskRemoveFromEventList>
    1968:	88 23       	and	r24, r24
    196a:	49 f0       	breq	.+18     	; 0x197e <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    196c:	e1 14       	cp	r14, r1
    196e:	f1 04       	cpc	r15, r1
    1970:	31 f0       	breq	.+12     	; 0x197e <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1972:	81 e0       	ldi	r24, 0x01	; 1
    1974:	f7 01       	movw	r30, r14
    1976:	80 83       	st	Z, r24
    1978:	05 c0       	rjmp	.+10     	; 0x1984 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    197a:	1f 5f       	subi	r17, 0xFF	; 255
    197c:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	01 c0       	rjmp	.+2      	; 0x1984 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1982:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	1f 91       	pop	r17
    198a:	0f 91       	pop	r16
    198c:	ff 90       	pop	r15
    198e:	ef 90       	pop	r14
    1990:	08 95       	ret

00001992 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1992:	0f 93       	push	r16
    1994:	1f 93       	push	r17
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    199a:	fc 01       	movw	r30, r24
    199c:	22 8d       	ldd	r18, Z+26	; 0x1a
    199e:	22 23       	and	r18, r18
    19a0:	49 f0       	breq	.+18     	; 0x19b4 <xQueuePeekFromISR+0x22>
    19a2:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    19a4:	06 81       	ldd	r16, Z+6	; 0x06
    19a6:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19a8:	0e 94 49 09 	call	0x1292	; 0x1292 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    19ac:	1f 83       	std	Y+7, r17	; 0x07
    19ae:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	01 c0       	rjmp	.+2      	; 0x19b6 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    19b4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19b6:	df 91       	pop	r29
    19b8:	cf 91       	pop	r28
    19ba:	1f 91       	pop	r17
    19bc:	0f 91       	pop	r16
    19be:	08 95       	ret

000019c0 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    19c6:	fc 01       	movw	r30, r24
    19c8:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19ca:	0f 90       	pop	r0
    19cc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19ce:	08 95       	ret

000019d0 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19d0:	0f b6       	in	r0, 0x3f	; 63
    19d2:	f8 94       	cli
    19d4:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19d6:	fc 01       	movw	r30, r24
    19d8:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19da:	0f 90       	pop	r0
    19dc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    19de:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19e0:	82 1b       	sub	r24, r18
    19e2:	08 95       	ret

000019e4 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    19e4:	fc 01       	movw	r30, r24
    19e6:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19e8:	08 95       	ret

000019ea <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    19ea:	0c 94 69 10 	jmp	0x20d2	; 0x20d2 <vPortFree>

000019ee <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19ee:	fc 01       	movw	r30, r24
    19f0:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	91 11       	cpse	r25, r1
    19f6:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19f8:	08 95       	ret

000019fa <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    19fa:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19fc:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	23 8d       	ldd	r18, Z+27	; 0x1b
    1a02:	29 13       	cpse	r18, r25
    1a04:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1a06:	08 95       	ret

00001a08 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
    1a0c:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a0e:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a10:	0f b6       	in	r0, 0x3f	; 63
    1a12:	f8 94       	cli
    1a14:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a16:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a18:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a1a:	0f 90       	pop	r0
    1a1c:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a1e:	89 13       	cpse	r24, r25
    1a20:	0f c0       	rjmp	.+30     	; 0x1a40 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a22:	41 15       	cp	r20, r1
    1a24:	51 05       	cpc	r21, r1
    1a26:	49 f0       	breq	.+18     	; 0x1a3a <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1a28:	be 01       	movw	r22, r28
    1a2a:	68 5f       	subi	r22, 0xF8	; 248
    1a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a2e:	ca 01       	movw	r24, r20
    1a30:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a34:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a36:	8c ef       	ldi	r24, 0xFC	; 252
    1a38:	1b c0       	rjmp	.+54     	; 0x1a70 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a3a:	78 94       	sei
					return errQUEUE_FULL;
    1a3c:	80 e0       	ldi	r24, 0x00	; 0
    1a3e:	18 c0       	rjmp	.+48     	; 0x1a70 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1a40:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a42:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a44:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a46:	89 17       	cp	r24, r25
    1a48:	88 f4       	brcc	.+34     	; 0x1a6c <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a4a:	40 e0       	ldi	r20, 0x00	; 0
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	0e 94 01 09 	call	0x1202	; 0x1202 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a52:	89 89       	ldd	r24, Y+17	; 0x11
    1a54:	81 11       	cpse	r24, r1
    1a56:	02 c0       	rjmp	.+4      	; 0x1a5c <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1a58:	81 e0       	ldi	r24, 0x01	; 1
    1a5a:	09 c0       	rjmp	.+18     	; 0x1a6e <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a5c:	ce 01       	movw	r24, r28
    1a5e:	41 96       	adiw	r24, 0x11	; 17
    1a60:	0e 94 12 10 	call	0x2024	; 0x2024 <xCoRoutineRemoveFromEventList>
    1a64:	88 23       	and	r24, r24
    1a66:	c1 f3       	breq	.-16     	; 0x1a58 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1a68:	8b ef       	ldi	r24, 0xFB	; 251
    1a6a:	01 c0       	rjmp	.+2      	; 0x1a6e <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1a6c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a6e:	78 94       	sei

		return xReturn;
	}
    1a70:	df 91       	pop	r29
    1a72:	cf 91       	pop	r28
    1a74:	08 95       	ret

00001a76 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a76:	cf 93       	push	r28
    1a78:	df 93       	push	r29
    1a7a:	ec 01       	movw	r28, r24
    1a7c:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a7e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a80:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a82:	81 11       	cpse	r24, r1
    1a84:	0f c0       	rjmp	.+30     	; 0x1aa4 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a86:	41 15       	cp	r20, r1
    1a88:	51 05       	cpc	r21, r1
    1a8a:	49 f0       	breq	.+18     	; 0x1a9e <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a8c:	be 01       	movw	r22, r28
    1a8e:	6f 5e       	subi	r22, 0xEF	; 239
    1a90:	7f 4f       	sbci	r23, 0xFF	; 255
    1a92:	ca 01       	movw	r24, r20
    1a94:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a98:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a9a:	8c ef       	ldi	r24, 0xFC	; 252
    1a9c:	30 c0       	rjmp	.+96     	; 0x1afe <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a9e:	78 94       	sei
					return errQUEUE_FULL;
    1aa0:	80 e0       	ldi	r24, 0x00	; 0
    1aa2:	2d c0       	rjmp	.+90     	; 0x1afe <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1aa4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1aa6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aa8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1aaa:	88 23       	and	r24, r24
    1aac:	31 f1       	breq	.+76     	; 0x1afa <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1aae:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1ab0:	50 e0       	ldi	r21, 0x00	; 0
    1ab2:	2e 81       	ldd	r18, Y+6	; 0x06
    1ab4:	3f 81       	ldd	r19, Y+7	; 0x07
    1ab6:	24 0f       	add	r18, r20
    1ab8:	35 1f       	adc	r19, r21
    1aba:	3f 83       	std	Y+7, r19	; 0x07
    1abc:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1abe:	8c 81       	ldd	r24, Y+4	; 0x04
    1ac0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ac2:	28 17       	cp	r18, r24
    1ac4:	39 07       	cpc	r19, r25
    1ac6:	20 f0       	brcs	.+8      	; 0x1ad0 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1ac8:	88 81       	ld	r24, Y
    1aca:	99 81       	ldd	r25, Y+1	; 0x01
    1acc:	9f 83       	std	Y+7, r25	; 0x07
    1ace:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1ad0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ad2:	91 50       	subi	r25, 0x01	; 1
    1ad4:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1ad6:	6e 81       	ldd	r22, Y+6	; 0x06
    1ad8:	7f 81       	ldd	r23, Y+7	; 0x07
    1ada:	cf 01       	movw	r24, r30
    1adc:	0e 94 75 12 	call	0x24ea	; 0x24ea <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ae0:	88 85       	ldd	r24, Y+8	; 0x08
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	02 c0       	rjmp	.+4      	; 0x1aea <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	09 c0       	rjmp	.+18     	; 0x1afc <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1aea:	ce 01       	movw	r24, r28
    1aec:	08 96       	adiw	r24, 0x08	; 8
    1aee:	0e 94 12 10 	call	0x2024	; 0x2024 <xCoRoutineRemoveFromEventList>
    1af2:	88 23       	and	r24, r24
    1af4:	c1 f3       	breq	.-16     	; 0x1ae6 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1af6:	8b ef       	ldi	r24, 0xFB	; 251
    1af8:	01 c0       	rjmp	.+2      	; 0x1afc <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1afa:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1afc:	78 94       	sei

		return xReturn;
	}
    1afe:	df 91       	pop	r29
    1b00:	cf 91       	pop	r28
    1b02:	08 95       	ret

00001b04 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1b04:	0f 93       	push	r16
    1b06:	1f 93       	push	r17
    1b08:	cf 93       	push	r28
    1b0a:	8c 01       	movw	r16, r24
    1b0c:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b0e:	fc 01       	movw	r30, r24
    1b10:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b12:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b14:	98 17       	cp	r25, r24
    1b16:	10 f0       	brcs	.+4      	; 0x1b1c <xQueueCRSendFromISR+0x18>
    1b18:	4c 2f       	mov	r20, r28
    1b1a:	12 c0       	rjmp	.+36     	; 0x1b40 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b1c:	40 e0       	ldi	r20, 0x00	; 0
    1b1e:	c8 01       	movw	r24, r16
    1b20:	0e 94 01 09 	call	0x1202	; 0x1202 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1b24:	c1 11       	cpse	r28, r1
    1b26:	f8 cf       	rjmp	.-16     	; 0x1b18 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b28:	f8 01       	movw	r30, r16
    1b2a:	81 89       	ldd	r24, Z+17	; 0x11
    1b2c:	88 23       	and	r24, r24
    1b2e:	39 f0       	breq	.+14     	; 0x1b3e <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b30:	c8 01       	movw	r24, r16
    1b32:	41 96       	adiw	r24, 0x11	; 17
    1b34:	0e 94 12 10 	call	0x2024	; 0x2024 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1b38:	41 e0       	ldi	r20, 0x01	; 1
    1b3a:	81 11       	cpse	r24, r1
    1b3c:	01 c0       	rjmp	.+2      	; 0x1b40 <xQueueCRSendFromISR+0x3c>
    1b3e:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1b40:	84 2f       	mov	r24, r20
    1b42:	cf 91       	pop	r28
    1b44:	1f 91       	pop	r17
    1b46:	0f 91       	pop	r16
    1b48:	08 95       	ret

00001b4a <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1b4a:	0f 93       	push	r16
    1b4c:	1f 93       	push	r17
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b56:	88 23       	and	r24, r24
    1b58:	79 f1       	breq	.+94     	; 0x1bb8 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b5a:	24 8d       	ldd	r18, Z+28	; 0x1c
    1b5c:	30 e0       	ldi	r19, 0x00	; 0
    1b5e:	a6 81       	ldd	r26, Z+6	; 0x06
    1b60:	b7 81       	ldd	r27, Z+7	; 0x07
    1b62:	a2 0f       	add	r26, r18
    1b64:	b3 1f       	adc	r27, r19
    1b66:	b7 83       	std	Z+7, r27	; 0x07
    1b68:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b6a:	84 81       	ldd	r24, Z+4	; 0x04
    1b6c:	95 81       	ldd	r25, Z+5	; 0x05
    1b6e:	a8 17       	cp	r26, r24
    1b70:	b9 07       	cpc	r27, r25
    1b72:	20 f0       	brcs	.+8      	; 0x1b7c <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b74:	80 81       	ld	r24, Z
    1b76:	91 81       	ldd	r25, Z+1	; 0x01
    1b78:	97 83       	std	Z+7, r25	; 0x07
    1b7a:	86 83       	std	Z+6, r24	; 0x06
    1b7c:	8a 01       	movw	r16, r20
    1b7e:	cb 01       	movw	r24, r22
    1b80:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b82:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b84:	41 50       	subi	r20, 0x01	; 1
    1b86:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b88:	66 81       	ldd	r22, Z+6	; 0x06
    1b8a:	77 81       	ldd	r23, Z+7	; 0x07
    1b8c:	a9 01       	movw	r20, r18
    1b8e:	0e 94 75 12 	call	0x24ea	; 0x24ea <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b92:	f8 01       	movw	r30, r16
    1b94:	80 81       	ld	r24, Z
    1b96:	88 23       	and	r24, r24
    1b98:	11 f0       	breq	.+4      	; 0x1b9e <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b9a:	81 e0       	ldi	r24, 0x01	; 1
    1b9c:	0e c0       	rjmp	.+28     	; 0x1bba <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b9e:	88 85       	ldd	r24, Y+8	; 0x08
    1ba0:	88 23       	and	r24, r24
    1ba2:	d9 f3       	breq	.-10     	; 0x1b9a <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ba4:	ce 01       	movw	r24, r28
    1ba6:	08 96       	adiw	r24, 0x08	; 8
    1ba8:	0e 94 12 10 	call	0x2024	; 0x2024 <xCoRoutineRemoveFromEventList>
    1bac:	88 23       	and	r24, r24
    1bae:	a9 f3       	breq	.-22     	; 0x1b9a <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	f8 01       	movw	r30, r16
    1bb4:	80 83       	st	Z, r24
    1bb6:	01 c0       	rjmp	.+2      	; 0x1bba <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1bb8:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	1f 91       	pop	r17
    1bc0:	0f 91       	pop	r16
    1bc2:	08 95       	ret

00001bc4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1bc4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bc6:	03 96       	adiw	r24, 0x03	; 3
    1bc8:	92 83       	std	Z+2, r25	; 0x02
    1bca:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bcc:	2f ef       	ldi	r18, 0xFF	; 255
    1bce:	3f ef       	ldi	r19, 0xFF	; 255
    1bd0:	34 83       	std	Z+4, r19	; 0x04
    1bd2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bd4:	96 83       	std	Z+6, r25	; 0x06
    1bd6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bd8:	90 87       	std	Z+8, r25	; 0x08
    1bda:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bdc:	10 82       	st	Z, r1
    1bde:	08 95       	ret

00001be0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1be0:	fc 01       	movw	r30, r24
    1be2:	11 86       	std	Z+9, r1	; 0x09
    1be4:	10 86       	std	Z+8, r1	; 0x08
    1be6:	08 95       	ret

00001be8 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	9c 01       	movw	r18, r24
    1bee:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1bf0:	dc 01       	movw	r26, r24
    1bf2:	11 96       	adiw	r26, 0x01	; 1
    1bf4:	cd 91       	ld	r28, X+
    1bf6:	dc 91       	ld	r29, X
    1bf8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bfa:	d3 83       	std	Z+3, r29	; 0x03
    1bfc:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bfe:	8c 81       	ldd	r24, Y+4	; 0x04
    1c00:	9d 81       	ldd	r25, Y+5	; 0x05
    1c02:	95 83       	std	Z+5, r25	; 0x05
    1c04:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c06:	8c 81       	ldd	r24, Y+4	; 0x04
    1c08:	9d 81       	ldd	r25, Y+5	; 0x05
    1c0a:	dc 01       	movw	r26, r24
    1c0c:	13 96       	adiw	r26, 0x03	; 3
    1c0e:	7c 93       	st	X, r23
    1c10:	6e 93       	st	-X, r22
    1c12:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1c14:	7d 83       	std	Y+5, r23	; 0x05
    1c16:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1c18:	31 87       	std	Z+9, r19	; 0x09
    1c1a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c1c:	f9 01       	movw	r30, r18
    1c1e:	80 81       	ld	r24, Z
    1c20:	8f 5f       	subi	r24, 0xFF	; 255
    1c22:	80 83       	st	Z, r24
}
    1c24:	df 91       	pop	r29
    1c26:	cf 91       	pop	r28
    1c28:	08 95       	ret

00001c2a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c2a:	0f 93       	push	r16
    1c2c:	1f 93       	push	r17
    1c2e:	cf 93       	push	r28
    1c30:	df 93       	push	r29
    1c32:	8c 01       	movw	r16, r24
    1c34:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c36:	80 81       	ld	r24, Z
    1c38:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c3a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c3c:	2f ef       	ldi	r18, 0xFF	; 255
    1c3e:	92 07       	cpc	r25, r18
    1c40:	21 f4       	brne	.+8      	; 0x1c4a <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c42:	e8 01       	movw	r28, r16
    1c44:	af 81       	ldd	r26, Y+7	; 0x07
    1c46:	b8 85       	ldd	r27, Y+8	; 0x08
    1c48:	0e c0       	rjmp	.+28     	; 0x1c66 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c4a:	d8 01       	movw	r26, r16
    1c4c:	13 96       	adiw	r26, 0x03	; 3
    1c4e:	12 96       	adiw	r26, 0x02	; 2
    1c50:	2d 91       	ld	r18, X+
    1c52:	3c 91       	ld	r19, X
    1c54:	13 97       	sbiw	r26, 0x03	; 3
    1c56:	e9 01       	movw	r28, r18
    1c58:	48 81       	ld	r20, Y
    1c5a:	59 81       	ldd	r21, Y+1	; 0x01
    1c5c:	84 17       	cp	r24, r20
    1c5e:	95 07       	cpc	r25, r21
    1c60:	10 f0       	brcs	.+4      	; 0x1c66 <vListInsert+0x3c>
    1c62:	d9 01       	movw	r26, r18
    1c64:	f4 cf       	rjmp	.-24     	; 0x1c4e <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c66:	12 96       	adiw	r26, 0x02	; 2
    1c68:	8d 91       	ld	r24, X+
    1c6a:	9c 91       	ld	r25, X
    1c6c:	13 97       	sbiw	r26, 0x03	; 3
    1c6e:	93 83       	std	Z+3, r25	; 0x03
    1c70:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c72:	ec 01       	movw	r28, r24
    1c74:	fd 83       	std	Y+5, r31	; 0x05
    1c76:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c78:	b5 83       	std	Z+5, r27	; 0x05
    1c7a:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c7c:	13 96       	adiw	r26, 0x03	; 3
    1c7e:	fc 93       	st	X, r31
    1c80:	ee 93       	st	-X, r30
    1c82:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c84:	11 87       	std	Z+9, r17	; 0x09
    1c86:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c88:	f8 01       	movw	r30, r16
    1c8a:	80 81       	ld	r24, Z
    1c8c:	8f 5f       	subi	r24, 0xFF	; 255
    1c8e:	80 83       	st	Z, r24
}
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	1f 91       	pop	r17
    1c96:	0f 91       	pop	r16
    1c98:	08 95       	ret

00001c9a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1ca0:	a0 85       	ldd	r26, Z+8	; 0x08
    1ca2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ca4:	82 81       	ldd	r24, Z+2	; 0x02
    1ca6:	93 81       	ldd	r25, Z+3	; 0x03
    1ca8:	24 81       	ldd	r18, Z+4	; 0x04
    1caa:	35 81       	ldd	r19, Z+5	; 0x05
    1cac:	ec 01       	movw	r28, r24
    1cae:	3d 83       	std	Y+5, r19	; 0x05
    1cb0:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cb2:	c4 81       	ldd	r28, Z+4	; 0x04
    1cb4:	d5 81       	ldd	r29, Z+5	; 0x05
    1cb6:	9b 83       	std	Y+3, r25	; 0x03
    1cb8:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cba:	11 96       	adiw	r26, 0x01	; 1
    1cbc:	8d 91       	ld	r24, X+
    1cbe:	9c 91       	ld	r25, X
    1cc0:	12 97       	sbiw	r26, 0x02	; 2
    1cc2:	e8 17       	cp	r30, r24
    1cc4:	f9 07       	cpc	r31, r25
    1cc6:	21 f4       	brne	.+8      	; 0x1cd0 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cc8:	12 96       	adiw	r26, 0x02	; 2
    1cca:	dc 93       	st	X, r29
    1ccc:	ce 93       	st	-X, r28
    1cce:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1cd0:	11 86       	std	Z+9, r1	; 0x09
    1cd2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cd4:	8c 91       	ld	r24, X
    1cd6:	81 50       	subi	r24, 0x01	; 1
    1cd8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1cda:	8c 91       	ld	r24, X
}
    1cdc:	df 91       	pop	r29
    1cde:	cf 91       	pop	r28
    1ce0:	08 95       	ret

00001ce2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1ce2:	cf 92       	push	r12
    1ce4:	df 92       	push	r13
    1ce6:	ef 92       	push	r14
    1ce8:	ff 92       	push	r15
    1cea:	1f 93       	push	r17
    1cec:	cf 93       	push	r28
    1cee:	df 93       	push	r29
    1cf0:	6c 01       	movw	r12, r24
    1cf2:	16 2f       	mov	r17, r22
    1cf4:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1cf6:	8a e1       	ldi	r24, 0x1A	; 26
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	0e 94 37 10 	call	0x206e	; 0x206e <pvPortMalloc>
    1cfe:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1d00:	89 2b       	or	r24, r25
    1d02:	09 f4       	brne	.+2      	; 0x1d06 <xCoRoutineCreate+0x24>
    1d04:	57 c0       	rjmp	.+174    	; 0x1db4 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1d06:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1d0a:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1d0e:	89 2b       	or	r24, r25
    1d10:	21 f5       	brne	.+72     	; 0x1d5a <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1d12:	d0 93 a5 01 	sts	0x01A5, r29	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1d16:	c0 93 a4 01 	sts	0x01A4, r28	; 0x8001a4 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1d1a:	8c ec       	ldi	r24, 0xCC	; 204
    1d1c:	91 e0       	ldi	r25, 0x01	; 1
    1d1e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
    1d22:	85 ed       	ldi	r24, 0xD5	; 213
    1d24:	91 e0       	ldi	r25, 0x01	; 1
    1d26:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1d2a:	83 ec       	ldi	r24, 0xC3	; 195
    1d2c:	91 e0       	ldi	r25, 0x01	; 1
    1d2e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1d32:	8a eb       	ldi	r24, 0xBA	; 186
    1d34:	91 e0       	ldi	r25, 0x01	; 1
    1d36:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1d3a:	8d ea       	ldi	r24, 0xAD	; 173
    1d3c:	91 e0       	ldi	r25, 0x01	; 1
    1d3e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1d42:	83 ec       	ldi	r24, 0xC3	; 195
    1d44:	91 e0       	ldi	r25, 0x01	; 1
    1d46:	90 93 b9 01 	sts	0x01B9, r25	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    1d4a:	80 93 b8 01 	sts	0x01B8, r24	; 0x8001b8 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1d4e:	8a eb       	ldi	r24, 0xBA	; 186
    1d50:	91 e0       	ldi	r25, 0x01	; 1
    1d52:	90 93 b7 01 	sts	0x01B7, r25	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    1d56:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    1d5a:	11 11       	cpse	r17, r1
    1d5c:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1d5e:	19 8e       	std	Y+25, r1	; 0x19
    1d60:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1d62:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1d64:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1d66:	fe 01       	movw	r30, r28
    1d68:	c1 92       	st	Z+, r12
    1d6a:	d1 92       	st	Z+, r13
    1d6c:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1d6e:	cf 01       	movw	r24, r30
    1d70:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d74:	ce 01       	movw	r24, r28
    1d76:	0c 96       	adiw	r24, 0x0c	; 12
    1d78:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d7c:	d9 87       	std	Y+9, r29	; 0x09
    1d7e:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d80:	db 8b       	std	Y+19, r29	; 0x13
    1d82:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d84:	82 e0       	ldi	r24, 0x02	; 2
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	81 1b       	sub	r24, r17
    1d8a:	91 09       	sbc	r25, r1
    1d8c:	9d 87       	std	Y+13, r25	; 0x0d
    1d8e:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d90:	8e 89       	ldd	r24, Y+22	; 0x16
    1d92:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1d96:	98 17       	cp	r25, r24
    1d98:	10 f4       	brcc	.+4      	; 0x1d9e <xCoRoutineCreate+0xbc>
    1d9a:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1d9e:	f9 e0       	ldi	r31, 0x09	; 9
    1da0:	8f 9f       	mul	r24, r31
    1da2:	c0 01       	movw	r24, r0
    1da4:	11 24       	eor	r1, r1
    1da6:	b7 01       	movw	r22, r14
    1da8:	84 53       	subi	r24, 0x34	; 52
    1daa:	9e 4f       	sbci	r25, 0xFE	; 254
    1dac:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

		xReturn = pdPASS;
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	01 c0       	rjmp	.+2      	; 0x1db6 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1db4:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1db6:	df 91       	pop	r29
    1db8:	cf 91       	pop	r28
    1dba:	1f 91       	pop	r17
    1dbc:	ff 90       	pop	r15
    1dbe:	ef 90       	pop	r14
    1dc0:	df 90       	pop	r13
    1dc2:	cf 90       	pop	r12
    1dc4:	08 95       	ret

00001dc6 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1dc6:	0f 93       	push	r16
    1dc8:	1f 93       	push	r17
    1dca:	cf 93       	push	r28
    1dcc:	df 93       	push	r29
    1dce:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1dd0:	c0 91 aa 01 	lds	r28, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1dd4:	d0 91 ab 01 	lds	r29, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1dd8:	c8 0f       	add	r28, r24
    1dda:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ddc:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1de0:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1de4:	02 96       	adiw	r24, 0x02	; 2
    1de6:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1dea:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1dee:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1df2:	d3 83       	std	Z+3, r29	; 0x03
    1df4:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1df6:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1dfa:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1dfe:	bf 01       	movw	r22, r30
    1e00:	6e 5f       	subi	r22, 0xFE	; 254
    1e02:	7f 4f       	sbci	r23, 0xFF	; 255
    1e04:	c8 17       	cp	r28, r24
    1e06:	d9 07       	cpc	r29, r25
    1e08:	28 f4       	brcc	.+10     	; 0x1e14 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e0a:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    1e0e:	90 91 b7 01 	lds	r25, 0x01B7	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    1e12:	04 c0       	rjmp	.+8      	; 0x1e1c <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e14:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <pxDelayedCoRoutineList>
    1e18:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    1e1c:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <vListInsert>
	}

	if( pxEventList )
    1e20:	01 15       	cp	r16, r1
    1e22:	11 05       	cpc	r17, r1
    1e24:	69 f0       	breq	.+26     	; 0x1e40 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e26:	60 91 a4 01 	lds	r22, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1e2a:	70 91 a5 01 	lds	r23, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1e2e:	64 5f       	subi	r22, 0xF4	; 244
    1e30:	7f 4f       	sbci	r23, 0xFF	; 255
    1e32:	c8 01       	movw	r24, r16
	}
}
    1e34:	df 91       	pop	r29
    1e36:	cf 91       	pop	r28
    1e38:	1f 91       	pop	r17
    1e3a:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e3c:	0c 94 15 0e 	jmp	0x1c2a	; 0x1c2a <vListInsert>
	}
}
    1e40:	df 91       	pop	r29
    1e42:	cf 91       	pop	r28
    1e44:	1f 91       	pop	r17
    1e46:	0f 91       	pop	r16
    1e48:	08 95       	ret

00001e4a <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e4a:	ff 92       	push	r15
    1e4c:	0f 93       	push	r16
    1e4e:	1f 93       	push	r17
    1e50:	cf 93       	push	r28
    1e52:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e54:	99 e0       	ldi	r25, 0x09	; 9
    1e56:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1e58:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <xPendingReadyCoRoutineList>
    1e5c:	88 23       	and	r24, r24
    1e5e:	11 f1       	breq	.+68     	; 0x1ea4 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1e60:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1e62:	e0 91 b2 01 	lds	r30, 0x01B2	; 0x8001b2 <xPendingReadyCoRoutineList+0x5>
    1e66:	f0 91 b3 01 	lds	r31, 0x01B3	; 0x8001b3 <xPendingReadyCoRoutineList+0x6>
    1e6a:	c6 81       	ldd	r28, Z+6	; 0x06
    1e6c:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e6e:	ce 01       	movw	r24, r28
    1e70:	0c 96       	adiw	r24, 0x0c	; 12
    1e72:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e76:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e78:	8e 01       	movw	r16, r28
    1e7a:	0e 5f       	subi	r16, 0xFE	; 254
    1e7c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e7e:	c8 01       	movw	r24, r16
    1e80:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e84:	8e 89       	ldd	r24, Y+22	; 0x16
    1e86:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1e8a:	98 17       	cp	r25, r24
    1e8c:	10 f4       	brcc	.+4      	; 0x1e92 <vCoRoutineSchedule+0x48>
    1e8e:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1e92:	f8 9e       	mul	r15, r24
    1e94:	c0 01       	movw	r24, r0
    1e96:	11 24       	eor	r1, r1
    1e98:	b8 01       	movw	r22, r16
    1e9a:	84 53       	subi	r24, 0x34	; 52
    1e9c:	9e 4f       	sbci	r25, 0xFE	; 254
    1e9e:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
    1ea2:	da cf       	rjmp	.-76     	; 0x1e58 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1ea4:	0e 94 b5 03 	call	0x76a	; 0x76a <xTaskGetTickCount>
    1ea8:	20 91 a8 01 	lds	r18, 0x01A8	; 0x8001a8 <xLastTickCount>
    1eac:	30 91 a9 01 	lds	r19, 0x01A9	; 0x8001a9 <xLastTickCount+0x1>
    1eb0:	82 1b       	sub	r24, r18
    1eb2:	93 0b       	sbc	r25, r19
    1eb4:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <xPassedTicks+0x1>
    1eb8:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1ebc:	89 e0       	ldi	r24, 0x09	; 9
    1ebe:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1ec0:	20 91 a6 01 	lds	r18, 0x01A6	; 0x8001a6 <xPassedTicks>
    1ec4:	30 91 a7 01 	lds	r19, 0x01A7	; 0x8001a7 <xPassedTicks+0x1>
    1ec8:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1ecc:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1ed0:	21 15       	cp	r18, r1
    1ed2:	31 05       	cpc	r19, r1
    1ed4:	09 f4       	brne	.+2      	; 0x1ed8 <vCoRoutineSchedule+0x8e>
    1ed6:	54 c0       	rjmp	.+168    	; 0x1f80 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1ed8:	01 96       	adiw	r24, 0x01	; 1
    1eda:	90 93 ab 01 	sts	0x01AB, r25	; 0x8001ab <xCoRoutineTickCount+0x1>
    1ede:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <xCoRoutineTickCount>
		xPassedTicks--;
    1ee2:	21 50       	subi	r18, 0x01	; 1
    1ee4:	31 09       	sbc	r19, r1
    1ee6:	30 93 a7 01 	sts	0x01A7, r19	; 0x8001a7 <xPassedTicks+0x1>
    1eea:	20 93 a6 01 	sts	0x01A6, r18	; 0x8001a6 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1eee:	89 2b       	or	r24, r25
    1ef0:	09 f0       	breq	.+2      	; 0x1ef4 <vCoRoutineSchedule+0xaa>
    1ef2:	3e c0       	rjmp	.+124    	; 0x1f70 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1ef4:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <pxDelayedCoRoutineList>
    1ef8:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1efc:	20 91 b6 01 	lds	r18, 0x01B6	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    1f00:	30 91 b7 01 	lds	r19, 0x01B7	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    1f04:	30 93 b9 01 	sts	0x01B9, r19	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    1f08:	20 93 b8 01 	sts	0x01B8, r18	; 0x8001b8 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1f0c:	90 93 b7 01 	sts	0x01B7, r25	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    1f10:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    1f14:	2d c0       	rjmp	.+90     	; 0x1f70 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1f16:	05 80       	ldd	r0, Z+5	; 0x05
    1f18:	f6 81       	ldd	r31, Z+6	; 0x06
    1f1a:	e0 2d       	mov	r30, r0
    1f1c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f1e:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1f20:	2a 81       	ldd	r18, Y+2	; 0x02
    1f22:	3b 81       	ldd	r19, Y+3	; 0x03
    1f24:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1f28:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1f2c:	82 17       	cp	r24, r18
    1f2e:	93 07       	cpc	r25, r19
    1f30:	38 f2       	brcs	.-114    	; 0x1ec0 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1f32:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1f34:	8e 01       	movw	r16, r28
    1f36:	0e 5f       	subi	r16, 0xFE	; 254
    1f38:	1f 4f       	sbci	r17, 0xFF	; 255
    1f3a:	c8 01       	movw	r24, r16
    1f3c:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1f40:	8c 89       	ldd	r24, Y+20	; 0x14
    1f42:	9d 89       	ldd	r25, Y+21	; 0x15
    1f44:	89 2b       	or	r24, r25
    1f46:	21 f0       	breq	.+8      	; 0x1f50 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1f48:	ce 01       	movw	r24, r28
    1f4a:	0c 96       	adiw	r24, 0x0c	; 12
    1f4c:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1f50:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f52:	8e 89       	ldd	r24, Y+22	; 0x16
    1f54:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1f58:	98 17       	cp	r25, r24
    1f5a:	10 f4       	brcc	.+4      	; 0x1f60 <vCoRoutineSchedule+0x116>
    1f5c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1f60:	f8 9e       	mul	r15, r24
    1f62:	c0 01       	movw	r24, r0
    1f64:	11 24       	eor	r1, r1
    1f66:	b8 01       	movw	r22, r16
    1f68:	84 53       	subi	r24, 0x34	; 52
    1f6a:	9e 4f       	sbci	r25, 0xFE	; 254
    1f6c:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f70:	e0 91 b8 01 	lds	r30, 0x01B8	; 0x8001b8 <pxDelayedCoRoutineList>
    1f74:	f0 91 b9 01 	lds	r31, 0x01B9	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    1f78:	80 81       	ld	r24, Z
    1f7a:	81 11       	cpse	r24, r1
    1f7c:	cc cf       	rjmp	.-104    	; 0x1f16 <vCoRoutineSchedule+0xcc>
    1f7e:	a0 cf       	rjmp	.-192    	; 0x1ec0 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f80:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <xLastTickCount+0x1>
    1f84:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <xLastTickCount>
    1f88:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f8c:	69 e0       	ldi	r22, 0x09	; 9
    1f8e:	48 2f       	mov	r20, r24
    1f90:	50 e0       	ldi	r21, 0x00	; 0
    1f92:	64 9f       	mul	r22, r20
    1f94:	90 01       	movw	r18, r0
    1f96:	65 9f       	mul	r22, r21
    1f98:	30 0d       	add	r19, r0
    1f9a:	11 24       	eor	r1, r1
    1f9c:	f9 01       	movw	r30, r18
    1f9e:	e4 53       	subi	r30, 0x34	; 52
    1fa0:	fe 4f       	sbci	r31, 0xFE	; 254
    1fa2:	90 81       	ld	r25, Z
    1fa4:	91 11       	cpse	r25, r1
    1fa6:	0c c0       	rjmp	.+24     	; 0x1fc0 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1fa8:	81 11       	cpse	r24, r1
    1faa:	08 c0       	rjmp	.+16     	; 0x1fbc <vCoRoutineSchedule+0x172>
    1fac:	10 92 ac 01 	sts	0x01AC, r1	; 0x8001ac <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1fb0:	df 91       	pop	r29
    1fb2:	cf 91       	pop	r28
    1fb4:	1f 91       	pop	r17
    1fb6:	0f 91       	pop	r16
    1fb8:	ff 90       	pop	r15
    1fba:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1fbc:	81 50       	subi	r24, 0x01	; 1
    1fbe:	e7 cf       	rjmp	.-50     	; 0x1f8e <vCoRoutineSchedule+0x144>
    1fc0:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1fc4:	a1 81       	ldd	r26, Z+1	; 0x01
    1fc6:	b2 81       	ldd	r27, Z+2	; 0x02
    1fc8:	12 96       	adiw	r26, 0x02	; 2
    1fca:	0d 90       	ld	r0, X+
    1fcc:	bc 91       	ld	r27, X
    1fce:	a0 2d       	mov	r26, r0
    1fd0:	b2 83       	std	Z+2, r27	; 0x02
    1fd2:	a1 83       	std	Z+1, r26	; 0x01
    1fd4:	21 53       	subi	r18, 0x31	; 49
    1fd6:	3e 4f       	sbci	r19, 0xFE	; 254
    1fd8:	a2 17       	cp	r26, r18
    1fda:	b3 07       	cpc	r27, r19
    1fdc:	31 f4       	brne	.+12     	; 0x1fea <vCoRoutineSchedule+0x1a0>
    1fde:	12 96       	adiw	r26, 0x02	; 2
    1fe0:	8d 91       	ld	r24, X+
    1fe2:	9c 91       	ld	r25, X
    1fe4:	13 97       	sbiw	r26, 0x03	; 3
    1fe6:	92 83       	std	Z+2, r25	; 0x02
    1fe8:	81 83       	std	Z+1, r24	; 0x01
    1fea:	89 e0       	ldi	r24, 0x09	; 9
    1fec:	84 9f       	mul	r24, r20
    1fee:	f0 01       	movw	r30, r0
    1ff0:	85 9f       	mul	r24, r21
    1ff2:	f0 0d       	add	r31, r0
    1ff4:	11 24       	eor	r1, r1
    1ff6:	e4 53       	subi	r30, 0x34	; 52
    1ff8:	fe 4f       	sbci	r31, 0xFE	; 254
    1ffa:	01 80       	ldd	r0, Z+1	; 0x01
    1ffc:	f2 81       	ldd	r31, Z+2	; 0x02
    1ffe:	e0 2d       	mov	r30, r0
    2000:	86 81       	ldd	r24, Z+6	; 0x06
    2002:	97 81       	ldd	r25, Z+7	; 0x07
    2004:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    2008:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    200c:	dc 01       	movw	r26, r24
    200e:	ed 91       	ld	r30, X+
    2010:	fc 91       	ld	r31, X
    2012:	11 97       	sbiw	r26, 0x01	; 1
    2014:	57 96       	adiw	r26, 0x17	; 23
    2016:	6c 91       	ld	r22, X

	return;
}
    2018:	df 91       	pop	r29
    201a:	cf 91       	pop	r28
    201c:	1f 91       	pop	r17
    201e:	0f 91       	pop	r16
    2020:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2022:	09 94       	ijmp

00002024 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2024:	0f 93       	push	r16
    2026:	1f 93       	push	r17
    2028:	cf 93       	push	r28
    202a:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    202c:	dc 01       	movw	r26, r24
    202e:	15 96       	adiw	r26, 0x05	; 5
    2030:	ed 91       	ld	r30, X+
    2032:	fc 91       	ld	r31, X
    2034:	16 97       	sbiw	r26, 0x06	; 6
    2036:	c6 81       	ldd	r28, Z+6	; 0x06
    2038:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    203a:	8e 01       	movw	r16, r28
    203c:	04 5f       	subi	r16, 0xF4	; 244
    203e:	1f 4f       	sbci	r17, 0xFF	; 255
    2040:	c8 01       	movw	r24, r16
    2042:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2046:	b8 01       	movw	r22, r16
    2048:	8d ea       	ldi	r24, 0xAD	; 173
    204a:	91 e0       	ldi	r25, 0x01	; 1
    204c:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2050:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    2054:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	2e 89       	ldd	r18, Y+22	; 0x16
    205c:	96 89       	ldd	r25, Z+22	; 0x16
    205e:	29 17       	cp	r18, r25
    2060:	08 f4       	brcc	.+2      	; 0x2064 <xCoRoutineRemoveFromEventList+0x40>
    2062:	80 e0       	ldi	r24, 0x00	; 0
}
    2064:	df 91       	pop	r29
    2066:	cf 91       	pop	r28
    2068:	1f 91       	pop	r17
    206a:	0f 91       	pop	r16
    206c:	08 95       	ret

0000206e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    206e:	cf 93       	push	r28
    2070:	df 93       	push	r29
    2072:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2074:	0e 94 af 03 	call	0x75e	; 0x75e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2078:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <pucAlignedHeap.2081>
    207c:	90 91 df 01 	lds	r25, 0x01DF	; 0x8001df <pucAlignedHeap.2081+0x1>
    2080:	89 2b       	or	r24, r25
    2082:	31 f4       	brne	.+12     	; 0x2090 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2084:	83 ee       	ldi	r24, 0xE3	; 227
    2086:	91 e0       	ldi	r25, 0x01	; 1
    2088:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <pucAlignedHeap.2081+0x1>
    208c:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2090:	20 91 e0 01 	lds	r18, 0x01E0	; 0x8001e0 <xNextFreeByte>
    2094:	30 91 e1 01 	lds	r19, 0x01E1	; 0x8001e1 <xNextFreeByte+0x1>
    2098:	c9 01       	movw	r24, r18
    209a:	8c 0f       	add	r24, r28
    209c:	9d 1f       	adc	r25, r29
    209e:	8b 3d       	cpi	r24, 0xDB	; 219
    20a0:	45 e0       	ldi	r20, 0x05	; 5
    20a2:	94 07       	cpc	r25, r20
    20a4:	70 f4       	brcc	.+28     	; 0x20c2 <pvPortMalloc+0x54>
    20a6:	28 17       	cp	r18, r24
    20a8:	39 07       	cpc	r19, r25
    20aa:	58 f4       	brcc	.+22     	; 0x20c2 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    20ac:	c0 91 de 01 	lds	r28, 0x01DE	; 0x8001de <pucAlignedHeap.2081>
    20b0:	d0 91 df 01 	lds	r29, 0x01DF	; 0x8001df <pucAlignedHeap.2081+0x1>
    20b4:	c2 0f       	add	r28, r18
    20b6:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    20b8:	90 93 e1 01 	sts	0x01E1, r25	; 0x8001e1 <xNextFreeByte+0x1>
    20bc:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <xNextFreeByte>
    20c0:	02 c0       	rjmp	.+4      	; 0x20c6 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    20c2:	c0 e0       	ldi	r28, 0x00	; 0
    20c4:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    20c6:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    20ca:	ce 01       	movw	r24, r28
    20cc:	df 91       	pop	r29
    20ce:	cf 91       	pop	r28
    20d0:	08 95       	ret

000020d2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    20d2:	08 95       	ret

000020d4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    20d4:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <xNextFreeByte+0x1>
    20d8:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <xNextFreeByte>
    20dc:	08 95       	ret

000020de <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    20de:	20 91 e0 01 	lds	r18, 0x01E0	; 0x8001e0 <xNextFreeByte>
    20e2:	30 91 e1 01 	lds	r19, 0x01E1	; 0x8001e1 <xNextFreeByte+0x1>
}
    20e6:	8b ed       	ldi	r24, 0xDB	; 219
    20e8:	95 e0       	ldi	r25, 0x05	; 5
    20ea:	82 1b       	sub	r24, r18
    20ec:	93 0b       	sbc	r25, r19
    20ee:	08 95       	ret

000020f0 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    20f0:	31 e1       	ldi	r19, 0x11	; 17
    20f2:	fc 01       	movw	r30, r24
    20f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	22 e2       	ldi	r18, 0x22	; 34
    20fa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	a3 e3       	ldi	r26, 0x33	; 51
    2100:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2106:	31 97       	sbiw	r30, 0x01	; 1
    2108:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    210a:	31 97       	sbiw	r30, 0x01	; 1
    210c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	60 e8       	ldi	r22, 0x80	; 128
    2112:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2114:	31 97       	sbiw	r30, 0x01	; 1
    2116:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2118:	31 97       	sbiw	r30, 0x01	; 1
    211a:	62 e0       	ldi	r22, 0x02	; 2
    211c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    211e:	31 97       	sbiw	r30, 0x01	; 1
    2120:	63 e0       	ldi	r22, 0x03	; 3
    2122:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2124:	31 97       	sbiw	r30, 0x01	; 1
    2126:	64 e0       	ldi	r22, 0x04	; 4
    2128:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    212a:	31 97       	sbiw	r30, 0x01	; 1
    212c:	65 e0       	ldi	r22, 0x05	; 5
    212e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	66 e0       	ldi	r22, 0x06	; 6
    2134:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	67 e0       	ldi	r22, 0x07	; 7
    213a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	68 e0       	ldi	r22, 0x08	; 8
    2140:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	69 e0       	ldi	r22, 0x09	; 9
    2146:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	60 e1       	ldi	r22, 0x10	; 16
    214c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    214e:	31 97       	sbiw	r30, 0x01	; 1
    2150:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2152:	31 97       	sbiw	r30, 0x01	; 1
    2154:	32 e1       	ldi	r19, 0x12	; 18
    2156:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2158:	31 97       	sbiw	r30, 0x01	; 1
    215a:	33 e1       	ldi	r19, 0x13	; 19
    215c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    215e:	31 97       	sbiw	r30, 0x01	; 1
    2160:	34 e1       	ldi	r19, 0x14	; 20
    2162:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2164:	31 97       	sbiw	r30, 0x01	; 1
    2166:	35 e1       	ldi	r19, 0x15	; 21
    2168:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    216a:	31 97       	sbiw	r30, 0x01	; 1
    216c:	36 e1       	ldi	r19, 0x16	; 22
    216e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2170:	31 97       	sbiw	r30, 0x01	; 1
    2172:	37 e1       	ldi	r19, 0x17	; 23
    2174:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2176:	31 97       	sbiw	r30, 0x01	; 1
    2178:	38 e1       	ldi	r19, 0x18	; 24
    217a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    217c:	31 97       	sbiw	r30, 0x01	; 1
    217e:	39 e1       	ldi	r19, 0x19	; 25
    2180:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2182:	31 97       	sbiw	r30, 0x01	; 1
    2184:	30 e2       	ldi	r19, 0x20	; 32
    2186:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2188:	31 97       	sbiw	r30, 0x01	; 1
    218a:	31 e2       	ldi	r19, 0x21	; 33
    218c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    218e:	31 97       	sbiw	r30, 0x01	; 1
    2190:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2192:	31 97       	sbiw	r30, 0x01	; 1
    2194:	23 e2       	ldi	r18, 0x23	; 35
    2196:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2198:	31 97       	sbiw	r30, 0x01	; 1
    219a:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    219c:	31 97       	sbiw	r30, 0x01	; 1
    219e:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    21a0:	31 97       	sbiw	r30, 0x01	; 1
    21a2:	26 e2       	ldi	r18, 0x26	; 38
    21a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    21a6:	31 97       	sbiw	r30, 0x01	; 1
    21a8:	27 e2       	ldi	r18, 0x27	; 39
    21aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    21ac:	31 97       	sbiw	r30, 0x01	; 1
    21ae:	28 e2       	ldi	r18, 0x28	; 40
    21b0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    21b2:	31 97       	sbiw	r30, 0x01	; 1
    21b4:	29 e2       	ldi	r18, 0x29	; 41
    21b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    21b8:	31 97       	sbiw	r30, 0x01	; 1
    21ba:	20 e3       	ldi	r18, 0x30	; 48
    21bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    21be:	31 97       	sbiw	r30, 0x01	; 1
    21c0:	21 e3       	ldi	r18, 0x31	; 49
    21c2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    21c4:	86 97       	sbiw	r24, 0x26	; 38
    21c6:	08 95       	ret

000021c8 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    21c8:	89 ef       	ldi	r24, 0xF9	; 249
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    21d0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    21d4:	e0 e8       	ldi	r30, 0x80	; 128
    21d6:	f0 e0       	ldi	r31, 0x00	; 0
    21d8:	80 81       	ld	r24, Z
    21da:	8c 7f       	andi	r24, 0xFC	; 252
    21dc:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21de:	8b e0       	ldi	r24, 0x0B	; 11
    21e0:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    21e4:	ef e6       	ldi	r30, 0x6F	; 111
    21e6:	f0 e0       	ldi	r31, 0x00	; 0
    21e8:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21ea:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    21ec:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21ee:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    21f2:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    21f6:	cd 91       	ld	r28, X+
    21f8:	cd bf       	out	0x3d, r28	; 61
    21fa:	dd 91       	ld	r29, X+
    21fc:	de bf       	out	0x3e, r29	; 62
    21fe:	ff 91       	pop	r31
    2200:	ef 91       	pop	r30
    2202:	df 91       	pop	r29
    2204:	cf 91       	pop	r28
    2206:	bf 91       	pop	r27
    2208:	af 91       	pop	r26
    220a:	9f 91       	pop	r25
    220c:	8f 91       	pop	r24
    220e:	7f 91       	pop	r23
    2210:	6f 91       	pop	r22
    2212:	5f 91       	pop	r21
    2214:	4f 91       	pop	r20
    2216:	3f 91       	pop	r19
    2218:	2f 91       	pop	r18
    221a:	1f 91       	pop	r17
    221c:	0f 91       	pop	r16
    221e:	ff 90       	pop	r15
    2220:	ef 90       	pop	r14
    2222:	df 90       	pop	r13
    2224:	cf 90       	pop	r12
    2226:	bf 90       	pop	r11
    2228:	af 90       	pop	r10
    222a:	9f 90       	pop	r9
    222c:	8f 90       	pop	r8
    222e:	7f 90       	pop	r7
    2230:	6f 90       	pop	r6
    2232:	5f 90       	pop	r5
    2234:	4f 90       	pop	r4
    2236:	3f 90       	pop	r3
    2238:	2f 90       	pop	r2
    223a:	1f 90       	pop	r1
    223c:	0f 90       	pop	r0
    223e:	0f be       	out	0x3f, r0	; 63
    2240:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2242:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2244:	81 e0       	ldi	r24, 0x01	; 1
    2246:	08 95       	ret

00002248 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2248:	08 95       	ret

0000224a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    224a:	0f 92       	push	r0
    224c:	0f b6       	in	r0, 0x3f	; 63
    224e:	f8 94       	cli
    2250:	0f 92       	push	r0
    2252:	1f 92       	push	r1
    2254:	11 24       	eor	r1, r1
    2256:	2f 92       	push	r2
    2258:	3f 92       	push	r3
    225a:	4f 92       	push	r4
    225c:	5f 92       	push	r5
    225e:	6f 92       	push	r6
    2260:	7f 92       	push	r7
    2262:	8f 92       	push	r8
    2264:	9f 92       	push	r9
    2266:	af 92       	push	r10
    2268:	bf 92       	push	r11
    226a:	cf 92       	push	r12
    226c:	df 92       	push	r13
    226e:	ef 92       	push	r14
    2270:	ff 92       	push	r15
    2272:	0f 93       	push	r16
    2274:	1f 93       	push	r17
    2276:	2f 93       	push	r18
    2278:	3f 93       	push	r19
    227a:	4f 93       	push	r20
    227c:	5f 93       	push	r21
    227e:	6f 93       	push	r22
    2280:	7f 93       	push	r23
    2282:	8f 93       	push	r24
    2284:	9f 93       	push	r25
    2286:	af 93       	push	r26
    2288:	bf 93       	push	r27
    228a:	cf 93       	push	r28
    228c:	df 93       	push	r29
    228e:	ef 93       	push	r30
    2290:	ff 93       	push	r31
    2292:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    2296:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    229a:	0d b6       	in	r0, 0x3d	; 61
    229c:	0d 92       	st	X+, r0
    229e:	0e b6       	in	r0, 0x3e	; 62
    22a0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    22a2:	0e 94 37 05 	call	0xa6e	; 0xa6e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22a6:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    22aa:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    22ae:	cd 91       	ld	r28, X+
    22b0:	cd bf       	out	0x3d, r28	; 61
    22b2:	dd 91       	ld	r29, X+
    22b4:	de bf       	out	0x3e, r29	; 62
    22b6:	ff 91       	pop	r31
    22b8:	ef 91       	pop	r30
    22ba:	df 91       	pop	r29
    22bc:	cf 91       	pop	r28
    22be:	bf 91       	pop	r27
    22c0:	af 91       	pop	r26
    22c2:	9f 91       	pop	r25
    22c4:	8f 91       	pop	r24
    22c6:	7f 91       	pop	r23
    22c8:	6f 91       	pop	r22
    22ca:	5f 91       	pop	r21
    22cc:	4f 91       	pop	r20
    22ce:	3f 91       	pop	r19
    22d0:	2f 91       	pop	r18
    22d2:	1f 91       	pop	r17
    22d4:	0f 91       	pop	r16
    22d6:	ff 90       	pop	r15
    22d8:	ef 90       	pop	r14
    22da:	df 90       	pop	r13
    22dc:	cf 90       	pop	r12
    22de:	bf 90       	pop	r11
    22e0:	af 90       	pop	r10
    22e2:	9f 90       	pop	r9
    22e4:	8f 90       	pop	r8
    22e6:	7f 90       	pop	r7
    22e8:	6f 90       	pop	r6
    22ea:	5f 90       	pop	r5
    22ec:	4f 90       	pop	r4
    22ee:	3f 90       	pop	r3
    22f0:	2f 90       	pop	r2
    22f2:	1f 90       	pop	r1
    22f4:	0f 90       	pop	r0
    22f6:	0f be       	out	0x3f, r0	; 63
    22f8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22fa:	08 95       	ret

000022fc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22fc:	0f 92       	push	r0
    22fe:	0f b6       	in	r0, 0x3f	; 63
    2300:	f8 94       	cli
    2302:	0f 92       	push	r0
    2304:	1f 92       	push	r1
    2306:	11 24       	eor	r1, r1
    2308:	2f 92       	push	r2
    230a:	3f 92       	push	r3
    230c:	4f 92       	push	r4
    230e:	5f 92       	push	r5
    2310:	6f 92       	push	r6
    2312:	7f 92       	push	r7
    2314:	8f 92       	push	r8
    2316:	9f 92       	push	r9
    2318:	af 92       	push	r10
    231a:	bf 92       	push	r11
    231c:	cf 92       	push	r12
    231e:	df 92       	push	r13
    2320:	ef 92       	push	r14
    2322:	ff 92       	push	r15
    2324:	0f 93       	push	r16
    2326:	1f 93       	push	r17
    2328:	2f 93       	push	r18
    232a:	3f 93       	push	r19
    232c:	4f 93       	push	r20
    232e:	5f 93       	push	r21
    2330:	6f 93       	push	r22
    2332:	7f 93       	push	r23
    2334:	8f 93       	push	r24
    2336:	9f 93       	push	r25
    2338:	af 93       	push	r26
    233a:	bf 93       	push	r27
    233c:	cf 93       	push	r28
    233e:	df 93       	push	r29
    2340:	ef 93       	push	r30
    2342:	ff 93       	push	r31
    2344:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    2348:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    234c:	0d b6       	in	r0, 0x3d	; 61
    234e:	0d 92       	st	X+, r0
    2350:	0e b6       	in	r0, 0x3e	; 62
    2352:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2354:	0e 94 cf 03 	call	0x79e	; 0x79e <xTaskIncrementTick>
    2358:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    235a:	0e 94 37 05 	call	0xa6e	; 0xa6e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    235e:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    2362:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    2366:	cd 91       	ld	r28, X+
    2368:	cd bf       	out	0x3d, r28	; 61
    236a:	dd 91       	ld	r29, X+
    236c:	de bf       	out	0x3e, r29	; 62
    236e:	ff 91       	pop	r31
    2370:	ef 91       	pop	r30
    2372:	df 91       	pop	r29
    2374:	cf 91       	pop	r28
    2376:	bf 91       	pop	r27
    2378:	af 91       	pop	r26
    237a:	9f 91       	pop	r25
    237c:	8f 91       	pop	r24
    237e:	7f 91       	pop	r23
    2380:	6f 91       	pop	r22
    2382:	5f 91       	pop	r21
    2384:	4f 91       	pop	r20
    2386:	3f 91       	pop	r19
    2388:	2f 91       	pop	r18
    238a:	1f 91       	pop	r17
    238c:	0f 91       	pop	r16
    238e:	ff 90       	pop	r15
    2390:	ef 90       	pop	r14
    2392:	df 90       	pop	r13
    2394:	cf 90       	pop	r12
    2396:	bf 90       	pop	r11
    2398:	af 90       	pop	r10
    239a:	9f 90       	pop	r9
    239c:	8f 90       	pop	r8
    239e:	7f 90       	pop	r7
    23a0:	6f 90       	pop	r6
    23a2:	5f 90       	pop	r5
    23a4:	4f 90       	pop	r4
    23a6:	3f 90       	pop	r3
    23a8:	2f 90       	pop	r2
    23aa:	1f 90       	pop	r1
    23ac:	0f 90       	pop	r0
    23ae:	0f be       	out	0x3f, r0	; 63
    23b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23b2:	08 95       	ret

000023b4 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    23b4:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vPortYieldFromTick>
		asm volatile ( "reti" );
    23b8:	18 95       	reti

000023ba <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0) | _BV(RXCIE0) | _BV(UDRIE0); /* Enable RX and TX odpala rwnie przerwania RX i UDRIE*/
}

int uart_transmit(char c, FILE *stream) {
    23ba:	cf 93       	push	r28
    23bc:	df 93       	push	r29
    23be:	1f 92       	push	r1
    23c0:	cd b7       	in	r28, 0x3d	; 61
    23c2:	de b7       	in	r29, 0x3e	; 62
    23c4:	89 83       	std	Y+1, r24	; 0x01
  if (uxQueueSpacesAvailable(bufor_out) == 0) {
    23c6:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <bufor_out>
    23ca:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <bufor_out+0x1>
    23ce:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueSpacesAvailable>
    23d2:	81 11       	cpse	r24, r1
    23d4:	04 c0       	rjmp	.+8      	; 0x23de <uart_transmit+0x24>
      while (!(UCSR0A & _BV(UDRE0)));
    23d6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    23da:	85 ff       	sbrs	r24, 5
    23dc:	fc cf       	rjmp	.-8      	; 0x23d6 <uart_transmit+0x1c>
  }
  xQueueSendFromISR(bufor_out, (void*)&c, NULL);
    23de:	20 e0       	ldi	r18, 0x00	; 0
    23e0:	40 e0       	ldi	r20, 0x00	; 0
    23e2:	50 e0       	ldi	r21, 0x00	; 0
    23e4:	be 01       	movw	r22, r28
    23e6:	6f 5f       	subi	r22, 0xFF	; 255
    23e8:	7f 4f       	sbci	r23, 0xFF	; 255
    23ea:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <bufor_out>
    23ee:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <bufor_out+0x1>
    23f2:	0e 94 9e 0a 	call	0x153c	; 0x153c <xQueueGenericSendFromISR>
  return 0;
}
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	90 e0       	ldi	r25, 0x00	; 0
    23fa:	0f 90       	pop	r0
    23fc:	df 91       	pop	r29
    23fe:	cf 91       	pop	r28
    2400:	08 95       	ret

00002402 <uart_receive>:

int uart_receive(FILE *stream) {
    2402:	cf 93       	push	r28
    2404:	df 93       	push	r29
    2406:	1f 92       	push	r1
    2408:	cd b7       	in	r28, 0x3d	; 61
    240a:	de b7       	in	r29, 0x3e	; 62
  uint8_t value = 0;
    240c:	19 82       	std	Y+1, r1	; 0x01
  while (xQueueReceiveFromISR(bufor_in, (void*)&value, NULL) == pdFALSE){
    240e:	40 e0       	ldi	r20, 0x00	; 0
    2410:	50 e0       	ldi	r21, 0x00	; 0
    2412:	be 01       	movw	r22, r28
    2414:	6f 5f       	subi	r22, 0xFF	; 255
    2416:	7f 4f       	sbci	r23, 0xFF	; 255
    2418:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <bufor_in>
    241c:	90 91 c1 07 	lds	r25, 0x07C1	; 0x8007c1 <bufor_in+0x1>
    2420:	0e 94 9a 0c 	call	0x1934	; 0x1934 <xQueueReceiveFromISR>
    2424:	81 11       	cpse	r24, r1
    2426:	05 c0       	rjmp	.+10     	; 0x2432 <uart_receive+0x30>
    vTaskDelay(5 / portTICK_PERIOD_MS);
    2428:	85 e0       	ldi	r24, 0x05	; 5
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	0e 94 22 05 	call	0xa44	; 0xa44 <vTaskDelay>
    2430:	ee cf       	rjmp	.-36     	; 0x240e <uart_receive+0xc>
  }
  return value;
    2432:	89 81       	ldd	r24, Y+1	; 0x01

    2434:	90 e0       	ldi	r25, 0x00	; 0
    2436:	0f 90       	pop	r0
    2438:	df 91       	pop	r29
    243a:	cf 91       	pop	r28
    243c:	08 95       	ret

0000243e <uart_init>:
    243e:	40 e0       	ldi	r20, 0x00	; 0
    2440:	61 e0       	ldi	r22, 0x01	; 1
    2442:	84 e6       	ldi	r24, 0x64	; 100
    2444:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <xQueueGenericCreate>
    2448:	90 93 c1 07 	sts	0x07C1, r25	; 0x8007c1 <bufor_in+0x1>
    244c:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <bufor_in>
    2450:	40 e0       	ldi	r20, 0x00	; 0
    2452:	61 e0       	ldi	r22, 0x01	; 1
    2454:	84 e6       	ldi	r24, 0x64	; 100
    2456:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <xQueueGenericCreate>
    245a:	90 93 bf 07 	sts	0x07BF, r25	; 0x8007bf <bufor_out+0x1>
    245e:	80 93 be 07 	sts	0x07BE, r24	; 0x8007be <bufor_out>
    2462:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    2466:	87 e6       	ldi	r24, 0x67	; 103
    2468:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    246c:	e0 ec       	ldi	r30, 0xC0	; 192
    246e:	f0 e0       	ldi	r31, 0x00	; 0
    2470:	80 81       	ld	r24, Z
    2472:	8d 7f       	andi	r24, 0xFD	; 253
    2474:	80 83       	st	Z, r24
    2476:	86 e0       	ldi	r24, 0x06	; 6
    2478:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
    247c:	88 eb       	ldi	r24, 0xB8	; 184
    247e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    2482:	08 95       	ret

00002484 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    2484:	ef 92       	push	r14
    2486:	ff 92       	push	r15
    2488:	0f 93       	push	r16
    248a:	cf 93       	push	r28
    248c:	df 93       	push	r29
    248e:	00 d0       	rcall	.+0      	; 0x2490 <main+0xc>
    2490:	00 d0       	rcall	.+0      	; 0x2492 <main+0xe>
    2492:	cd b7       	in	r28, 0x3d	; 61
    2494:	de b7       	in	r29, 0x3e	; 62
    // Create task.
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    xTaskCreate
    2496:	ce 01       	movw	r24, r28
    2498:	03 96       	adiw	r24, 0x03	; 3
    249a:	7c 01       	movw	r14, r24
    249c:	01 e0       	ldi	r16, 0x01	; 1
    249e:	20 e0       	ldi	r18, 0x00	; 0
    24a0:	30 e0       	ldi	r19, 0x00	; 0
    24a2:	45 e5       	ldi	r20, 0x55	; 85
    24a4:	50 e0       	ldi	r21, 0x00	; 0
    24a6:	6b e2       	ldi	r22, 0x2B	; 43
    24a8:	71 e0       	ldi	r23, 0x01	; 1
    24aa:	8e e7       	ldi	r24, 0x7E	; 126
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    24ae:	0e 94 9b 01 	call	0x336	; 0x336 <xTaskCreate>
         NULL,
         mainLED_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    24b2:	ce 01       	movw	r24, r28
    24b4:	01 96       	adiw	r24, 0x01	; 1
    24b6:	7c 01       	movw	r14, r24
    24b8:	02 e0       	ldi	r16, 0x02	; 2
    24ba:	20 e0       	ldi	r18, 0x00	; 0
    24bc:	30 e0       	ldi	r19, 0x00	; 0
    24be:	45 e5       	ldi	r20, 0x55	; 85
    24c0:	50 e0       	ldi	r21, 0x00	; 0
    24c2:	61 e3       	ldi	r22, 0x31	; 49
    24c4:	71 e0       	ldi	r23, 0x01	; 1
    24c6:	83 e5       	ldi	r24, 0x53	; 83
    24c8:	90 e0       	ldi	r25, 0x00	; 0
    24ca:	0e 94 9b 01 	call	0x336	; 0x336 <xTaskCreate>
         mainSERIAL_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    24ce:	0e 94 80 03 	call	0x700	; 0x700 <vTaskStartScheduler>

    return 0;
}
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	0f 90       	pop	r0
    24d8:	0f 90       	pop	r0
    24da:	0f 90       	pop	r0
    24dc:	0f 90       	pop	r0
    24de:	df 91       	pop	r29
    24e0:	cf 91       	pop	r28
    24e2:	0f 91       	pop	r16
    24e4:	ff 90       	pop	r15
    24e6:	ef 90       	pop	r14
    24e8:	08 95       	ret

000024ea <memcpy>:
    24ea:	fb 01       	movw	r30, r22
    24ec:	dc 01       	movw	r26, r24
    24ee:	02 c0       	rjmp	.+4      	; 0x24f4 <memcpy+0xa>
    24f0:	01 90       	ld	r0, Z+
    24f2:	0d 92       	st	X+, r0
    24f4:	41 50       	subi	r20, 0x01	; 1
    24f6:	50 40       	sbci	r21, 0x00	; 0
    24f8:	d8 f7       	brcc	.-10     	; 0x24f0 <memcpy+0x6>
    24fa:	08 95       	ret

000024fc <fgetc>:
    24fc:	cf 93       	push	r28
    24fe:	df 93       	push	r29
    2500:	ec 01       	movw	r28, r24
    2502:	2b 81       	ldd	r18, Y+3	; 0x03
    2504:	20 ff       	sbrs	r18, 0
    2506:	33 c0       	rjmp	.+102    	; 0x256e <fgetc+0x72>
    2508:	26 ff       	sbrs	r18, 6
    250a:	0a c0       	rjmp	.+20     	; 0x2520 <fgetc+0x24>
    250c:	2f 7b       	andi	r18, 0xBF	; 191
    250e:	2b 83       	std	Y+3, r18	; 0x03
    2510:	8e 81       	ldd	r24, Y+6	; 0x06
    2512:	9f 81       	ldd	r25, Y+7	; 0x07
    2514:	01 96       	adiw	r24, 0x01	; 1
    2516:	9f 83       	std	Y+7, r25	; 0x07
    2518:	8e 83       	std	Y+6, r24	; 0x06
    251a:	8a 81       	ldd	r24, Y+2	; 0x02
    251c:	90 e0       	ldi	r25, 0x00	; 0
    251e:	29 c0       	rjmp	.+82     	; 0x2572 <fgetc+0x76>
    2520:	22 ff       	sbrs	r18, 2
    2522:	0f c0       	rjmp	.+30     	; 0x2542 <fgetc+0x46>
    2524:	e8 81       	ld	r30, Y
    2526:	f9 81       	ldd	r31, Y+1	; 0x01
    2528:	80 81       	ld	r24, Z
    252a:	08 2e       	mov	r0, r24
    252c:	00 0c       	add	r0, r0
    252e:	99 0b       	sbc	r25, r25
    2530:	00 97       	sbiw	r24, 0x00	; 0
    2532:	19 f4       	brne	.+6      	; 0x253a <fgetc+0x3e>
    2534:	20 62       	ori	r18, 0x20	; 32
    2536:	2b 83       	std	Y+3, r18	; 0x03
    2538:	1a c0       	rjmp	.+52     	; 0x256e <fgetc+0x72>
    253a:	31 96       	adiw	r30, 0x01	; 1
    253c:	f9 83       	std	Y+1, r31	; 0x01
    253e:	e8 83       	st	Y, r30
    2540:	0e c0       	rjmp	.+28     	; 0x255e <fgetc+0x62>
    2542:	ea 85       	ldd	r30, Y+10	; 0x0a
    2544:	fb 85       	ldd	r31, Y+11	; 0x0b
    2546:	09 95       	icall
    2548:	97 ff       	sbrs	r25, 7
    254a:	09 c0       	rjmp	.+18     	; 0x255e <fgetc+0x62>
    254c:	2b 81       	ldd	r18, Y+3	; 0x03
    254e:	01 96       	adiw	r24, 0x01	; 1
    2550:	11 f0       	breq	.+4      	; 0x2556 <fgetc+0x5a>
    2552:	80 e2       	ldi	r24, 0x20	; 32
    2554:	01 c0       	rjmp	.+2      	; 0x2558 <fgetc+0x5c>
    2556:	80 e1       	ldi	r24, 0x10	; 16
    2558:	82 2b       	or	r24, r18
    255a:	8b 83       	std	Y+3, r24	; 0x03
    255c:	08 c0       	rjmp	.+16     	; 0x256e <fgetc+0x72>
    255e:	2e 81       	ldd	r18, Y+6	; 0x06
    2560:	3f 81       	ldd	r19, Y+7	; 0x07
    2562:	2f 5f       	subi	r18, 0xFF	; 255
    2564:	3f 4f       	sbci	r19, 0xFF	; 255
    2566:	3f 83       	std	Y+7, r19	; 0x07
    2568:	2e 83       	std	Y+6, r18	; 0x06
    256a:	99 27       	eor	r25, r25
    256c:	02 c0       	rjmp	.+4      	; 0x2572 <fgetc+0x76>
    256e:	8f ef       	ldi	r24, 0xFF	; 255
    2570:	9f ef       	ldi	r25, 0xFF	; 255
    2572:	df 91       	pop	r29
    2574:	cf 91       	pop	r28
    2576:	08 95       	ret

00002578 <printf>:
    2578:	a0 e0       	ldi	r26, 0x00	; 0
    257a:	b0 e0       	ldi	r27, 0x00	; 0
    257c:	e2 ec       	ldi	r30, 0xC2	; 194
    257e:	f2 e1       	ldi	r31, 0x12	; 18
    2580:	0c 94 a3 15 	jmp	0x2b46	; 0x2b46 <__prologue_saves__+0x20>
    2584:	ae 01       	movw	r20, r28
    2586:	4b 5f       	subi	r20, 0xFB	; 251
    2588:	5f 4f       	sbci	r21, 0xFF	; 255
    258a:	fa 01       	movw	r30, r20
    258c:	61 91       	ld	r22, Z+
    258e:	71 91       	ld	r23, Z+
    2590:	af 01       	movw	r20, r30
    2592:	80 91 c4 07 	lds	r24, 0x07C4	; 0x8007c4 <__iob+0x2>
    2596:	90 91 c5 07 	lds	r25, 0x07C5	; 0x8007c5 <__iob+0x3>
    259a:	0e 94 02 13 	call	0x2604	; 0x2604 <vfprintf>
    259e:	e2 e0       	ldi	r30, 0x02	; 2
    25a0:	0c 94 bf 15 	jmp	0x2b7e	; 0x2b7e <__epilogue_restores__+0x20>

000025a4 <puts>:
    25a4:	0f 93       	push	r16
    25a6:	1f 93       	push	r17
    25a8:	cf 93       	push	r28
    25aa:	df 93       	push	r29
    25ac:	e0 91 c4 07 	lds	r30, 0x07C4	; 0x8007c4 <__iob+0x2>
    25b0:	f0 91 c5 07 	lds	r31, 0x07C5	; 0x8007c5 <__iob+0x3>
    25b4:	23 81       	ldd	r18, Z+3	; 0x03
    25b6:	21 ff       	sbrs	r18, 1
    25b8:	1b c0       	rjmp	.+54     	; 0x25f0 <puts+0x4c>
    25ba:	8c 01       	movw	r16, r24
    25bc:	d0 e0       	ldi	r29, 0x00	; 0
    25be:	c0 e0       	ldi	r28, 0x00	; 0
    25c0:	f8 01       	movw	r30, r16
    25c2:	81 91       	ld	r24, Z+
    25c4:	8f 01       	movw	r16, r30
    25c6:	60 91 c4 07 	lds	r22, 0x07C4	; 0x8007c4 <__iob+0x2>
    25ca:	70 91 c5 07 	lds	r23, 0x07C5	; 0x8007c5 <__iob+0x3>
    25ce:	db 01       	movw	r26, r22
    25d0:	18 96       	adiw	r26, 0x08	; 8
    25d2:	ed 91       	ld	r30, X+
    25d4:	fc 91       	ld	r31, X
    25d6:	19 97       	sbiw	r26, 0x09	; 9
    25d8:	88 23       	and	r24, r24
    25da:	31 f0       	breq	.+12     	; 0x25e8 <puts+0x44>
    25dc:	09 95       	icall
    25de:	89 2b       	or	r24, r25
    25e0:	79 f3       	breq	.-34     	; 0x25c0 <puts+0x1c>
    25e2:	df ef       	ldi	r29, 0xFF	; 255
    25e4:	cf ef       	ldi	r28, 0xFF	; 255
    25e6:	ec cf       	rjmp	.-40     	; 0x25c0 <puts+0x1c>
    25e8:	8a e0       	ldi	r24, 0x0A	; 10
    25ea:	09 95       	icall
    25ec:	89 2b       	or	r24, r25
    25ee:	19 f0       	breq	.+6      	; 0x25f6 <puts+0x52>
    25f0:	8f ef       	ldi	r24, 0xFF	; 255
    25f2:	9f ef       	ldi	r25, 0xFF	; 255
    25f4:	02 c0       	rjmp	.+4      	; 0x25fa <puts+0x56>
    25f6:	8d 2f       	mov	r24, r29
    25f8:	9c 2f       	mov	r25, r28
    25fa:	df 91       	pop	r29
    25fc:	cf 91       	pop	r28
    25fe:	1f 91       	pop	r17
    2600:	0f 91       	pop	r16
    2602:	08 95       	ret

00002604 <vfprintf>:
    2604:	ab e0       	ldi	r26, 0x0B	; 11
    2606:	b0 e0       	ldi	r27, 0x00	; 0
    2608:	e8 e0       	ldi	r30, 0x08	; 8
    260a:	f3 e1       	ldi	r31, 0x13	; 19
    260c:	0c 94 93 15 	jmp	0x2b26	; 0x2b26 <__prologue_saves__>
    2610:	6c 01       	movw	r12, r24
    2612:	7b 01       	movw	r14, r22
    2614:	8a 01       	movw	r16, r20
    2616:	fc 01       	movw	r30, r24
    2618:	17 82       	std	Z+7, r1	; 0x07
    261a:	16 82       	std	Z+6, r1	; 0x06
    261c:	83 81       	ldd	r24, Z+3	; 0x03
    261e:	81 ff       	sbrs	r24, 1
    2620:	cc c1       	rjmp	.+920    	; 0x29ba <vfprintf+0x3b6>
    2622:	ce 01       	movw	r24, r28
    2624:	01 96       	adiw	r24, 0x01	; 1
    2626:	3c 01       	movw	r6, r24
    2628:	f6 01       	movw	r30, r12
    262a:	93 81       	ldd	r25, Z+3	; 0x03
    262c:	f7 01       	movw	r30, r14
    262e:	93 fd       	sbrc	r25, 3
    2630:	85 91       	lpm	r24, Z+
    2632:	93 ff       	sbrs	r25, 3
    2634:	81 91       	ld	r24, Z+
    2636:	7f 01       	movw	r14, r30
    2638:	88 23       	and	r24, r24
    263a:	09 f4       	brne	.+2      	; 0x263e <vfprintf+0x3a>
    263c:	ba c1       	rjmp	.+884    	; 0x29b2 <vfprintf+0x3ae>
    263e:	85 32       	cpi	r24, 0x25	; 37
    2640:	39 f4       	brne	.+14     	; 0x2650 <vfprintf+0x4c>
    2642:	93 fd       	sbrc	r25, 3
    2644:	85 91       	lpm	r24, Z+
    2646:	93 ff       	sbrs	r25, 3
    2648:	81 91       	ld	r24, Z+
    264a:	7f 01       	movw	r14, r30
    264c:	85 32       	cpi	r24, 0x25	; 37
    264e:	29 f4       	brne	.+10     	; 0x265a <vfprintf+0x56>
    2650:	b6 01       	movw	r22, r12
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    2658:	e7 cf       	rjmp	.-50     	; 0x2628 <vfprintf+0x24>
    265a:	91 2c       	mov	r9, r1
    265c:	21 2c       	mov	r2, r1
    265e:	31 2c       	mov	r3, r1
    2660:	ff e1       	ldi	r31, 0x1F	; 31
    2662:	f3 15       	cp	r31, r3
    2664:	d8 f0       	brcs	.+54     	; 0x269c <vfprintf+0x98>
    2666:	8b 32       	cpi	r24, 0x2B	; 43
    2668:	79 f0       	breq	.+30     	; 0x2688 <vfprintf+0x84>
    266a:	38 f4       	brcc	.+14     	; 0x267a <vfprintf+0x76>
    266c:	80 32       	cpi	r24, 0x20	; 32
    266e:	79 f0       	breq	.+30     	; 0x268e <vfprintf+0x8a>
    2670:	83 32       	cpi	r24, 0x23	; 35
    2672:	a1 f4       	brne	.+40     	; 0x269c <vfprintf+0x98>
    2674:	23 2d       	mov	r18, r3
    2676:	20 61       	ori	r18, 0x10	; 16
    2678:	1d c0       	rjmp	.+58     	; 0x26b4 <vfprintf+0xb0>
    267a:	8d 32       	cpi	r24, 0x2D	; 45
    267c:	61 f0       	breq	.+24     	; 0x2696 <vfprintf+0x92>
    267e:	80 33       	cpi	r24, 0x30	; 48
    2680:	69 f4       	brne	.+26     	; 0x269c <vfprintf+0x98>
    2682:	23 2d       	mov	r18, r3
    2684:	21 60       	ori	r18, 0x01	; 1
    2686:	16 c0       	rjmp	.+44     	; 0x26b4 <vfprintf+0xb0>
    2688:	83 2d       	mov	r24, r3
    268a:	82 60       	ori	r24, 0x02	; 2
    268c:	38 2e       	mov	r3, r24
    268e:	e3 2d       	mov	r30, r3
    2690:	e4 60       	ori	r30, 0x04	; 4
    2692:	3e 2e       	mov	r3, r30
    2694:	2a c0       	rjmp	.+84     	; 0x26ea <vfprintf+0xe6>
    2696:	f3 2d       	mov	r31, r3
    2698:	f8 60       	ori	r31, 0x08	; 8
    269a:	1d c0       	rjmp	.+58     	; 0x26d6 <vfprintf+0xd2>
    269c:	37 fc       	sbrc	r3, 7
    269e:	2d c0       	rjmp	.+90     	; 0x26fa <vfprintf+0xf6>
    26a0:	20 ed       	ldi	r18, 0xD0	; 208
    26a2:	28 0f       	add	r18, r24
    26a4:	2a 30       	cpi	r18, 0x0A	; 10
    26a6:	40 f0       	brcs	.+16     	; 0x26b8 <vfprintf+0xb4>
    26a8:	8e 32       	cpi	r24, 0x2E	; 46
    26aa:	b9 f4       	brne	.+46     	; 0x26da <vfprintf+0xd6>
    26ac:	36 fc       	sbrc	r3, 6
    26ae:	81 c1       	rjmp	.+770    	; 0x29b2 <vfprintf+0x3ae>
    26b0:	23 2d       	mov	r18, r3
    26b2:	20 64       	ori	r18, 0x40	; 64
    26b4:	32 2e       	mov	r3, r18
    26b6:	19 c0       	rjmp	.+50     	; 0x26ea <vfprintf+0xe6>
    26b8:	36 fe       	sbrs	r3, 6
    26ba:	06 c0       	rjmp	.+12     	; 0x26c8 <vfprintf+0xc4>
    26bc:	8a e0       	ldi	r24, 0x0A	; 10
    26be:	98 9e       	mul	r9, r24
    26c0:	20 0d       	add	r18, r0
    26c2:	11 24       	eor	r1, r1
    26c4:	92 2e       	mov	r9, r18
    26c6:	11 c0       	rjmp	.+34     	; 0x26ea <vfprintf+0xe6>
    26c8:	ea e0       	ldi	r30, 0x0A	; 10
    26ca:	2e 9e       	mul	r2, r30
    26cc:	20 0d       	add	r18, r0
    26ce:	11 24       	eor	r1, r1
    26d0:	22 2e       	mov	r2, r18
    26d2:	f3 2d       	mov	r31, r3
    26d4:	f0 62       	ori	r31, 0x20	; 32
    26d6:	3f 2e       	mov	r3, r31
    26d8:	08 c0       	rjmp	.+16     	; 0x26ea <vfprintf+0xe6>
    26da:	8c 36       	cpi	r24, 0x6C	; 108
    26dc:	21 f4       	brne	.+8      	; 0x26e6 <vfprintf+0xe2>
    26de:	83 2d       	mov	r24, r3
    26e0:	80 68       	ori	r24, 0x80	; 128
    26e2:	38 2e       	mov	r3, r24
    26e4:	02 c0       	rjmp	.+4      	; 0x26ea <vfprintf+0xe6>
    26e6:	88 36       	cpi	r24, 0x68	; 104
    26e8:	41 f4       	brne	.+16     	; 0x26fa <vfprintf+0xf6>
    26ea:	f7 01       	movw	r30, r14
    26ec:	93 fd       	sbrc	r25, 3
    26ee:	85 91       	lpm	r24, Z+
    26f0:	93 ff       	sbrs	r25, 3
    26f2:	81 91       	ld	r24, Z+
    26f4:	7f 01       	movw	r14, r30
    26f6:	81 11       	cpse	r24, r1
    26f8:	b3 cf       	rjmp	.-154    	; 0x2660 <vfprintf+0x5c>
    26fa:	98 2f       	mov	r25, r24
    26fc:	9f 7d       	andi	r25, 0xDF	; 223
    26fe:	95 54       	subi	r25, 0x45	; 69
    2700:	93 30       	cpi	r25, 0x03	; 3
    2702:	28 f4       	brcc	.+10     	; 0x270e <vfprintf+0x10a>
    2704:	0c 5f       	subi	r16, 0xFC	; 252
    2706:	1f 4f       	sbci	r17, 0xFF	; 255
    2708:	9f e3       	ldi	r25, 0x3F	; 63
    270a:	99 83       	std	Y+1, r25	; 0x01
    270c:	0d c0       	rjmp	.+26     	; 0x2728 <vfprintf+0x124>
    270e:	83 36       	cpi	r24, 0x63	; 99
    2710:	31 f0       	breq	.+12     	; 0x271e <vfprintf+0x11a>
    2712:	83 37       	cpi	r24, 0x73	; 115
    2714:	71 f0       	breq	.+28     	; 0x2732 <vfprintf+0x12e>
    2716:	83 35       	cpi	r24, 0x53	; 83
    2718:	09 f0       	breq	.+2      	; 0x271c <vfprintf+0x118>
    271a:	59 c0       	rjmp	.+178    	; 0x27ce <vfprintf+0x1ca>
    271c:	21 c0       	rjmp	.+66     	; 0x2760 <vfprintf+0x15c>
    271e:	f8 01       	movw	r30, r16
    2720:	80 81       	ld	r24, Z
    2722:	89 83       	std	Y+1, r24	; 0x01
    2724:	0e 5f       	subi	r16, 0xFE	; 254
    2726:	1f 4f       	sbci	r17, 0xFF	; 255
    2728:	88 24       	eor	r8, r8
    272a:	83 94       	inc	r8
    272c:	91 2c       	mov	r9, r1
    272e:	53 01       	movw	r10, r6
    2730:	13 c0       	rjmp	.+38     	; 0x2758 <vfprintf+0x154>
    2732:	28 01       	movw	r4, r16
    2734:	f2 e0       	ldi	r31, 0x02	; 2
    2736:	4f 0e       	add	r4, r31
    2738:	51 1c       	adc	r5, r1
    273a:	f8 01       	movw	r30, r16
    273c:	a0 80       	ld	r10, Z
    273e:	b1 80       	ldd	r11, Z+1	; 0x01
    2740:	36 fe       	sbrs	r3, 6
    2742:	03 c0       	rjmp	.+6      	; 0x274a <vfprintf+0x146>
    2744:	69 2d       	mov	r22, r9
    2746:	70 e0       	ldi	r23, 0x00	; 0
    2748:	02 c0       	rjmp	.+4      	; 0x274e <vfprintf+0x14a>
    274a:	6f ef       	ldi	r22, 0xFF	; 255
    274c:	7f ef       	ldi	r23, 0xFF	; 255
    274e:	c5 01       	movw	r24, r10
    2750:	0e 94 ee 14 	call	0x29dc	; 0x29dc <strnlen>
    2754:	4c 01       	movw	r8, r24
    2756:	82 01       	movw	r16, r4
    2758:	f3 2d       	mov	r31, r3
    275a:	ff 77       	andi	r31, 0x7F	; 127
    275c:	3f 2e       	mov	r3, r31
    275e:	16 c0       	rjmp	.+44     	; 0x278c <vfprintf+0x188>
    2760:	28 01       	movw	r4, r16
    2762:	22 e0       	ldi	r18, 0x02	; 2
    2764:	42 0e       	add	r4, r18
    2766:	51 1c       	adc	r5, r1
    2768:	f8 01       	movw	r30, r16
    276a:	a0 80       	ld	r10, Z
    276c:	b1 80       	ldd	r11, Z+1	; 0x01
    276e:	36 fe       	sbrs	r3, 6
    2770:	03 c0       	rjmp	.+6      	; 0x2778 <vfprintf+0x174>
    2772:	69 2d       	mov	r22, r9
    2774:	70 e0       	ldi	r23, 0x00	; 0
    2776:	02 c0       	rjmp	.+4      	; 0x277c <vfprintf+0x178>
    2778:	6f ef       	ldi	r22, 0xFF	; 255
    277a:	7f ef       	ldi	r23, 0xFF	; 255
    277c:	c5 01       	movw	r24, r10
    277e:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <strnlen_P>
    2782:	4c 01       	movw	r8, r24
    2784:	f3 2d       	mov	r31, r3
    2786:	f0 68       	ori	r31, 0x80	; 128
    2788:	3f 2e       	mov	r3, r31
    278a:	82 01       	movw	r16, r4
    278c:	33 fc       	sbrc	r3, 3
    278e:	1b c0       	rjmp	.+54     	; 0x27c6 <vfprintf+0x1c2>
    2790:	82 2d       	mov	r24, r2
    2792:	90 e0       	ldi	r25, 0x00	; 0
    2794:	88 16       	cp	r8, r24
    2796:	99 06       	cpc	r9, r25
    2798:	b0 f4       	brcc	.+44     	; 0x27c6 <vfprintf+0x1c2>
    279a:	b6 01       	movw	r22, r12
    279c:	80 e2       	ldi	r24, 0x20	; 32
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    27a4:	2a 94       	dec	r2
    27a6:	f4 cf       	rjmp	.-24     	; 0x2790 <vfprintf+0x18c>
    27a8:	f5 01       	movw	r30, r10
    27aa:	37 fc       	sbrc	r3, 7
    27ac:	85 91       	lpm	r24, Z+
    27ae:	37 fe       	sbrs	r3, 7
    27b0:	81 91       	ld	r24, Z+
    27b2:	5f 01       	movw	r10, r30
    27b4:	b6 01       	movw	r22, r12
    27b6:	90 e0       	ldi	r25, 0x00	; 0
    27b8:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    27bc:	21 10       	cpse	r2, r1
    27be:	2a 94       	dec	r2
    27c0:	21 e0       	ldi	r18, 0x01	; 1
    27c2:	82 1a       	sub	r8, r18
    27c4:	91 08       	sbc	r9, r1
    27c6:	81 14       	cp	r8, r1
    27c8:	91 04       	cpc	r9, r1
    27ca:	71 f7       	brne	.-36     	; 0x27a8 <vfprintf+0x1a4>
    27cc:	e8 c0       	rjmp	.+464    	; 0x299e <vfprintf+0x39a>
    27ce:	84 36       	cpi	r24, 0x64	; 100
    27d0:	11 f0       	breq	.+4      	; 0x27d6 <vfprintf+0x1d2>
    27d2:	89 36       	cpi	r24, 0x69	; 105
    27d4:	41 f5       	brne	.+80     	; 0x2826 <vfprintf+0x222>
    27d6:	f8 01       	movw	r30, r16
    27d8:	37 fe       	sbrs	r3, 7
    27da:	07 c0       	rjmp	.+14     	; 0x27ea <vfprintf+0x1e6>
    27dc:	60 81       	ld	r22, Z
    27de:	71 81       	ldd	r23, Z+1	; 0x01
    27e0:	82 81       	ldd	r24, Z+2	; 0x02
    27e2:	93 81       	ldd	r25, Z+3	; 0x03
    27e4:	0c 5f       	subi	r16, 0xFC	; 252
    27e6:	1f 4f       	sbci	r17, 0xFF	; 255
    27e8:	08 c0       	rjmp	.+16     	; 0x27fa <vfprintf+0x1f6>
    27ea:	60 81       	ld	r22, Z
    27ec:	71 81       	ldd	r23, Z+1	; 0x01
    27ee:	07 2e       	mov	r0, r23
    27f0:	00 0c       	add	r0, r0
    27f2:	88 0b       	sbc	r24, r24
    27f4:	99 0b       	sbc	r25, r25
    27f6:	0e 5f       	subi	r16, 0xFE	; 254
    27f8:	1f 4f       	sbci	r17, 0xFF	; 255
    27fa:	f3 2d       	mov	r31, r3
    27fc:	ff 76       	andi	r31, 0x6F	; 111
    27fe:	3f 2e       	mov	r3, r31
    2800:	97 ff       	sbrs	r25, 7
    2802:	09 c0       	rjmp	.+18     	; 0x2816 <vfprintf+0x212>
    2804:	90 95       	com	r25
    2806:	80 95       	com	r24
    2808:	70 95       	com	r23
    280a:	61 95       	neg	r22
    280c:	7f 4f       	sbci	r23, 0xFF	; 255
    280e:	8f 4f       	sbci	r24, 0xFF	; 255
    2810:	9f 4f       	sbci	r25, 0xFF	; 255
    2812:	f0 68       	ori	r31, 0x80	; 128
    2814:	3f 2e       	mov	r3, r31
    2816:	2a e0       	ldi	r18, 0x0A	; 10
    2818:	30 e0       	ldi	r19, 0x00	; 0
    281a:	a3 01       	movw	r20, r6
    281c:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <__ultoa_invert>
    2820:	88 2e       	mov	r8, r24
    2822:	86 18       	sub	r8, r6
    2824:	45 c0       	rjmp	.+138    	; 0x28b0 <vfprintf+0x2ac>
    2826:	85 37       	cpi	r24, 0x75	; 117
    2828:	31 f4       	brne	.+12     	; 0x2836 <vfprintf+0x232>
    282a:	23 2d       	mov	r18, r3
    282c:	2f 7e       	andi	r18, 0xEF	; 239
    282e:	b2 2e       	mov	r11, r18
    2830:	2a e0       	ldi	r18, 0x0A	; 10
    2832:	30 e0       	ldi	r19, 0x00	; 0
    2834:	25 c0       	rjmp	.+74     	; 0x2880 <vfprintf+0x27c>
    2836:	93 2d       	mov	r25, r3
    2838:	99 7f       	andi	r25, 0xF9	; 249
    283a:	b9 2e       	mov	r11, r25
    283c:	8f 36       	cpi	r24, 0x6F	; 111
    283e:	c1 f0       	breq	.+48     	; 0x2870 <vfprintf+0x26c>
    2840:	18 f4       	brcc	.+6      	; 0x2848 <vfprintf+0x244>
    2842:	88 35       	cpi	r24, 0x58	; 88
    2844:	79 f0       	breq	.+30     	; 0x2864 <vfprintf+0x260>
    2846:	b5 c0       	rjmp	.+362    	; 0x29b2 <vfprintf+0x3ae>
    2848:	80 37       	cpi	r24, 0x70	; 112
    284a:	19 f0       	breq	.+6      	; 0x2852 <vfprintf+0x24e>
    284c:	88 37       	cpi	r24, 0x78	; 120
    284e:	21 f0       	breq	.+8      	; 0x2858 <vfprintf+0x254>
    2850:	b0 c0       	rjmp	.+352    	; 0x29b2 <vfprintf+0x3ae>
    2852:	e9 2f       	mov	r30, r25
    2854:	e0 61       	ori	r30, 0x10	; 16
    2856:	be 2e       	mov	r11, r30
    2858:	b4 fe       	sbrs	r11, 4
    285a:	0d c0       	rjmp	.+26     	; 0x2876 <vfprintf+0x272>
    285c:	fb 2d       	mov	r31, r11
    285e:	f4 60       	ori	r31, 0x04	; 4
    2860:	bf 2e       	mov	r11, r31
    2862:	09 c0       	rjmp	.+18     	; 0x2876 <vfprintf+0x272>
    2864:	34 fe       	sbrs	r3, 4
    2866:	0a c0       	rjmp	.+20     	; 0x287c <vfprintf+0x278>
    2868:	29 2f       	mov	r18, r25
    286a:	26 60       	ori	r18, 0x06	; 6
    286c:	b2 2e       	mov	r11, r18
    286e:	06 c0       	rjmp	.+12     	; 0x287c <vfprintf+0x278>
    2870:	28 e0       	ldi	r18, 0x08	; 8
    2872:	30 e0       	ldi	r19, 0x00	; 0
    2874:	05 c0       	rjmp	.+10     	; 0x2880 <vfprintf+0x27c>
    2876:	20 e1       	ldi	r18, 0x10	; 16
    2878:	30 e0       	ldi	r19, 0x00	; 0
    287a:	02 c0       	rjmp	.+4      	; 0x2880 <vfprintf+0x27c>
    287c:	20 e1       	ldi	r18, 0x10	; 16
    287e:	32 e0       	ldi	r19, 0x02	; 2
    2880:	f8 01       	movw	r30, r16
    2882:	b7 fe       	sbrs	r11, 7
    2884:	07 c0       	rjmp	.+14     	; 0x2894 <vfprintf+0x290>
    2886:	60 81       	ld	r22, Z
    2888:	71 81       	ldd	r23, Z+1	; 0x01
    288a:	82 81       	ldd	r24, Z+2	; 0x02
    288c:	93 81       	ldd	r25, Z+3	; 0x03
    288e:	0c 5f       	subi	r16, 0xFC	; 252
    2890:	1f 4f       	sbci	r17, 0xFF	; 255
    2892:	06 c0       	rjmp	.+12     	; 0x28a0 <vfprintf+0x29c>
    2894:	60 81       	ld	r22, Z
    2896:	71 81       	ldd	r23, Z+1	; 0x01
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	90 e0       	ldi	r25, 0x00	; 0
    289c:	0e 5f       	subi	r16, 0xFE	; 254
    289e:	1f 4f       	sbci	r17, 0xFF	; 255
    28a0:	a3 01       	movw	r20, r6
    28a2:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <__ultoa_invert>
    28a6:	88 2e       	mov	r8, r24
    28a8:	86 18       	sub	r8, r6
    28aa:	fb 2d       	mov	r31, r11
    28ac:	ff 77       	andi	r31, 0x7F	; 127
    28ae:	3f 2e       	mov	r3, r31
    28b0:	36 fe       	sbrs	r3, 6
    28b2:	0d c0       	rjmp	.+26     	; 0x28ce <vfprintf+0x2ca>
    28b4:	23 2d       	mov	r18, r3
    28b6:	2e 7f       	andi	r18, 0xFE	; 254
    28b8:	a2 2e       	mov	r10, r18
    28ba:	89 14       	cp	r8, r9
    28bc:	58 f4       	brcc	.+22     	; 0x28d4 <vfprintf+0x2d0>
    28be:	34 fe       	sbrs	r3, 4
    28c0:	0b c0       	rjmp	.+22     	; 0x28d8 <vfprintf+0x2d4>
    28c2:	32 fc       	sbrc	r3, 2
    28c4:	09 c0       	rjmp	.+18     	; 0x28d8 <vfprintf+0x2d4>
    28c6:	83 2d       	mov	r24, r3
    28c8:	8e 7e       	andi	r24, 0xEE	; 238
    28ca:	a8 2e       	mov	r10, r24
    28cc:	05 c0       	rjmp	.+10     	; 0x28d8 <vfprintf+0x2d4>
    28ce:	b8 2c       	mov	r11, r8
    28d0:	a3 2c       	mov	r10, r3
    28d2:	03 c0       	rjmp	.+6      	; 0x28da <vfprintf+0x2d6>
    28d4:	b8 2c       	mov	r11, r8
    28d6:	01 c0       	rjmp	.+2      	; 0x28da <vfprintf+0x2d6>
    28d8:	b9 2c       	mov	r11, r9
    28da:	a4 fe       	sbrs	r10, 4
    28dc:	0f c0       	rjmp	.+30     	; 0x28fc <vfprintf+0x2f8>
    28de:	fe 01       	movw	r30, r28
    28e0:	e8 0d       	add	r30, r8
    28e2:	f1 1d       	adc	r31, r1
    28e4:	80 81       	ld	r24, Z
    28e6:	80 33       	cpi	r24, 0x30	; 48
    28e8:	21 f4       	brne	.+8      	; 0x28f2 <vfprintf+0x2ee>
    28ea:	9a 2d       	mov	r25, r10
    28ec:	99 7e       	andi	r25, 0xE9	; 233
    28ee:	a9 2e       	mov	r10, r25
    28f0:	09 c0       	rjmp	.+18     	; 0x2904 <vfprintf+0x300>
    28f2:	a2 fe       	sbrs	r10, 2
    28f4:	06 c0       	rjmp	.+12     	; 0x2902 <vfprintf+0x2fe>
    28f6:	b3 94       	inc	r11
    28f8:	b3 94       	inc	r11
    28fa:	04 c0       	rjmp	.+8      	; 0x2904 <vfprintf+0x300>
    28fc:	8a 2d       	mov	r24, r10
    28fe:	86 78       	andi	r24, 0x86	; 134
    2900:	09 f0       	breq	.+2      	; 0x2904 <vfprintf+0x300>
    2902:	b3 94       	inc	r11
    2904:	a3 fc       	sbrc	r10, 3
    2906:	11 c0       	rjmp	.+34     	; 0x292a <vfprintf+0x326>
    2908:	a0 fe       	sbrs	r10, 0
    290a:	06 c0       	rjmp	.+12     	; 0x2918 <vfprintf+0x314>
    290c:	b2 14       	cp	r11, r2
    290e:	88 f4       	brcc	.+34     	; 0x2932 <vfprintf+0x32e>
    2910:	28 0c       	add	r2, r8
    2912:	92 2c       	mov	r9, r2
    2914:	9b 18       	sub	r9, r11
    2916:	0e c0       	rjmp	.+28     	; 0x2934 <vfprintf+0x330>
    2918:	b2 14       	cp	r11, r2
    291a:	60 f4       	brcc	.+24     	; 0x2934 <vfprintf+0x330>
    291c:	b6 01       	movw	r22, r12
    291e:	80 e2       	ldi	r24, 0x20	; 32
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    2926:	b3 94       	inc	r11
    2928:	f7 cf       	rjmp	.-18     	; 0x2918 <vfprintf+0x314>
    292a:	b2 14       	cp	r11, r2
    292c:	18 f4       	brcc	.+6      	; 0x2934 <vfprintf+0x330>
    292e:	2b 18       	sub	r2, r11
    2930:	02 c0       	rjmp	.+4      	; 0x2936 <vfprintf+0x332>
    2932:	98 2c       	mov	r9, r8
    2934:	21 2c       	mov	r2, r1
    2936:	a4 fe       	sbrs	r10, 4
    2938:	10 c0       	rjmp	.+32     	; 0x295a <vfprintf+0x356>
    293a:	b6 01       	movw	r22, r12
    293c:	80 e3       	ldi	r24, 0x30	; 48
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    2944:	a2 fe       	sbrs	r10, 2
    2946:	17 c0       	rjmp	.+46     	; 0x2976 <vfprintf+0x372>
    2948:	a1 fc       	sbrc	r10, 1
    294a:	03 c0       	rjmp	.+6      	; 0x2952 <vfprintf+0x34e>
    294c:	88 e7       	ldi	r24, 0x78	; 120
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	02 c0       	rjmp	.+4      	; 0x2956 <vfprintf+0x352>
    2952:	88 e5       	ldi	r24, 0x58	; 88
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	b6 01       	movw	r22, r12
    2958:	0c c0       	rjmp	.+24     	; 0x2972 <vfprintf+0x36e>
    295a:	8a 2d       	mov	r24, r10
    295c:	86 78       	andi	r24, 0x86	; 134
    295e:	59 f0       	breq	.+22     	; 0x2976 <vfprintf+0x372>
    2960:	a1 fe       	sbrs	r10, 1
    2962:	02 c0       	rjmp	.+4      	; 0x2968 <vfprintf+0x364>
    2964:	8b e2       	ldi	r24, 0x2B	; 43
    2966:	01 c0       	rjmp	.+2      	; 0x296a <vfprintf+0x366>
    2968:	80 e2       	ldi	r24, 0x20	; 32
    296a:	a7 fc       	sbrc	r10, 7
    296c:	8d e2       	ldi	r24, 0x2D	; 45
    296e:	b6 01       	movw	r22, r12
    2970:	90 e0       	ldi	r25, 0x00	; 0
    2972:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    2976:	89 14       	cp	r8, r9
    2978:	38 f4       	brcc	.+14     	; 0x2988 <vfprintf+0x384>
    297a:	b6 01       	movw	r22, r12
    297c:	80 e3       	ldi	r24, 0x30	; 48
    297e:	90 e0       	ldi	r25, 0x00	; 0
    2980:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    2984:	9a 94       	dec	r9
    2986:	f7 cf       	rjmp	.-18     	; 0x2976 <vfprintf+0x372>
    2988:	8a 94       	dec	r8
    298a:	f3 01       	movw	r30, r6
    298c:	e8 0d       	add	r30, r8
    298e:	f1 1d       	adc	r31, r1
    2990:	80 81       	ld	r24, Z
    2992:	b6 01       	movw	r22, r12
    2994:	90 e0       	ldi	r25, 0x00	; 0
    2996:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    299a:	81 10       	cpse	r8, r1
    299c:	f5 cf       	rjmp	.-22     	; 0x2988 <vfprintf+0x384>
    299e:	22 20       	and	r2, r2
    29a0:	09 f4       	brne	.+2      	; 0x29a4 <vfprintf+0x3a0>
    29a2:	42 ce       	rjmp	.-892    	; 0x2628 <vfprintf+0x24>
    29a4:	b6 01       	movw	r22, r12
    29a6:	80 e2       	ldi	r24, 0x20	; 32
    29a8:	90 e0       	ldi	r25, 0x00	; 0
    29aa:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <fputc>
    29ae:	2a 94       	dec	r2
    29b0:	f6 cf       	rjmp	.-20     	; 0x299e <vfprintf+0x39a>
    29b2:	f6 01       	movw	r30, r12
    29b4:	86 81       	ldd	r24, Z+6	; 0x06
    29b6:	97 81       	ldd	r25, Z+7	; 0x07
    29b8:	02 c0       	rjmp	.+4      	; 0x29be <vfprintf+0x3ba>
    29ba:	8f ef       	ldi	r24, 0xFF	; 255
    29bc:	9f ef       	ldi	r25, 0xFF	; 255
    29be:	2b 96       	adiw	r28, 0x0b	; 11
    29c0:	e2 e1       	ldi	r30, 0x12	; 18
    29c2:	0c 94 af 15 	jmp	0x2b5e	; 0x2b5e <__epilogue_restores__>

000029c6 <strnlen_P>:
    29c6:	fc 01       	movw	r30, r24
    29c8:	05 90       	lpm	r0, Z+
    29ca:	61 50       	subi	r22, 0x01	; 1
    29cc:	70 40       	sbci	r23, 0x00	; 0
    29ce:	01 10       	cpse	r0, r1
    29d0:	d8 f7       	brcc	.-10     	; 0x29c8 <strnlen_P+0x2>
    29d2:	80 95       	com	r24
    29d4:	90 95       	com	r25
    29d6:	8e 0f       	add	r24, r30
    29d8:	9f 1f       	adc	r25, r31
    29da:	08 95       	ret

000029dc <strnlen>:
    29dc:	fc 01       	movw	r30, r24
    29de:	61 50       	subi	r22, 0x01	; 1
    29e0:	70 40       	sbci	r23, 0x00	; 0
    29e2:	01 90       	ld	r0, Z+
    29e4:	01 10       	cpse	r0, r1
    29e6:	d8 f7       	brcc	.-10     	; 0x29de <strnlen+0x2>
    29e8:	80 95       	com	r24
    29ea:	90 95       	com	r25
    29ec:	8e 0f       	add	r24, r30
    29ee:	9f 1f       	adc	r25, r31
    29f0:	08 95       	ret

000029f2 <fputc>:
    29f2:	0f 93       	push	r16
    29f4:	1f 93       	push	r17
    29f6:	cf 93       	push	r28
    29f8:	df 93       	push	r29
    29fa:	fb 01       	movw	r30, r22
    29fc:	23 81       	ldd	r18, Z+3	; 0x03
    29fe:	21 fd       	sbrc	r18, 1
    2a00:	03 c0       	rjmp	.+6      	; 0x2a08 <fputc+0x16>
    2a02:	8f ef       	ldi	r24, 0xFF	; 255
    2a04:	9f ef       	ldi	r25, 0xFF	; 255
    2a06:	2c c0       	rjmp	.+88     	; 0x2a60 <fputc+0x6e>
    2a08:	22 ff       	sbrs	r18, 2
    2a0a:	16 c0       	rjmp	.+44     	; 0x2a38 <fputc+0x46>
    2a0c:	46 81       	ldd	r20, Z+6	; 0x06
    2a0e:	57 81       	ldd	r21, Z+7	; 0x07
    2a10:	24 81       	ldd	r18, Z+4	; 0x04
    2a12:	35 81       	ldd	r19, Z+5	; 0x05
    2a14:	42 17       	cp	r20, r18
    2a16:	53 07       	cpc	r21, r19
    2a18:	44 f4       	brge	.+16     	; 0x2a2a <fputc+0x38>
    2a1a:	a0 81       	ld	r26, Z
    2a1c:	b1 81       	ldd	r27, Z+1	; 0x01
    2a1e:	9d 01       	movw	r18, r26
    2a20:	2f 5f       	subi	r18, 0xFF	; 255
    2a22:	3f 4f       	sbci	r19, 0xFF	; 255
    2a24:	31 83       	std	Z+1, r19	; 0x01
    2a26:	20 83       	st	Z, r18
    2a28:	8c 93       	st	X, r24
    2a2a:	26 81       	ldd	r18, Z+6	; 0x06
    2a2c:	37 81       	ldd	r19, Z+7	; 0x07
    2a2e:	2f 5f       	subi	r18, 0xFF	; 255
    2a30:	3f 4f       	sbci	r19, 0xFF	; 255
    2a32:	37 83       	std	Z+7, r19	; 0x07
    2a34:	26 83       	std	Z+6, r18	; 0x06
    2a36:	14 c0       	rjmp	.+40     	; 0x2a60 <fputc+0x6e>
    2a38:	8b 01       	movw	r16, r22
    2a3a:	ec 01       	movw	r28, r24
    2a3c:	fb 01       	movw	r30, r22
    2a3e:	00 84       	ldd	r0, Z+8	; 0x08
    2a40:	f1 85       	ldd	r31, Z+9	; 0x09
    2a42:	e0 2d       	mov	r30, r0
    2a44:	09 95       	icall
    2a46:	89 2b       	or	r24, r25
    2a48:	e1 f6       	brne	.-72     	; 0x2a02 <fputc+0x10>
    2a4a:	d8 01       	movw	r26, r16
    2a4c:	16 96       	adiw	r26, 0x06	; 6
    2a4e:	8d 91       	ld	r24, X+
    2a50:	9c 91       	ld	r25, X
    2a52:	17 97       	sbiw	r26, 0x07	; 7
    2a54:	01 96       	adiw	r24, 0x01	; 1
    2a56:	17 96       	adiw	r26, 0x07	; 7
    2a58:	9c 93       	st	X, r25
    2a5a:	8e 93       	st	-X, r24
    2a5c:	16 97       	sbiw	r26, 0x06	; 6
    2a5e:	ce 01       	movw	r24, r28
    2a60:	df 91       	pop	r29
    2a62:	cf 91       	pop	r28
    2a64:	1f 91       	pop	r17
    2a66:	0f 91       	pop	r16
    2a68:	08 95       	ret

00002a6a <__ultoa_invert>:
    2a6a:	fa 01       	movw	r30, r20
    2a6c:	aa 27       	eor	r26, r26
    2a6e:	28 30       	cpi	r18, 0x08	; 8
    2a70:	51 f1       	breq	.+84     	; 0x2ac6 <__ultoa_invert+0x5c>
    2a72:	20 31       	cpi	r18, 0x10	; 16
    2a74:	81 f1       	breq	.+96     	; 0x2ad6 <__ultoa_invert+0x6c>
    2a76:	e8 94       	clt
    2a78:	6f 93       	push	r22
    2a7a:	6e 7f       	andi	r22, 0xFE	; 254
    2a7c:	6e 5f       	subi	r22, 0xFE	; 254
    2a7e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a80:	8f 4f       	sbci	r24, 0xFF	; 255
    2a82:	9f 4f       	sbci	r25, 0xFF	; 255
    2a84:	af 4f       	sbci	r26, 0xFF	; 255
    2a86:	b1 e0       	ldi	r27, 0x01	; 1
    2a88:	3e d0       	rcall	.+124    	; 0x2b06 <__ultoa_invert+0x9c>
    2a8a:	b4 e0       	ldi	r27, 0x04	; 4
    2a8c:	3c d0       	rcall	.+120    	; 0x2b06 <__ultoa_invert+0x9c>
    2a8e:	67 0f       	add	r22, r23
    2a90:	78 1f       	adc	r23, r24
    2a92:	89 1f       	adc	r24, r25
    2a94:	9a 1f       	adc	r25, r26
    2a96:	a1 1d       	adc	r26, r1
    2a98:	68 0f       	add	r22, r24
    2a9a:	79 1f       	adc	r23, r25
    2a9c:	8a 1f       	adc	r24, r26
    2a9e:	91 1d       	adc	r25, r1
    2aa0:	a1 1d       	adc	r26, r1
    2aa2:	6a 0f       	add	r22, r26
    2aa4:	71 1d       	adc	r23, r1
    2aa6:	81 1d       	adc	r24, r1
    2aa8:	91 1d       	adc	r25, r1
    2aaa:	a1 1d       	adc	r26, r1
    2aac:	20 d0       	rcall	.+64     	; 0x2aee <__ultoa_invert+0x84>
    2aae:	09 f4       	brne	.+2      	; 0x2ab2 <__ultoa_invert+0x48>
    2ab0:	68 94       	set
    2ab2:	3f 91       	pop	r19
    2ab4:	2a e0       	ldi	r18, 0x0A	; 10
    2ab6:	26 9f       	mul	r18, r22
    2ab8:	11 24       	eor	r1, r1
    2aba:	30 19       	sub	r19, r0
    2abc:	30 5d       	subi	r19, 0xD0	; 208
    2abe:	31 93       	st	Z+, r19
    2ac0:	de f6       	brtc	.-74     	; 0x2a78 <__ultoa_invert+0xe>
    2ac2:	cf 01       	movw	r24, r30
    2ac4:	08 95       	ret
    2ac6:	46 2f       	mov	r20, r22
    2ac8:	47 70       	andi	r20, 0x07	; 7
    2aca:	40 5d       	subi	r20, 0xD0	; 208
    2acc:	41 93       	st	Z+, r20
    2ace:	b3 e0       	ldi	r27, 0x03	; 3
    2ad0:	0f d0       	rcall	.+30     	; 0x2af0 <__ultoa_invert+0x86>
    2ad2:	c9 f7       	brne	.-14     	; 0x2ac6 <__ultoa_invert+0x5c>
    2ad4:	f6 cf       	rjmp	.-20     	; 0x2ac2 <__ultoa_invert+0x58>
    2ad6:	46 2f       	mov	r20, r22
    2ad8:	4f 70       	andi	r20, 0x0F	; 15
    2ada:	40 5d       	subi	r20, 0xD0	; 208
    2adc:	4a 33       	cpi	r20, 0x3A	; 58
    2ade:	18 f0       	brcs	.+6      	; 0x2ae6 <__ultoa_invert+0x7c>
    2ae0:	49 5d       	subi	r20, 0xD9	; 217
    2ae2:	31 fd       	sbrc	r19, 1
    2ae4:	40 52       	subi	r20, 0x20	; 32
    2ae6:	41 93       	st	Z+, r20
    2ae8:	02 d0       	rcall	.+4      	; 0x2aee <__ultoa_invert+0x84>
    2aea:	a9 f7       	brne	.-22     	; 0x2ad6 <__ultoa_invert+0x6c>
    2aec:	ea cf       	rjmp	.-44     	; 0x2ac2 <__ultoa_invert+0x58>
    2aee:	b4 e0       	ldi	r27, 0x04	; 4
    2af0:	a6 95       	lsr	r26
    2af2:	97 95       	ror	r25
    2af4:	87 95       	ror	r24
    2af6:	77 95       	ror	r23
    2af8:	67 95       	ror	r22
    2afa:	ba 95       	dec	r27
    2afc:	c9 f7       	brne	.-14     	; 0x2af0 <__ultoa_invert+0x86>
    2afe:	00 97       	sbiw	r24, 0x00	; 0
    2b00:	61 05       	cpc	r22, r1
    2b02:	71 05       	cpc	r23, r1
    2b04:	08 95       	ret
    2b06:	9b 01       	movw	r18, r22
    2b08:	ac 01       	movw	r20, r24
    2b0a:	0a 2e       	mov	r0, r26
    2b0c:	06 94       	lsr	r0
    2b0e:	57 95       	ror	r21
    2b10:	47 95       	ror	r20
    2b12:	37 95       	ror	r19
    2b14:	27 95       	ror	r18
    2b16:	ba 95       	dec	r27
    2b18:	c9 f7       	brne	.-14     	; 0x2b0c <__ultoa_invert+0xa2>
    2b1a:	62 0f       	add	r22, r18
    2b1c:	73 1f       	adc	r23, r19
    2b1e:	84 1f       	adc	r24, r20
    2b20:	95 1f       	adc	r25, r21
    2b22:	a0 1d       	adc	r26, r0
    2b24:	08 95       	ret

00002b26 <__prologue_saves__>:
    2b26:	2f 92       	push	r2
    2b28:	3f 92       	push	r3
    2b2a:	4f 92       	push	r4
    2b2c:	5f 92       	push	r5
    2b2e:	6f 92       	push	r6
    2b30:	7f 92       	push	r7
    2b32:	8f 92       	push	r8
    2b34:	9f 92       	push	r9
    2b36:	af 92       	push	r10
    2b38:	bf 92       	push	r11
    2b3a:	cf 92       	push	r12
    2b3c:	df 92       	push	r13
    2b3e:	ef 92       	push	r14
    2b40:	ff 92       	push	r15
    2b42:	0f 93       	push	r16
    2b44:	1f 93       	push	r17
    2b46:	cf 93       	push	r28
    2b48:	df 93       	push	r29
    2b4a:	cd b7       	in	r28, 0x3d	; 61
    2b4c:	de b7       	in	r29, 0x3e	; 62
    2b4e:	ca 1b       	sub	r28, r26
    2b50:	db 0b       	sbc	r29, r27
    2b52:	0f b6       	in	r0, 0x3f	; 63
    2b54:	f8 94       	cli
    2b56:	de bf       	out	0x3e, r29	; 62
    2b58:	0f be       	out	0x3f, r0	; 63
    2b5a:	cd bf       	out	0x3d, r28	; 61
    2b5c:	09 94       	ijmp

00002b5e <__epilogue_restores__>:
    2b5e:	2a 88       	ldd	r2, Y+18	; 0x12
    2b60:	39 88       	ldd	r3, Y+17	; 0x11
    2b62:	48 88       	ldd	r4, Y+16	; 0x10
    2b64:	5f 84       	ldd	r5, Y+15	; 0x0f
    2b66:	6e 84       	ldd	r6, Y+14	; 0x0e
    2b68:	7d 84       	ldd	r7, Y+13	; 0x0d
    2b6a:	8c 84       	ldd	r8, Y+12	; 0x0c
    2b6c:	9b 84       	ldd	r9, Y+11	; 0x0b
    2b6e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2b70:	b9 84       	ldd	r11, Y+9	; 0x09
    2b72:	c8 84       	ldd	r12, Y+8	; 0x08
    2b74:	df 80       	ldd	r13, Y+7	; 0x07
    2b76:	ee 80       	ldd	r14, Y+6	; 0x06
    2b78:	fd 80       	ldd	r15, Y+5	; 0x05
    2b7a:	0c 81       	ldd	r16, Y+4	; 0x04
    2b7c:	1b 81       	ldd	r17, Y+3	; 0x03
    2b7e:	aa 81       	ldd	r26, Y+2	; 0x02
    2b80:	b9 81       	ldd	r27, Y+1	; 0x01
    2b82:	ce 0f       	add	r28, r30
    2b84:	d1 1d       	adc	r29, r1
    2b86:	0f b6       	in	r0, 0x3f	; 63
    2b88:	f8 94       	cli
    2b8a:	de bf       	out	0x3e, r29	; 62
    2b8c:	0f be       	out	0x3f, r0	; 63
    2b8e:	cd bf       	out	0x3d, r28	; 61
    2b90:	ed 01       	movw	r28, r26
    2b92:	08 95       	ret

00002b94 <_exit>:
    2b94:	f8 94       	cli

00002b96 <__stop_program>:
    2b96:	ff cf       	rjmp	.-2      	; 0x2b96 <__stop_program>
